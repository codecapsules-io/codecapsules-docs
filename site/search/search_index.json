{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started with Code Capsules Code Capsules lets you deploy your GitHub projects to production automatically. Dive directly into our reference documentation or get started by following one of our tutorials . Deployment guides If you're looking to deploy a specific framework, you can find guides on how to do so on our deployment pages FAQ Visit our FAQ to get answers to the questions our new users usually ask. Comparisons and Community Get to know us and the services we offer better by checking out our Comparisons and Community pages. If you need help with anything, join our Slack commuinty .","title":"Getting Started"},{"location":"#getting-started-with-code-capsules","text":"Code Capsules lets you deploy your GitHub projects to production automatically. Dive directly into our reference documentation or get started by following one of our tutorials .","title":"Getting Started with Code Capsules"},{"location":"#deployment-guides","text":"If you're looking to deploy a specific framework, you can find guides on how to do so on our deployment pages","title":"Deployment guides"},{"location":"#faq","text":"Visit our FAQ to get answers to the questions our new users usually ask.","title":"FAQ"},{"location":"#comparisons-and-community","text":"Get to know us and the services we offer better by checking out our Comparisons and Community pages. If you need help with anything, join our Slack commuinty .","title":"Comparisons and Community"},{"location":"FAQ/how-to-add-custom-domain/","text":"How Do I Add a Custom Domain to My Application? If you have purchased a domain from a domain registrar, you may route any application hosted on Code Capsules free of charge. To add a custom domain, navigate to the Capsule containing the application which you'd like to add a custom domain to. Find and click on the \"Overview\" tab. In the Overview tab, you can see your default Code Capsules URL under \"Domains\". Below, there is an \"Add a Custom Domain\" button. Click it. Then: Save the IP address under \"A Record Route\". Enter the root domain (no subdomain) of the domain you've purchased. Click \"Create Domain\". With the IP address saved previously, create an A record pointing to the IP address. Visit your domain registrar for further instructions on creating an A record. After creating an A record pointing to the IP address, allow up to four hours for the changes to propagate before your domain routes to your application. For further information on custom domains, refer to this document explaining the ins and outs of adding custom domains and subdomains to your applications hosted on Code Capsules.","title":"How Do I Add a Custom Domain?"},{"location":"FAQ/how-to-add-custom-domain/#how-do-i-add-a-custom-domain-to-my-application","text":"If you have purchased a domain from a domain registrar, you may route any application hosted on Code Capsules free of charge. To add a custom domain, navigate to the Capsule containing the application which you'd like to add a custom domain to. Find and click on the \"Overview\" tab. In the Overview tab, you can see your default Code Capsules URL under \"Domains\". Below, there is an \"Add a Custom Domain\" button. Click it. Then: Save the IP address under \"A Record Route\". Enter the root domain (no subdomain) of the domain you've purchased. Click \"Create Domain\". With the IP address saved previously, create an A record pointing to the IP address. Visit your domain registrar for further instructions on creating an A record. After creating an A record pointing to the IP address, allow up to four hours for the changes to propagate before your domain routes to your application. For further information on custom domains, refer to this document explaining the ins and outs of adding custom domains and subdomains to your applications hosted on Code Capsules.","title":"How Do I Add a Custom Domain to My Application?"},{"location":"FAQ/teams-spaces-capsules/","text":"Teams, Spaces, and Capsules Teams , Spaces , and Capsules are the foundation of Code Capsules . \" Teams contain Spaces and Spaces contain Capsules \". Teams are to organize people. Multiple people can join your Team, and each member of the Team can interact with the Spaces and Capsules that the Team contains. Furthermore, Teams are associated with a payment method \u2013 you add a credit card to a Team, and Code Capsules bills this credit card when a charge incurs. Spaces are the second layer of organization. Spaces can contain any amount of Capsules and are excellent tools for larger projects. If your project involves complicated frontend and backend code, splitting your code into multiple Capsules \u2013 each within the same space \u2013 may help with organization. Capsules provide the actual computational power for running your applications. While Teams and Spaces are organizational tools, Capsules connect to GitHub repositories containing your applications and hosts them on a server. Capsules can run both frontend and backend applications. For a single, simple project, you would have exactly one team, containing one space, containing one capsule. If you wanted to set up a frontend only project (e.g. a React app) backed by a REST API, you would have two capsules in your space: a frontend Capsule for the React application and a backend Capsule for the REST API.","title":"Teams, Spaces and Capsules"},{"location":"FAQ/teams-spaces-capsules/#teams-spaces-and-capsules","text":"Teams , Spaces , and Capsules are the foundation of Code Capsules . \" Teams contain Spaces and Spaces contain Capsules \". Teams are to organize people. Multiple people can join your Team, and each member of the Team can interact with the Spaces and Capsules that the Team contains. Furthermore, Teams are associated with a payment method \u2013 you add a credit card to a Team, and Code Capsules bills this credit card when a charge incurs. Spaces are the second layer of organization. Spaces can contain any amount of Capsules and are excellent tools for larger projects. If your project involves complicated frontend and backend code, splitting your code into multiple Capsules \u2013 each within the same space \u2013 may help with organization. Capsules provide the actual computational power for running your applications. While Teams and Spaces are organizational tools, Capsules connect to GitHub repositories containing your applications and hosts them on a server. Capsules can run both frontend and backend applications. For a single, simple project, you would have exactly one team, containing one space, containing one capsule. If you wanted to set up a frontend only project (e.g. a React app) backed by a REST API, you would have two capsules in your space: a frontend Capsule for the React application and a backend Capsule for the REST API.","title":"Teams, Spaces, and Capsules"},{"location":"FAQ/what-is-a-capsule/","text":"What is a Capsule? A Capsule provides the actual server for running your applications. Code Capsules offers two distinct Capsule types: Frontend Capsules and Backend Capsules. Frontend Capsules deploy Angular, React, Vue, or static content from the GitHub repository housing your application. Backend Capsules deploy Node.js, Java, or Python applications from the GitHub repository containing your code. Capsules automatically build and deploy upon creation. One can monitor the build process by navigating to the \"Logs\" tab, or by pressing \"View build log\" under the \"Build and Deploy\" tab. Upon deployment, an HTTPS subdomain is generated for the Capsule. The subdomain assigned to the app is available in the \"Config\" tab. Clicking on the subdomain will open the link in a new tab. You can turn Capsules off by toggling the switch at the top right of the Capsule view (next to \"Live Website\").","title":"What is a Capsule?"},{"location":"FAQ/what-is-a-capsule/#what-is-a-capsule","text":"A Capsule provides the actual server for running your applications. Code Capsules offers two distinct Capsule types: Frontend Capsules and Backend Capsules. Frontend Capsules deploy Angular, React, Vue, or static content from the GitHub repository housing your application. Backend Capsules deploy Node.js, Java, or Python applications from the GitHub repository containing your code. Capsules automatically build and deploy upon creation. One can monitor the build process by navigating to the \"Logs\" tab, or by pressing \"View build log\" under the \"Build and Deploy\" tab. Upon deployment, an HTTPS subdomain is generated for the Capsule. The subdomain assigned to the app is available in the \"Config\" tab. Clicking on the subdomain will open the link in a new tab. You can turn Capsules off by toggling the switch at the top right of the Capsule view (next to \"Live Website\").","title":"What is a Capsule?"},{"location":"FAQ/what-is-a-space/","text":"What is a Space? Spaces are an organizational tool for Capsules . Each Space can contain any number of Capsules. Spaces come in handy when working with a large project \u2013 it may be useful to split the project into multiple Capsules.","title":"What is a Space?"},{"location":"FAQ/what-is-a-space/#what-is-a-space","text":"Spaces are an organizational tool for Capsules . Each Space can contain any number of Capsules. Spaces come in handy when working with a large project \u2013 it may be useful to split the project into multiple Capsules.","title":"What is a Space?"},{"location":"FAQ/what-is-a-team/","text":"What is a Team? Code Capsules provides Teams for collaborative development. Multiple members may belong to a team. A Team may contain multiple Spaces and Capsules . Members of the Team can interact with these Spaces and Capsules. Furthermore, Teams handle the payment for all of its Capsules. You set up a payment method for the entire Team (a credit card), and Code Capsules charges that payment method appropriately.","title":"What is a Team?"},{"location":"FAQ/what-is-a-team/#what-is-a-team","text":"Code Capsules provides Teams for collaborative development. Multiple members may belong to a team. A Team may contain multiple Spaces and Capsules . Members of the Team can interact with these Spaces and Capsules. Furthermore, Teams handle the payment for all of its Capsules. You set up a payment method for the entire Team (a credit card), and Code Capsules charges that payment method appropriately.","title":"What is a Team?"},{"location":"community/codecapsules-hack-days/","text":"Code Capsules Hack Days and Free Tech Consulting Every Friday we run an informal \"hack day\" in our Slack from 2pm (UTC+2) onwards. This is a time where people from the dev community can come and share side projects (or main projects) that they are working on, get feedback from peers, or get help from our team on anything they need. Drop in to say hi or stay and work with us for a few hours - it's a safe space and supportive environment :) People work on everything from their dev portfolios to machine learning projects. Some people post 'live updates' of what they're working on for others to follow along, and others simply observe. For beginners, we have a series of tutorials that you can work through and get realtime help if you get stuck. Gareth Dwyer and Miki von Ketelhodt as well as others with expertise ranging through software engineering, design, DevOps, and startups will be available to help you out, give you feedback, or answer your questions on anything tech related. Join our Slack and come say hi.","title":"Hack Days and Free Tech Consulting"},{"location":"community/codecapsules-hack-days/#code-capsules-hack-days-and-free-tech-consulting","text":"Every Friday we run an informal \"hack day\" in our Slack from 2pm (UTC+2) onwards. This is a time where people from the dev community can come and share side projects (or main projects) that they are working on, get feedback from peers, or get help from our team on anything they need. Drop in to say hi or stay and work with us for a few hours - it's a safe space and supportive environment :) People work on everything from their dev portfolios to machine learning projects. Some people post 'live updates' of what they're working on for others to follow along, and others simply observe. For beginners, we have a series of tutorials that you can work through and get realtime help if you get stuck. Gareth Dwyer and Miki von Ketelhodt as well as others with expertise ranging through software engineering, design, DevOps, and startups will be available to help you out, give you feedback, or answer your questions on anything tech related. Join our Slack and come say hi.","title":"Code Capsules Hack Days and Free Tech Consulting"},{"location":"community/founder-fridays/","text":"Founder Fridays We are starting an experimental 'Founder Fridays' weekly meetup. We'll have a group Zoom call 1pm-2pm SAST on Fridays, followed by some time for founders to do focused work while getting help at our Slack . The first cohort will run for four weeks, and contain a maximum of 6 founders Founders should be early stage - have something more than 'just an idea' but probably not yet generating substantial revenue. Founders will talk about challenges, share goals, and help each other. Code Capsules will provide free technical and startup consulting / mentoring, and credits for Code Capsules hosting (PaaS + database). Details To apply, fill out this form by Tuesday 13 July 13h00 SAST and join the #founder-fridays channel of our Slack . We will select up to six applicants and send out invitations by Wednesday, 14 July 17h00 SAST. We will run for four weeks for the first cohort, but aim to start a second cohort directly after. On the first call, each participant will set a goal for the week as well as an overall goal for the four-week period. Every week, each participant will share progress on the intermediate goal and set a new subgoal for the following week. Participants will demonstrate their product and get early feedback from their peers. If the time doesn't suit you, or you are not selected, feel free to join our Friday Hackdays instead which will continue to run in parallel.","title":"Founder Fridays"},{"location":"community/founder-fridays/#founder-fridays","text":"We are starting an experimental 'Founder Fridays' weekly meetup. We'll have a group Zoom call 1pm-2pm SAST on Fridays, followed by some time for founders to do focused work while getting help at our Slack . The first cohort will run for four weeks, and contain a maximum of 6 founders Founders should be early stage - have something more than 'just an idea' but probably not yet generating substantial revenue. Founders will talk about challenges, share goals, and help each other. Code Capsules will provide free technical and startup consulting / mentoring, and credits for Code Capsules hosting (PaaS + database).","title":"Founder Fridays"},{"location":"community/founder-fridays/#details","text":"To apply, fill out this form by Tuesday 13 July 13h00 SAST and join the #founder-fridays channel of our Slack . We will select up to six applicants and send out invitations by Wednesday, 14 July 17h00 SAST. We will run for four weeks for the first cohort, but aim to start a second cohort directly after. On the first call, each participant will set a goal for the week as well as an overall goal for the four-week period. Every week, each participant will share progress on the intermediate goal and set a new subgoal for the following week. Participants will demonstrate their product and get early feedback from their peers. If the time doesn't suit you, or you are not selected, feel free to join our Friday Hackdays instead which will continue to run in parallel.","title":"Details"},{"location":"community/introducing-code-capsules/","text":"Introducing Code Capsules Background We have been huge fans of Serverless for many years. The term exists in many forms, such as PaaS (Platform as a Service) or FaaS (Functions as a Service) and every major cloud has some form of Serverless service, which allows us as developers to continuously integrate and deploy our latest code without worrying about infrastructure. Over the past few years we have enjoyed deploying our backend applications to Heroku and our static Frontend applications to Netlify . We found the developer experiences to be incredible and many of my projects still easily deploy from a git push , even years after initially setting it up. Major Problems we faced as Developers Our company projects at Appstrax are generally deployed and maintained at a variety of cloud providers, from AWS or Heroku to smaller local [to South Africa] shared server environments. This caused a few problems over time for a company like ours. Managing Client Infrastructure Billing We needed to manage the billing for all of our client projects' infrastructure each month. We used to collect all of the invoices from the various cloud providers and divide them up to the relevant client and ultimate re-invoice to recover the costs. This does depend on the client, for us it was mostly non-technical clients that wanted us to manage the infrastructure on their behalf. It would be great if we could just have those non-technical clients enter their payment methods against the relevant cloud resources and get invoiced directly, saving us some admin time. Knowledge Transfer When a team mate left the company, there was a long and involved process to hand over all the correct project information. We needed to make sure we had the right private keys, cloud account logins, documentation and processes to maintain and deploy to the relevant servers. A solution was needed going forward whereby the need for exchanging private keys and account logins was avoided to maintain a projects integrity. Managing SSL certificates Managing SSL certificates and private keys were a nightmare depending on the cloud or platform you were using for that project. We wanted to avoid touching any private keys or server terminals at all and just have every project automate their SSL through something like LetsEncrypt. Context Switch Team mates would often context switch between various cloud providers depending on where the project was located when needing to maintain or fix deployments and infrastructure. If we had one unified dashboard that every team mate was familiar with, our productivity as a company would be heavily improved. Lack of South African PaaS Local South African servers lack decent developer experience when it comes to anything like CI/CD (Continuous Integration & Deployment) and Heroku and Netlify only targeted US or EU servers. We thought it would be epic if we could have one platform that would combine all of our favorite PaaS features into one, while solving some of the above problems for us, especially CI/CD to local South African servers. We started prototyping Code Capsules in 2019 through the use of various cloud-native and open source technologies, which has resulted in the application that is now in an Open Beta status. Deploying a Static Frontend App After installing our Github Application into your Code Capsules user account and team, you are able to easily create a Frontend Capsule in few simple steps. Select your Github Repository and Branch Choose which folder within your Github Repository contains your static app (Angular, React or Vue) Enter the Build Command, which will tell Code Capsules which command to use to generate your static HTML and JavaScript content Enter the resulting Static Content Folder Path (the result of the build command) If you enter the Build Command, you will notice that it runs through the Build Logs on the Capsule Details screen: If you have a plain old HTML and JavaScript app, you may not need a Build Command. You can simply enter the folder path within your Github Repository that contains the index.html file, which Code Capsules will serve up once deployed. Deploying a Backend App Similar to the Frontend Capsule workflow, a few simple steps is all it takes to get your Backend App online: Select your Github Repository and Branch Choose which folder within your Github Repository contains your static app (Node, Python, Java or .NET Core) Enter the Run Command , which will tell Code Capsules which command to use to start your server (ensure your app binds to a PORT environment variable) The Backend Capsule will build your code into a container and try to serve up your application. It also automatically creates a new build and deploy every time push new code to your Github branch. This can be turned off if you prefer to create builds manually. You can view the server logs below: Both Frontend and Backend Capsules will automatically create a free subdomain with an SSL certificate installed. You can choose to point a custom domain to your capsule through either a CNAME or A Record from any DNS provider you may be using. Team Management We have broken down the solution to allow developers to manage their applications and cloud resources that best meets their needs. You can create as many Teams as you want You can create as many Spaces within Teams as you want You can invite users into your Team You can add different payment methods to different teams, which is helpful if you want to link your clients credit card directly to the Team You can view invoices broken down by Team You can manage Github Repositories per Team Check out our Documentation and Tutorials if you are keen to give it a go. Every Personal Team can enjoy a Free Frontend Capsule to give our new platform a try . We would love to hear any and all feedback (join us on our Slack Team ) so that we can improve our solution and hopefully add value to other developers \ud83d\ude80.","title":"Introducing Code Capsules"},{"location":"community/introducing-code-capsules/#introducing-code-capsules","text":"","title":"Introducing Code Capsules"},{"location":"community/introducing-code-capsules/#background","text":"We have been huge fans of Serverless for many years. The term exists in many forms, such as PaaS (Platform as a Service) or FaaS (Functions as a Service) and every major cloud has some form of Serverless service, which allows us as developers to continuously integrate and deploy our latest code without worrying about infrastructure. Over the past few years we have enjoyed deploying our backend applications to Heroku and our static Frontend applications to Netlify . We found the developer experiences to be incredible and many of my projects still easily deploy from a git push , even years after initially setting it up.","title":"Background"},{"location":"community/introducing-code-capsules/#major-problems-we-faced-as-developers","text":"Our company projects at Appstrax are generally deployed and maintained at a variety of cloud providers, from AWS or Heroku to smaller local [to South Africa] shared server environments. This caused a few problems over time for a company like ours.","title":"Major Problems we faced as Developers"},{"location":"community/introducing-code-capsules/#managing-client-infrastructure-billing","text":"We needed to manage the billing for all of our client projects' infrastructure each month. We used to collect all of the invoices from the various cloud providers and divide them up to the relevant client and ultimate re-invoice to recover the costs. This does depend on the client, for us it was mostly non-technical clients that wanted us to manage the infrastructure on their behalf. It would be great if we could just have those non-technical clients enter their payment methods against the relevant cloud resources and get invoiced directly, saving us some admin time.","title":"Managing Client Infrastructure Billing"},{"location":"community/introducing-code-capsules/#knowledge-transfer","text":"When a team mate left the company, there was a long and involved process to hand over all the correct project information. We needed to make sure we had the right private keys, cloud account logins, documentation and processes to maintain and deploy to the relevant servers. A solution was needed going forward whereby the need for exchanging private keys and account logins was avoided to maintain a projects integrity.","title":"Knowledge Transfer"},{"location":"community/introducing-code-capsules/#managing-ssl-certificates","text":"Managing SSL certificates and private keys were a nightmare depending on the cloud or platform you were using for that project. We wanted to avoid touching any private keys or server terminals at all and just have every project automate their SSL through something like LetsEncrypt.","title":"Managing SSL certificates"},{"location":"community/introducing-code-capsules/#context-switch","text":"Team mates would often context switch between various cloud providers depending on where the project was located when needing to maintain or fix deployments and infrastructure. If we had one unified dashboard that every team mate was familiar with, our productivity as a company would be heavily improved.","title":"Context Switch"},{"location":"community/introducing-code-capsules/#lack-of-south-african-paas","text":"Local South African servers lack decent developer experience when it comes to anything like CI/CD (Continuous Integration & Deployment) and Heroku and Netlify only targeted US or EU servers. We thought it would be epic if we could have one platform that would combine all of our favorite PaaS features into one, while solving some of the above problems for us, especially CI/CD to local South African servers. We started prototyping Code Capsules in 2019 through the use of various cloud-native and open source technologies, which has resulted in the application that is now in an Open Beta status.","title":"Lack of South African PaaS"},{"location":"community/introducing-code-capsules/#deploying-a-static-frontend-app","text":"After installing our Github Application into your Code Capsules user account and team, you are able to easily create a Frontend Capsule in few simple steps. Select your Github Repository and Branch Choose which folder within your Github Repository contains your static app (Angular, React or Vue) Enter the Build Command, which will tell Code Capsules which command to use to generate your static HTML and JavaScript content Enter the resulting Static Content Folder Path (the result of the build command) If you enter the Build Command, you will notice that it runs through the Build Logs on the Capsule Details screen: If you have a plain old HTML and JavaScript app, you may not need a Build Command. You can simply enter the folder path within your Github Repository that contains the index.html file, which Code Capsules will serve up once deployed.","title":"Deploying a Static Frontend App"},{"location":"community/introducing-code-capsules/#deploying-a-backend-app","text":"Similar to the Frontend Capsule workflow, a few simple steps is all it takes to get your Backend App online: Select your Github Repository and Branch Choose which folder within your Github Repository contains your static app (Node, Python, Java or .NET Core) Enter the Run Command , which will tell Code Capsules which command to use to start your server (ensure your app binds to a PORT environment variable) The Backend Capsule will build your code into a container and try to serve up your application. It also automatically creates a new build and deploy every time push new code to your Github branch. This can be turned off if you prefer to create builds manually. You can view the server logs below: Both Frontend and Backend Capsules will automatically create a free subdomain with an SSL certificate installed. You can choose to point a custom domain to your capsule through either a CNAME or A Record from any DNS provider you may be using.","title":"Deploying a Backend App"},{"location":"community/introducing-code-capsules/#team-management","text":"We have broken down the solution to allow developers to manage their applications and cloud resources that best meets their needs. You can create as many Teams as you want You can create as many Spaces within Teams as you want You can invite users into your Team You can add different payment methods to different teams, which is helpful if you want to link your clients credit card directly to the Team You can view invoices broken down by Team You can manage Github Repositories per Team Check out our Documentation and Tutorials if you are keen to give it a go. Every Personal Team can enjoy a Free Frontend Capsule to give our new platform a try . We would love to hear any and all feedback (join us on our Slack Team ) so that we can improve our solution and hopefully add value to other developers \ud83d\ude80.","title":"Team Management"},{"location":"comparisons/","text":"Comparisons Guide Welcome to the Code Capsules Comparisons guide. In this section, you can find comparison articles on common programming paradigms as well as see how Code Capsules compares with other service providers. Comparison Articles PaaS Providers SaaS vs PaaS vs IaaS","title":"Comparisons Guide"},{"location":"comparisons/#comparisons-guide","text":"Welcome to the Code Capsules Comparisons guide. In this section, you can find comparison articles on common programming paradigms as well as see how Code Capsules compares with other service providers.","title":"Comparisons Guide"},{"location":"comparisons/#comparison-articles","text":"PaaS Providers SaaS vs PaaS vs IaaS","title":"Comparison Articles"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/","text":"Comparing PaaS providers: Heroku vs DigitalOcean vs Code Capsules Deploying a web application to a production environment is complicated. Traditionally, you need to set up a web server including the operating system and supporting software and libraries. Then you need to deploy your code, configure it, and monitor it to ensure it keeps running. Because most developers do not want to be so deeply involved in \"operations\", an alternative is to use a Platform-as-a-Service (PaaS) offering. These platforms need only minimal configuration and offer an integration with GitHub or similar so that you, as a developer, can simply push new code to your repository and have it deployed to a production environment automatically. We deployed a basic Python (Flask) web application to three PaaS providers: Heroku, DigitalOcean App Platform, and Code Capsules. In this article, we compare these for ease-of-use and show step-by-step instructions on how to get started with each. The platforms we tested are: Heroku DigitalOcean App Platform Code Capsules This guide will help you decide which platform to choose. We'll start with an overview of the metrics showing how long and how many clicks it took to deploy our simple \"Hello, world!\" application to each provider. Ease-of-use benchmarks We compared each platform on: The time it took to deploy the web application to production on each platform. How complicated each platform's user interface is. How intuitive the platform was to use overall. These measurements are necessarily somewhat subjective, but by following the steps or taking a look at them below, you should be able to form your own opinion too. Timing results To test the simplicity of each platform, we performed the platform-specific steps (as detailed later in this article) twice. Each attempt we recorded how long it took to get from GitHub to production. Attempt # Code Capsules Heroku DigitalOcean 1 7 min 30 sec 10 min 5 sec 12 min 11 sec 2 4 min 45 sec 5 min 2 sec 6 min 1 sec Code Capsules was the fastest in both runs, and also had the least difference in timing between runs, indicating that is simpler than the other two, with a smaller learning curve. Number of clicks We also counted the total number of UI clicks: that is, the number of clicks after creating an account to reach a deployed web application. Code Capsules Heroku DigitalOcean 8 clicks 9 clicks 11 clicks General impressions Heroku's interface was the most complicated, providing many pricing and other options. As the most mature platform of the three, it has acquired more features over time, but these are generally a hinderance if you just want to deploy a basic application. DigitalOcean provided a simpler platform, but requires payment details up front which slows down the initial process. Code Capsules was the simplest for a first-time user. It follows a simple pipeline of three steps to get from GitHub to production. Finally, each platform offers a custom domain name to host your application. DigitalOcean generates a fully random name which can't be changed during the deployment process (though it can be customized later in their settings page.) Heroku allows a customized domain, but as it is the most popular platform it is hard to find an available domain. The first name we chose on Code Capsules was accepted. Step-by-step guide to deploy to each provider Let's take a look at how to create the web application we tested these platforms with, and how to deploy it to the platforms tested. Prerequisites To follow along you should have general programming knowledge and be able to use GitHub. This means you can send code from a local repository to a remote repository. You should also have (instructions at each link): Python version 3.5 or above installed. A GitHub account and Git installed. Python's virtualenv installed . A working credit card to test out DigitalOcean (free of charge). General steps for building the web application The following steps need to be carried out only once for all three providers. They will show you how to install local dependencies and create the \"Hello, world!\" app. Installing virtualenv If you already have virtualenv and know what it does, skip to the next section. Using virtualenv, you can create a virtual Python environment. This virtual environment will contain only the essential modules for your web application. To install virtualenv, open up your terminal and type: pip3 install virtualenv Now that you have a current version of Python, Git, a GitHub account, and virtualenv installed, you can create the \"Hello, world!\" application. Setting up the virtual environment First, create a directory for your project. I named my directory \"helloWorld\". Open your command line, and enter the created directory. Within the directory, create the virtual Python environment by typing virtualenv env . To activate the virtual environment, type the following from within the newly created directory: Linux/MacOSX source env/bin/activate Windows env\\Scripts\\activate.bat Your terminal should now look something like this: Installing Flask and Gunicorn For our web application we'll use two popular Python tools for web development: Flask and Gunicorn : Flask is a lightweight web-development framework for Python. It provides a number of easy-to-use resources and tools for building and maintaining web applications, websites, and similar services. Gunicorn is a WSGI server for sending code to the production environment. Check out this link to read more about WSGI servers . Install these tools with the following pip command. (Ensure you are in your virtual environment before running this command.) pip3 install flask gunicorn Coding the application Now that we have set up our requirements, we can write the code for our application. Create a new Python file within the current directory and name it anything. I named mine \"helloFlask\". Next, enter the following code. from flask import Flask app = Flask ( __name__ ) # __name__ = name of program @app . route ( '/' ) # Display on main page of the domain def hello (): return 'Hello, world!' if __name__ == '__main__' : app . run () This program will display \"Hello, world!\" on the domain hosted by Code Capsules, Heroku, and DigitalOcean. Creating the Procfile A Procfile is necessary to tell our platform of choice what to do with our code. You can read more about what a Procfile does here . Create a new file within the same directory. Name it Procfile. Next, open the Procfile and enter the following code on the first line. web: gunicorn fileName:app Replace \"fileName\" with the name of your Python file. Save the Procfile. Freezing the requirements Our final step before uploading the web application to GitHub is to create a list of requirements for it. This is necessary for the platform to know what to install to run our web application. Luckily, pip makes this easy. In the same terminal, enter pip3 freeze > requirements.txt . This will create a file titled \"requirements.txt\", that contains all the project's requirements. Your directory should look similar to this: ProjectDirectory + env + helloFlask.py + requirements.txt + Procfile Uploading to GitHub Send the Procfile, requirements.txt, and Python files to a remote repository on GitHub. If you are unfamiliar with how to do this, read this article for further information. With our application on GitHub, we will be able to link the repository to each platform we test and deploy our web application. Provider-specific steps Each of the following steps is specific to one of the providers. If you only want to test one of them, skip to that section. Code Capsules Code Capsules is the newest of the three providers and they advertise ease of use as their unique selling point. Creating an account with Code Capsules and connecting to GitHub First, we need to create an account with Code Capsules. Follow these instructions to get started: Go to Code Capsules . Click SIGN UP in the top right corner and follow the instructions. Check your email and confirm your account. Go back to Code Capsules and log into your newly created account. After logging in, Code Capsules brings you to a page that will look similar to this. For now, ignore anything that you see on this picture that isn't on your account. Now that we have created a Code Capsules account, we can connect Code Capsules to our GitHub account. Perform the following: Click your profile name on the top right corner and click Edit profile . Under \"GitHub\" details, click the GitHub button. Under repository access, give Code Capsules access to our recently created repository. We are now connected to GitHub. Navigate back to the main screen. Creating a team, space, and a capsule Code Capsules organizes your code into three distinct containers: Teams Spaces Capsules These are different levels of organization to manage larger projects. For our purposes, we will only need one of each. To create a capsule, we must create a team and space. A team allows you to invite multiple people to collaborate with you. You may assign team members to different spaces, which can contain different capsules. Capsules provide cloud resources such as databases, APIs, and servers. Follow these steps to get your code into production: Create a new team and name it anything. Choose \"Create a New Space For Your Apps\". Select your region (I chose the Netherlands). Choose your name for the space. Your space is now created! Click on your newly created space. Create a new capsule. Choose the \"Backend\" Capsule. Select \"Sandbox\". Select the correct GitHub repository and click Next . Because we have a Procfile in our repository, we do not need to use a run command. Instead, click Create Capsule . Viewing your work Now that you have created a capsule, you can see your website. Click on the Overview button. Your URL is displayed under \"domain\". Enter it into your browser to see your web application! Heroku Heroku provides similar services to Code Capsules and DigitalOcean. Heroku is the original Cloud platform as service (PaaS). Heroku aims to allow developers to focus on their core product, while they take care of the rest. Creating an account with Heroku and creating an application We must first create a Heroku account. Do the following: Go to www.heroku.com. Register an account by clicking Sign up in the top right corner. Log into the registered account. Accept terms of service. Check your email and confirm your account. Now that we have created a Heroku account, we can create an application. An application is similar to a Code Capsules \"capsule\". Go to www.heroku.com and log in. Click Create new app . Choose an app name that is not in use (I chose hello-flask-tutorial). Choose your region (I chose the United States). Click Create app . Connecting to GitHub and sending to production After creating your app, Heroku presents several options to you. Under \"Deployment method\", click GitHub , and follow these steps: Click the connect to GitHub option, and perform the required tasks. Now that you are connected to GitHub, type your repositories name under \"Search for a repository to connect to\". I've named mine \"flask-hello\". Connect to this repository. After connecting, click Deploy Branch in the \"Manual Deploy\" section at the bottom of the page. Wait until it has finished deploying. When the deployment is finished, navigate to the top of the page and click Open app to see the result! DigitalOcean App Platform The DigitalOcean App Platform is another PaaS alternative. It contains the same key features as Code Capsules and Heroku. Creating an account and linking your repository DigitalOcean is the only platform here that requires a credit card. At the time of writing, DigitalOcean offers a free trial worth a $100 credit on their platform, so you will not be charged until the $100 is spent. Ensure that you have canceled your billing account so that you will not be charged in the future. Create a new account by performing these steps: Visit https://www.digitalocean.com/products/app-platform/. Click the Get Started button, and sign up via email. You will now need to enter your payment information. (I chose a credit card.) Click Deploy a GitHub Repo . Click Launch Your App . Choose \"Link your GitHub account\". Log into your GitHub account and press the Only select repositories button. Pick the repository containing your Flask application. Press the Authorize and Install button. From the drop-down menu, choose the repository containing the Flask application. Finishing up and deploying your code DigitalOcean redirects you to a new set of steps. Follow the remaining instructions carefully: Choose your region. (I chose New York.) Pick the proper branch you want to deploy from (default is \"main\"). Change the run command to gunicorn --worker-tmp-dir /dev/shm file:app This is important . Without performing this step, your application will not deploy. Change file to the name of your Python file (mine was helloFlask ). Select the \"Basic\" plan. Press Launch Basic App and your application will now be built. View the application by entering the link under the application's name in your web browser. Conclusion All three providers provide similar features but some of them are easier to use, especially for new users. They each provide auto-deploy functionality, meaning that you can largely forget about them after setup and simply push any changes to your GitHub repository. The integration with GitHub means that the provider will get a notification about the code changes and pull these changes into the production environment.","title":"PaaS Providers"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules","text":"Deploying a web application to a production environment is complicated. Traditionally, you need to set up a web server including the operating system and supporting software and libraries. Then you need to deploy your code, configure it, and monitor it to ensure it keeps running. Because most developers do not want to be so deeply involved in \"operations\", an alternative is to use a Platform-as-a-Service (PaaS) offering. These platforms need only minimal configuration and offer an integration with GitHub or similar so that you, as a developer, can simply push new code to your repository and have it deployed to a production environment automatically. We deployed a basic Python (Flask) web application to three PaaS providers: Heroku, DigitalOcean App Platform, and Code Capsules. In this article, we compare these for ease-of-use and show step-by-step instructions on how to get started with each. The platforms we tested are: Heroku DigitalOcean App Platform Code Capsules This guide will help you decide which platform to choose. We'll start with an overview of the metrics showing how long and how many clicks it took to deploy our simple \"Hello, world!\" application to each provider.","title":"Comparing PaaS providers: Heroku vs DigitalOcean vs Code Capsules"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#ease-of-use-benchmarks","text":"We compared each platform on: The time it took to deploy the web application to production on each platform. How complicated each platform's user interface is. How intuitive the platform was to use overall. These measurements are necessarily somewhat subjective, but by following the steps or taking a look at them below, you should be able to form your own opinion too.","title":"Ease-of-use benchmarks"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#timing-results","text":"To test the simplicity of each platform, we performed the platform-specific steps (as detailed later in this article) twice. Each attempt we recorded how long it took to get from GitHub to production. Attempt # Code Capsules Heroku DigitalOcean 1 7 min 30 sec 10 min 5 sec 12 min 11 sec 2 4 min 45 sec 5 min 2 sec 6 min 1 sec Code Capsules was the fastest in both runs, and also had the least difference in timing between runs, indicating that is simpler than the other two, with a smaller learning curve.","title":"Timing results"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#number-of-clicks","text":"We also counted the total number of UI clicks: that is, the number of clicks after creating an account to reach a deployed web application. Code Capsules Heroku DigitalOcean 8 clicks 9 clicks 11 clicks","title":"Number of clicks"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#general-impressions","text":"Heroku's interface was the most complicated, providing many pricing and other options. As the most mature platform of the three, it has acquired more features over time, but these are generally a hinderance if you just want to deploy a basic application. DigitalOcean provided a simpler platform, but requires payment details up front which slows down the initial process. Code Capsules was the simplest for a first-time user. It follows a simple pipeline of three steps to get from GitHub to production. Finally, each platform offers a custom domain name to host your application. DigitalOcean generates a fully random name which can't be changed during the deployment process (though it can be customized later in their settings page.) Heroku allows a customized domain, but as it is the most popular platform it is hard to find an available domain. The first name we chose on Code Capsules was accepted.","title":"General impressions"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#step-by-step-guide-to-deploy-to-each-provider","text":"Let's take a look at how to create the web application we tested these platforms with, and how to deploy it to the platforms tested.","title":"Step-by-step guide to deploy to each provider"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#prerequisites","text":"To follow along you should have general programming knowledge and be able to use GitHub. This means you can send code from a local repository to a remote repository. You should also have (instructions at each link): Python version 3.5 or above installed. A GitHub account and Git installed. Python's virtualenv installed . A working credit card to test out DigitalOcean (free of charge).","title":"Prerequisites"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#general-steps-for-building-the-web-application","text":"The following steps need to be carried out only once for all three providers. They will show you how to install local dependencies and create the \"Hello, world!\" app.","title":"General steps for building the web application"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#installing-virtualenv","text":"If you already have virtualenv and know what it does, skip to the next section. Using virtualenv, you can create a virtual Python environment. This virtual environment will contain only the essential modules for your web application. To install virtualenv, open up your terminal and type: pip3 install virtualenv Now that you have a current version of Python, Git, a GitHub account, and virtualenv installed, you can create the \"Hello, world!\" application.","title":"Installing virtualenv"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#setting-up-the-virtual-environment","text":"First, create a directory for your project. I named my directory \"helloWorld\". Open your command line, and enter the created directory. Within the directory, create the virtual Python environment by typing virtualenv env . To activate the virtual environment, type the following from within the newly created directory: Linux/MacOSX source env/bin/activate Windows env\\Scripts\\activate.bat Your terminal should now look something like this:","title":"Setting up the virtual environment"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#installing-flask-and-gunicorn","text":"For our web application we'll use two popular Python tools for web development: Flask and Gunicorn : Flask is a lightweight web-development framework for Python. It provides a number of easy-to-use resources and tools for building and maintaining web applications, websites, and similar services. Gunicorn is a WSGI server for sending code to the production environment. Check out this link to read more about WSGI servers . Install these tools with the following pip command. (Ensure you are in your virtual environment before running this command.) pip3 install flask gunicorn","title":"Installing Flask and Gunicorn"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#coding-the-application","text":"Now that we have set up our requirements, we can write the code for our application. Create a new Python file within the current directory and name it anything. I named mine \"helloFlask\". Next, enter the following code. from flask import Flask app = Flask ( __name__ ) # __name__ = name of program @app . route ( '/' ) # Display on main page of the domain def hello (): return 'Hello, world!' if __name__ == '__main__' : app . run () This program will display \"Hello, world!\" on the domain hosted by Code Capsules, Heroku, and DigitalOcean.","title":"Coding the application"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#creating-the-procfile","text":"A Procfile is necessary to tell our platform of choice what to do with our code. You can read more about what a Procfile does here . Create a new file within the same directory. Name it Procfile. Next, open the Procfile and enter the following code on the first line. web: gunicorn fileName:app Replace \"fileName\" with the name of your Python file. Save the Procfile.","title":"Creating the Procfile"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#freezing-the-requirements","text":"Our final step before uploading the web application to GitHub is to create a list of requirements for it. This is necessary for the platform to know what to install to run our web application. Luckily, pip makes this easy. In the same terminal, enter pip3 freeze > requirements.txt . This will create a file titled \"requirements.txt\", that contains all the project's requirements. Your directory should look similar to this: ProjectDirectory + env + helloFlask.py + requirements.txt + Procfile","title":"Freezing the requirements"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#uploading-to-github","text":"Send the Procfile, requirements.txt, and Python files to a remote repository on GitHub. If you are unfamiliar with how to do this, read this article for further information. With our application on GitHub, we will be able to link the repository to each platform we test and deploy our web application.","title":"Uploading to GitHub"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#provider-specific-steps","text":"Each of the following steps is specific to one of the providers. If you only want to test one of them, skip to that section.","title":"Provider-specific steps"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#code-capsules","text":"Code Capsules is the newest of the three providers and they advertise ease of use as their unique selling point.","title":"Code Capsules"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#creating-an-account-with-code-capsules-and-connecting-to-github","text":"First, we need to create an account with Code Capsules. Follow these instructions to get started: Go to Code Capsules . Click SIGN UP in the top right corner and follow the instructions. Check your email and confirm your account. Go back to Code Capsules and log into your newly created account. After logging in, Code Capsules brings you to a page that will look similar to this. For now, ignore anything that you see on this picture that isn't on your account. Now that we have created a Code Capsules account, we can connect Code Capsules to our GitHub account. Perform the following: Click your profile name on the top right corner and click Edit profile . Under \"GitHub\" details, click the GitHub button. Under repository access, give Code Capsules access to our recently created repository. We are now connected to GitHub. Navigate back to the main screen.","title":"Creating an account with Code Capsules and connecting to GitHub"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#creating-a-team-space-and-a-capsule","text":"Code Capsules organizes your code into three distinct containers: Teams Spaces Capsules These are different levels of organization to manage larger projects. For our purposes, we will only need one of each. To create a capsule, we must create a team and space. A team allows you to invite multiple people to collaborate with you. You may assign team members to different spaces, which can contain different capsules. Capsules provide cloud resources such as databases, APIs, and servers. Follow these steps to get your code into production: Create a new team and name it anything. Choose \"Create a New Space For Your Apps\". Select your region (I chose the Netherlands). Choose your name for the space. Your space is now created! Click on your newly created space. Create a new capsule. Choose the \"Backend\" Capsule. Select \"Sandbox\". Select the correct GitHub repository and click Next . Because we have a Procfile in our repository, we do not need to use a run command. Instead, click Create Capsule .","title":"Creating a team, space, and a capsule"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#viewing-your-work","text":"Now that you have created a capsule, you can see your website. Click on the Overview button. Your URL is displayed under \"domain\". Enter it into your browser to see your web application!","title":"Viewing your work"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#heroku","text":"Heroku provides similar services to Code Capsules and DigitalOcean. Heroku is the original Cloud platform as service (PaaS). Heroku aims to allow developers to focus on their core product, while they take care of the rest.","title":"Heroku"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#creating-an-account-with-heroku-and-creating-an-application","text":"We must first create a Heroku account. Do the following: Go to www.heroku.com. Register an account by clicking Sign up in the top right corner. Log into the registered account. Accept terms of service. Check your email and confirm your account. Now that we have created a Heroku account, we can create an application. An application is similar to a Code Capsules \"capsule\". Go to www.heroku.com and log in. Click Create new app . Choose an app name that is not in use (I chose hello-flask-tutorial). Choose your region (I chose the United States). Click Create app .","title":"Creating an account with Heroku and creating an application"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#connecting-to-github-and-sending-to-production","text":"After creating your app, Heroku presents several options to you. Under \"Deployment method\", click GitHub , and follow these steps: Click the connect to GitHub option, and perform the required tasks. Now that you are connected to GitHub, type your repositories name under \"Search for a repository to connect to\". I've named mine \"flask-hello\". Connect to this repository. After connecting, click Deploy Branch in the \"Manual Deploy\" section at the bottom of the page. Wait until it has finished deploying. When the deployment is finished, navigate to the top of the page and click Open app to see the result!","title":"Connecting to GitHub and sending to production"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#digitalocean-app-platform","text":"The DigitalOcean App Platform is another PaaS alternative. It contains the same key features as Code Capsules and Heroku.","title":"DigitalOcean App Platform"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#creating-an-account-and-linking-your-repository","text":"DigitalOcean is the only platform here that requires a credit card. At the time of writing, DigitalOcean offers a free trial worth a $100 credit on their platform, so you will not be charged until the $100 is spent. Ensure that you have canceled your billing account so that you will not be charged in the future. Create a new account by performing these steps: Visit https://www.digitalocean.com/products/app-platform/. Click the Get Started button, and sign up via email. You will now need to enter your payment information. (I chose a credit card.) Click Deploy a GitHub Repo . Click Launch Your App . Choose \"Link your GitHub account\". Log into your GitHub account and press the Only select repositories button. Pick the repository containing your Flask application. Press the Authorize and Install button. From the drop-down menu, choose the repository containing the Flask application.","title":"Creating an account and linking your repository"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#finishing-up-and-deploying-your-code","text":"DigitalOcean redirects you to a new set of steps. Follow the remaining instructions carefully: Choose your region. (I chose New York.) Pick the proper branch you want to deploy from (default is \"main\"). Change the run command to gunicorn --worker-tmp-dir /dev/shm file:app This is important . Without performing this step, your application will not deploy. Change file to the name of your Python file (mine was helloFlask ). Select the \"Basic\" plan. Press Launch Basic App and your application will now be built. View the application by entering the link under the application's name in your web browser.","title":"Finishing up and deploying your code"},{"location":"comparisons/comparing-paas-providers-heroku-vs-digitalocean-vs-code-capsules/#conclusion","text":"All three providers provide similar features but some of them are easier to use, especially for new users. They each provide auto-deploy functionality, meaning that you can largely forget about them after setup and simply push any changes to your GitHub repository. The integration with GitHub means that the provider will get a notification about the code changes and pull these changes into the production environment.","title":"Conclusion"},{"location":"comparisons/saas-paas-iaas/","text":"SaaS vs PaaS vs IaaS If you've spent any amount of time trying out or researching cloud services, you've probably come across acronyms like SaaS, PaaS and IaaS. Respectively, these are: Software as a Service Platform as a Service Infrastructure as a Service But what do any of these terms actually mean? And what's the difference between them? In this article, we will provide a practical, hands-on overview of the differences, strengths and weaknesses of these three types of cloud services. We will add examples of each, and the types of things you might build with them. Let's say we're interested in building a budgeting application. This will initially be for personal use, but we might want to let other people use it in future, or even build a business out of it. We could choose to use any of these three types of services to build our application, but each one has different pros and cons. The chosen service will determine both the skills we'll need, and the limitations we'll need to work with. Roughly speaking, we will need greater depth and breadth of technical expertise as you move up the ladder from SaaS to IaaS, but we'll also have more flexibility. Below, we'll go through each one and discuss how we might use it to build our budgeting application. Software as a Service (SaaS) Pros Cons Quick to get started with. Limited flexibility. Requires little or no programming knowledge. Significant vendor lock-in. Likely to be inefficient and costly at scale. Just about any application that runs in your browser can be considered Software as a Service (SaaS). SaaS examples include Google Drive and its associated office suite \u2013 Google Docs, Google Sheets, and others \u2013 as well as other file management services like Dropbox, communication platforms like Slack, and knowledge management solutions like Notion and Confluence. If we were to build a budgeting application using SaaS, we could do it without writing a large amount of code. We could start with a simple Google Sheet, attached to a Google Form, where the user would manually enter each transaction they make during the month. The user would specify the amount, whether it's an income, expense or investment, and add a comment about what it was for: e.g. \"Monthly salary\" or \"Groceries\". We could then use macros to calculate the user's total income and expenditure for each month. We could make this more complex by using multiple forms and spreadsheets to do things like allowing the user to set up a budget at the beginning of each month. We could also integrate investments into our spreadsheets, using the GOOGLEFINANCE macro to fetch stock prices in real time. We could then expand out of spreadsheets and forms by using another SaaS platform like IFTTT or Zapier to send a monthly digest email to the user's G-mail address, or warning emails if they start coming close to their allotted budget for a particular kind of expense. And if the user is more active on Slack than on email, we could also set up Slack alerts. If we want something more than email and Slack alterts, we could use a SaaS platform such as Glide to build a custom application using our original spreadsheets as a data backend. With a bit of tweaking, we could make it possible for others to use it, too. Our full application architecture would now look like this: In this way, we can get a fully functional budgetting application with multiple integrations working by using different SaaS solutions together, and without writing any code. However, if we're interested in building a business out of this application, we may soon run into problems like expensive per-user fees and a lack of flexibility and control. Glide's visual editor may not allow us to design our application in the exact way we want to, or we may run up against the limitations of what sorts of data analysis can reasonably be done using spreadsheets. SaaS platforms also have the strongest vendor lock-in of the three types of services discussed in this article. If the SaaS we're using closes down or radically changes its software, we may be unable to extract all of your data. And even if we are able to extract our data, it's unlikely that we'll be able to import it directly into a different SaaS and keep going. For example, if our budget application uses a lot of functionality specific to Google Sheets, such as the GOOGLEFINANCE macro, and Google decides to shut down Sheets, we should be able to download our sheets as XLSX files and move them to a competing platform, such as Microsoft Office 365 . But we'll then have to do a lot of manual tinkering to get everything to work again on this new service. In some cases, we may even have to remove functionality that's not supported by the new service. And seeing as we're using multiple SaaS platforms together, as in the above architecture, we're dependent on them continuing to support each other. For example, if Slack changes its API in a way that breaks Zapier's integration with it, our budgeting application's Slack integration will be broken until Zapier updates their software. Worse still, if Slack chooses to stop supporting the kinds of integrations we want, we will have to scramble to find an alternative solution to notify users about their budgets. SaaS solutions provide a great way to quickly prototype ideas, but may prove unreliable and limiting if you need them to work over a long timescale or for a large number of users. Using Google Sheets and some integrations to build a budgeting app for yourself is not a bad idea, and you could even develop it to the point of accepting other users, but if you want to build a sustainable business with your application, you may be better off looking into a PaaS or IaaS solution instead. Platform as a Service (PaaS) Pros Cons Requires no infrastructure set-up. May be inefficient or costly at scale. The vendor is responsible for system maintenance and security patches. Less vendor lock-in than SaaS, more than IaaS. Unlike most SaaS solutions, Platform as a Service (PaaS) solutions are specifically intended for use by developers. You can think of a PaaS as anywhere you can upload code and have it automatically deployed and run. PaaS solutions include Code Capsules, Heroku, Netlify, Google App Engine and AWS Elastic Beanstalk. If you've deployed a Capsule before, you'll be familiar with the process of working with a PaaS. If you haven't, it generally goes like this: Write application code in a language and framework of your choice. Push code to a source code repository on a code hosting platform such as GitHub. Link your GitHub profile to the PaaS of your choice, locate the repository you want to deploy, and click \"Deploy\". Your application will be live on a URL that looks like myapp.paas.com. Depending on the PaaS and the type of application being deployed, the developer may need to include deployment configuration instructions with their application code. For example, in many of our tutorials , it is necessary to create files named Procfile and requirements.txt prior to deployment. Users of a PaaS will need to write a lot of code. In return, they get flexibility and a reduced level of vendor lock-in compared to building on SaaS solutions. Writing your own custom code gives you far more customisation options and areas where you can make specific optimisations. Users of PaaS solutions do not require system administration knowledge, as the PaaS will be responsible for configuring their code to run correctly. Different PaaS solutions target different parts of the standard three-layer application stack made up of frontend (HTML and JavaScript that runs in users' browsers), backend (code that runs on servers) and data persistence (databases and datastores that record information such as user login details). Some PaaS solutions are highly focused on a single part of the stack, while others offer solutions for multiple areas of the stack. The table below gives some examples of each. Areas of the stack PaaS solution examples Frontend Netlify, Vercel, AWS S3, GitHub Pages, Code Capsules (Frontend capsules) Backend Heroku, OpenShift, AWS Elastic Beanstalk, AWS Lambda, Code Capsules (Backend capsules) Data persistence MongoDB Atlas, AWS RDS, Azure SQL Database Frontend code can be included with backend code, and some PaaS solutions offer data persistence solutions, so you may be able to deploy a complete application as a single project on a single PaaS, but you can also use multiple PaaS solutions for different stack components. If we were to build our budgeting application on PaaS solutions, we would start by writing the application code. We might do this in Python with a framework like Flask, in Node.js with a framework like Express, in Ruby with a framework like Sinatra, or any number of other languages, depending on PaaS support. We may also use a frontend framework such as Vue or React. We would also need to choose a data store: either a relational database like PostgreSQL or a NoSQL document store like MongoDB . Then we would need to choose one or more PaaS solutions which supports our chosen technologies. Let's say we developed our budgeting application using Code Capsules to host our back- and frontend code and MongoDB Atlas to store our data. We could combine the backend and frontend code into a single backend capsule. Alternatively, we could create a frontend capsule with our application frontend and have it interact with an API created in a backend capsule \u2013 we might do this if we wanted to reuse our backend for a mobile application. Our budgeting app would be a web application with user login. Custom functionality would need to be developed for entering transactions, setting budgets and viewing spending reports, but we would have total flexibility in how all of this worked, without being constrained by the interfaces of Google Sheets or Google Forms. For example, we could create specialised forms for common transactions with user-friendly features like autocomplete based on existing data. If we're feeling really ambitious, we could integrate open banking into our application and have transactions fetched automatically rather than having to enter them manually. Using a single backend capsule, our application architecture would look something like this: Using a backend and frontend capsule, our application architecture would look like this: In the above architecture, we could replace the frontend module with a Netlify site, and the backend module with a collection of AWS Lambda functions, or just about any other PaaS solution that provides the appropriate area of the stack. Using PaaS solutions is the middleground between using SaaS and IaaS solutions in terms of ease of setup versus flexibility and control. Using a PaaS will lead to some level of vendor lock-in, especially if you use something like AWS Lambda. However, in most cases, we will be able to move our code to a different PaaS if the one we're using shuts down or stops supporting something we rely on. We may have to do some reconfiguration, but this is likely to be less onerous than moving between SaaS solutions. As we are not doing our own system administration when we use a PaaS solution, we won't be able to optimise our infrastructure for the needs of our application. If we're not careful about how we design our application, it may end up being much more expensive to run than it would be on an IaaS solution. Infrastructure as a Service (IaaS) Pros Cons Highly flexible. Requires programming and system administration knowledge. Can be configured more precisely and efficiently than SaaS and PaaS solutions. Requires regular maintenance. Very little vendor lock-in ... Infrastructure as a Service (IaaS) solutions are the most technically demanding of their users. Rather than providing end-user software or deployment for user-developed code, most IaaS solutions merely provide you with virtual machines (VMs), commonly called a \"compute instance\". These are fully capable computers that you have full control over and responsibility for. Examples of IaaS services include AWS Elastic Computing (EC) 2, Google Cloud Platform's Compute Engine, and Digital Ocean's Droplets. To deploy an app using an IaaS solution, we follow these general steps: Create a virtual machine, specifying how much CPU power, RAM and hard drive storage space you want, as well as its operating system. Specify firewall rules for this virtual machine \u2013 for most simple web applications, you'll need to specify that TCP ports 80 and 443 should be open, as well as port 22, for your remote access. Access your virtual machine over a secure shell (SSH), generally using an SSH key like you would with GitHub. Install a web server, database management system, and all the other requirements for your application. Upload your application's code to your server. Ensure that all of your supporting software is configured correctly and your application's code files can be located and read by your webserver, and then start your application. Buy a domain name and configure it to point to the IP address of your virtual server. This is quite a lot more effort than using a PaaS, and it requires some specialised knowledge in addition to programming. In our budgeting app example, we would be able to take the same code you might deploy to a PaaS and use that on an IaaS: for example, we could take code we've uploaded to Code Capsules and upload it to an AWS EC2 instance instead. We would just need to install and set up your own webserver (usually Apache or nginx), and our own database (either a traditional relational database like PostgreSQL or a NoSQL document store like MongoDB). We could also put the database on a second EC2 instance, and configure your networking rules to allow both instances to speak to each other over the relevant port. Our application architecture would look now look like the diagram below. Note that we would retain our open banking integration, as that is defined in code. The benefit this gives you is total control over your infrastructure, which can have efficiency and cost savings over working with a PaaS. How much will depend on your level of expertise and the amount of time you can allocate to optimising and managing your infrastructure. Depending on our application's architecture, we might create more than one VM for serving the application and managing the database, using load balancers and data replication. Alternatively, we may just dynamically increase the CPU speed, RAM and disk space of one or two VMs. The other major benefit to using IaaS over SaaS or PaaS is that it has essentially no vendor lock-in. Just about everything you do on an AWS EC2 instance will work just as well on a virtual machine provided by Google Compute Engine or Digital Ocean, or even a physical server in a pre-cloud datacentre. But with great power comes great responsibility. Anything we build on an IaaS solution will require regular maintenance \u2013 we will be responsible for keeping our virtual machines' software up-to-date. This is extremely important for internet-facing infrastructure, as out-of-date software can contain security vulnerabilities which could lead to our application being hacked, even if all of our own code is completely secure. Conclusion The choice between SaaS, PaaS and IaaS solutions will depend on your and your team's depth and breadth of expertise, how you aim to manage your time, and what stage of development you're in. The same application could go from a proof-of-concept build on SaaS solutions to a custom built application running on PaaS solutions, and then move over to the IaaS to improve performance or costs. Or you could use a mix of all three: the choice between SaaS, PaaS and IaaS does not have to all-or-nothing. Instead, it's worth making an independent decision for each area of your application stack. For example, you can have an application that runs on an AWS EC2 instance (IaaS), stores data in an AWS RDS database (PaaS) and sends users notifications on Slack (SaaS). Or you could create a Netlify website (PaaS) that communicates with a an API deployed on Code Capsules (PaaS), which in turn uses a PostgreSQL database running on an AWS EC2 instance (IaaS). The possibilities are endless.","title":"SaaS vs PaaS vs IaaS"},{"location":"comparisons/saas-paas-iaas/#saas-vs-paas-vs-iaas","text":"If you've spent any amount of time trying out or researching cloud services, you've probably come across acronyms like SaaS, PaaS and IaaS. Respectively, these are: Software as a Service Platform as a Service Infrastructure as a Service But what do any of these terms actually mean? And what's the difference between them? In this article, we will provide a practical, hands-on overview of the differences, strengths and weaknesses of these three types of cloud services. We will add examples of each, and the types of things you might build with them. Let's say we're interested in building a budgeting application. This will initially be for personal use, but we might want to let other people use it in future, or even build a business out of it. We could choose to use any of these three types of services to build our application, but each one has different pros and cons. The chosen service will determine both the skills we'll need, and the limitations we'll need to work with. Roughly speaking, we will need greater depth and breadth of technical expertise as you move up the ladder from SaaS to IaaS, but we'll also have more flexibility. Below, we'll go through each one and discuss how we might use it to build our budgeting application.","title":"SaaS vs PaaS vs IaaS"},{"location":"comparisons/saas-paas-iaas/#software-as-a-service-saas","text":"Pros Cons Quick to get started with. Limited flexibility. Requires little or no programming knowledge. Significant vendor lock-in. Likely to be inefficient and costly at scale. Just about any application that runs in your browser can be considered Software as a Service (SaaS). SaaS examples include Google Drive and its associated office suite \u2013 Google Docs, Google Sheets, and others \u2013 as well as other file management services like Dropbox, communication platforms like Slack, and knowledge management solutions like Notion and Confluence. If we were to build a budgeting application using SaaS, we could do it without writing a large amount of code. We could start with a simple Google Sheet, attached to a Google Form, where the user would manually enter each transaction they make during the month. The user would specify the amount, whether it's an income, expense or investment, and add a comment about what it was for: e.g. \"Monthly salary\" or \"Groceries\". We could then use macros to calculate the user's total income and expenditure for each month. We could make this more complex by using multiple forms and spreadsheets to do things like allowing the user to set up a budget at the beginning of each month. We could also integrate investments into our spreadsheets, using the GOOGLEFINANCE macro to fetch stock prices in real time. We could then expand out of spreadsheets and forms by using another SaaS platform like IFTTT or Zapier to send a monthly digest email to the user's G-mail address, or warning emails if they start coming close to their allotted budget for a particular kind of expense. And if the user is more active on Slack than on email, we could also set up Slack alerts. If we want something more than email and Slack alterts, we could use a SaaS platform such as Glide to build a custom application using our original spreadsheets as a data backend. With a bit of tweaking, we could make it possible for others to use it, too. Our full application architecture would now look like this: In this way, we can get a fully functional budgetting application with multiple integrations working by using different SaaS solutions together, and without writing any code. However, if we're interested in building a business out of this application, we may soon run into problems like expensive per-user fees and a lack of flexibility and control. Glide's visual editor may not allow us to design our application in the exact way we want to, or we may run up against the limitations of what sorts of data analysis can reasonably be done using spreadsheets. SaaS platforms also have the strongest vendor lock-in of the three types of services discussed in this article. If the SaaS we're using closes down or radically changes its software, we may be unable to extract all of your data. And even if we are able to extract our data, it's unlikely that we'll be able to import it directly into a different SaaS and keep going. For example, if our budget application uses a lot of functionality specific to Google Sheets, such as the GOOGLEFINANCE macro, and Google decides to shut down Sheets, we should be able to download our sheets as XLSX files and move them to a competing platform, such as Microsoft Office 365 . But we'll then have to do a lot of manual tinkering to get everything to work again on this new service. In some cases, we may even have to remove functionality that's not supported by the new service. And seeing as we're using multiple SaaS platforms together, as in the above architecture, we're dependent on them continuing to support each other. For example, if Slack changes its API in a way that breaks Zapier's integration with it, our budgeting application's Slack integration will be broken until Zapier updates their software. Worse still, if Slack chooses to stop supporting the kinds of integrations we want, we will have to scramble to find an alternative solution to notify users about their budgets. SaaS solutions provide a great way to quickly prototype ideas, but may prove unreliable and limiting if you need them to work over a long timescale or for a large number of users. Using Google Sheets and some integrations to build a budgeting app for yourself is not a bad idea, and you could even develop it to the point of accepting other users, but if you want to build a sustainable business with your application, you may be better off looking into a PaaS or IaaS solution instead.","title":"Software as a Service (SaaS)"},{"location":"comparisons/saas-paas-iaas/#platform-as-a-service-paas","text":"Pros Cons Requires no infrastructure set-up. May be inefficient or costly at scale. The vendor is responsible for system maintenance and security patches. Less vendor lock-in than SaaS, more than IaaS. Unlike most SaaS solutions, Platform as a Service (PaaS) solutions are specifically intended for use by developers. You can think of a PaaS as anywhere you can upload code and have it automatically deployed and run. PaaS solutions include Code Capsules, Heroku, Netlify, Google App Engine and AWS Elastic Beanstalk. If you've deployed a Capsule before, you'll be familiar with the process of working with a PaaS. If you haven't, it generally goes like this: Write application code in a language and framework of your choice. Push code to a source code repository on a code hosting platform such as GitHub. Link your GitHub profile to the PaaS of your choice, locate the repository you want to deploy, and click \"Deploy\". Your application will be live on a URL that looks like myapp.paas.com. Depending on the PaaS and the type of application being deployed, the developer may need to include deployment configuration instructions with their application code. For example, in many of our tutorials , it is necessary to create files named Procfile and requirements.txt prior to deployment. Users of a PaaS will need to write a lot of code. In return, they get flexibility and a reduced level of vendor lock-in compared to building on SaaS solutions. Writing your own custom code gives you far more customisation options and areas where you can make specific optimisations. Users of PaaS solutions do not require system administration knowledge, as the PaaS will be responsible for configuring their code to run correctly. Different PaaS solutions target different parts of the standard three-layer application stack made up of frontend (HTML and JavaScript that runs in users' browsers), backend (code that runs on servers) and data persistence (databases and datastores that record information such as user login details). Some PaaS solutions are highly focused on a single part of the stack, while others offer solutions for multiple areas of the stack. The table below gives some examples of each. Areas of the stack PaaS solution examples Frontend Netlify, Vercel, AWS S3, GitHub Pages, Code Capsules (Frontend capsules) Backend Heroku, OpenShift, AWS Elastic Beanstalk, AWS Lambda, Code Capsules (Backend capsules) Data persistence MongoDB Atlas, AWS RDS, Azure SQL Database Frontend code can be included with backend code, and some PaaS solutions offer data persistence solutions, so you may be able to deploy a complete application as a single project on a single PaaS, but you can also use multiple PaaS solutions for different stack components. If we were to build our budgeting application on PaaS solutions, we would start by writing the application code. We might do this in Python with a framework like Flask, in Node.js with a framework like Express, in Ruby with a framework like Sinatra, or any number of other languages, depending on PaaS support. We may also use a frontend framework such as Vue or React. We would also need to choose a data store: either a relational database like PostgreSQL or a NoSQL document store like MongoDB . Then we would need to choose one or more PaaS solutions which supports our chosen technologies. Let's say we developed our budgeting application using Code Capsules to host our back- and frontend code and MongoDB Atlas to store our data. We could combine the backend and frontend code into a single backend capsule. Alternatively, we could create a frontend capsule with our application frontend and have it interact with an API created in a backend capsule \u2013 we might do this if we wanted to reuse our backend for a mobile application. Our budgeting app would be a web application with user login. Custom functionality would need to be developed for entering transactions, setting budgets and viewing spending reports, but we would have total flexibility in how all of this worked, without being constrained by the interfaces of Google Sheets or Google Forms. For example, we could create specialised forms for common transactions with user-friendly features like autocomplete based on existing data. If we're feeling really ambitious, we could integrate open banking into our application and have transactions fetched automatically rather than having to enter them manually. Using a single backend capsule, our application architecture would look something like this: Using a backend and frontend capsule, our application architecture would look like this: In the above architecture, we could replace the frontend module with a Netlify site, and the backend module with a collection of AWS Lambda functions, or just about any other PaaS solution that provides the appropriate area of the stack. Using PaaS solutions is the middleground between using SaaS and IaaS solutions in terms of ease of setup versus flexibility and control. Using a PaaS will lead to some level of vendor lock-in, especially if you use something like AWS Lambda. However, in most cases, we will be able to move our code to a different PaaS if the one we're using shuts down or stops supporting something we rely on. We may have to do some reconfiguration, but this is likely to be less onerous than moving between SaaS solutions. As we are not doing our own system administration when we use a PaaS solution, we won't be able to optimise our infrastructure for the needs of our application. If we're not careful about how we design our application, it may end up being much more expensive to run than it would be on an IaaS solution.","title":"Platform as a Service (PaaS)"},{"location":"comparisons/saas-paas-iaas/#infrastructure-as-a-service-iaas","text":"Pros Cons Highly flexible. Requires programming and system administration knowledge. Can be configured more precisely and efficiently than SaaS and PaaS solutions. Requires regular maintenance. Very little vendor lock-in ... Infrastructure as a Service (IaaS) solutions are the most technically demanding of their users. Rather than providing end-user software or deployment for user-developed code, most IaaS solutions merely provide you with virtual machines (VMs), commonly called a \"compute instance\". These are fully capable computers that you have full control over and responsibility for. Examples of IaaS services include AWS Elastic Computing (EC) 2, Google Cloud Platform's Compute Engine, and Digital Ocean's Droplets. To deploy an app using an IaaS solution, we follow these general steps: Create a virtual machine, specifying how much CPU power, RAM and hard drive storage space you want, as well as its operating system. Specify firewall rules for this virtual machine \u2013 for most simple web applications, you'll need to specify that TCP ports 80 and 443 should be open, as well as port 22, for your remote access. Access your virtual machine over a secure shell (SSH), generally using an SSH key like you would with GitHub. Install a web server, database management system, and all the other requirements for your application. Upload your application's code to your server. Ensure that all of your supporting software is configured correctly and your application's code files can be located and read by your webserver, and then start your application. Buy a domain name and configure it to point to the IP address of your virtual server. This is quite a lot more effort than using a PaaS, and it requires some specialised knowledge in addition to programming. In our budgeting app example, we would be able to take the same code you might deploy to a PaaS and use that on an IaaS: for example, we could take code we've uploaded to Code Capsules and upload it to an AWS EC2 instance instead. We would just need to install and set up your own webserver (usually Apache or nginx), and our own database (either a traditional relational database like PostgreSQL or a NoSQL document store like MongoDB). We could also put the database on a second EC2 instance, and configure your networking rules to allow both instances to speak to each other over the relevant port. Our application architecture would look now look like the diagram below. Note that we would retain our open banking integration, as that is defined in code. The benefit this gives you is total control over your infrastructure, which can have efficiency and cost savings over working with a PaaS. How much will depend on your level of expertise and the amount of time you can allocate to optimising and managing your infrastructure. Depending on our application's architecture, we might create more than one VM for serving the application and managing the database, using load balancers and data replication. Alternatively, we may just dynamically increase the CPU speed, RAM and disk space of one or two VMs. The other major benefit to using IaaS over SaaS or PaaS is that it has essentially no vendor lock-in. Just about everything you do on an AWS EC2 instance will work just as well on a virtual machine provided by Google Compute Engine or Digital Ocean, or even a physical server in a pre-cloud datacentre. But with great power comes great responsibility. Anything we build on an IaaS solution will require regular maintenance \u2013 we will be responsible for keeping our virtual machines' software up-to-date. This is extremely important for internet-facing infrastructure, as out-of-date software can contain security vulnerabilities which could lead to our application being hacked, even if all of our own code is completely secure.","title":"Infrastructure as a Service (IaaS)"},{"location":"comparisons/saas-paas-iaas/#conclusion","text":"The choice between SaaS, PaaS and IaaS solutions will depend on your and your team's depth and breadth of expertise, how you aim to manage your time, and what stage of development you're in. The same application could go from a proof-of-concept build on SaaS solutions to a custom built application running on PaaS solutions, and then move over to the IaaS to improve performance or costs. Or you could use a mix of all three: the choice between SaaS, PaaS and IaaS does not have to all-or-nothing. Instead, it's worth making an independent decision for each area of your application stack. For example, you can have an application that runs on an AWS EC2 instance (IaaS), stores data in an AWS RDS database (PaaS) and sends users notifications on Slack (SaaS). Or you could create a Netlify website (PaaS) that communicates with a an API deployed on Code Capsules (PaaS), which in turn uses a PostgreSQL database running on an AWS EC2 instance (IaaS). The possibilities are endless.","title":"Conclusion"},{"location":"deployment/","text":"Deployment guides If you're looking to deploy a specific framework, you can find guides for Frontend frameworks: Angular React Vue Static HTML Backend frameworks: Flask Express Java","title":"Overview"},{"location":"deployment/#deployment-guides","text":"If you're looking to deploy a specific framework, you can find guides for Frontend frameworks: Angular React Vue Static HTML Backend frameworks: Flask Express Java","title":"Deployment guides"},{"location":"deployment/how-to-deploy-angular-application-to-production/","text":"How to Deploy an Angular Application to Production on Code Capsules Deploy an Angular application and learn how to host frontend code on Code Capsules. Set Up Code Capsules connects to GitHub repositories to deploy applications. For this tutorial, you'll need: - A Code Capsules account. - A GitHub account. To demonstrate how to deploy an Angular application with Code Capsules, we'll use our example application . Follow the link above and fork the application by clicking \"fork\" at the top-right of the repository. With the Angular application forked to your GitHub account, we are ready to deploy it on Code Capsules. Sign Up for Code Capsules If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just signed up for an account, you'll be directed to the Welcome page on your first login. Click on the \"Go To Personal Team\" button. After clicking on the \"Go To Personal Team\" button, you will be redirected to the Spaces tab for your Personal Team. A Team is an environment for you to manage your Spaces and Capsules. Teams can have multiple members interacting with the projects associated with that particular Team. Code Capsules gives every account a Personal Team as the default. Create a Space for Your Apps Spaces are an organisational tool for your applications. Click the \"Create A New Space For Your Apps\" button and follow the prompts, naming the Space anything you'd like. Now that we've created a Space, we need to connect the GitHub repository we forked to our Code Capsules. Link to GitHub To host our application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. We can link the GitHub repository by clicking the profile image at the top right of the screen, and finding the \"GitHub\" button under \"GitHub Details\". Click the \"GitHub\" button. To give Code Capsules access to the Angular application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the contents of the selected repositories. All that's left to deploy the application is to add the repo to your Team and create a Capsule . Capsules act as storage space for the different types of applications you'd host on Code Capsules. Add Repo to Team Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo. Create and Build the Capsule It's time to create a Capsule . To do this, navigate to the Spaces tab and open the Space you created for this tutorial. Once inside the Space, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button and follow the instructions below. Choose a \"Frontend\" Capsule. Select the \"Trial - Static Site Hosting\" product. Choose the GitHub repository we forked. Press next. Use npm run build for the \"Build command\" and dist for \"Static content folder path\". Press \"Create Capsule\". You can view the build logs under the Build and Deploy tab in your Capsule. When the Capsule builds, navigate to the Overview tab and click on the provided URL to view the application. For a better understanding of Capsules, read this explanation on Capsules . If you want to deploy another Angular application in the future, it'll be useful to check out the script Code Capsules used to build the Angular application. Navigate to the Angular repository we forked and take a look at the package.json file. On line four, you'll see the script Code Capsules used to deploy the application.","title":"Angular"},{"location":"deployment/how-to-deploy-angular-application-to-production/#how-to-deploy-an-angular-application-to-production-on-code-capsules","text":"Deploy an Angular application and learn how to host frontend code on Code Capsules.","title":"How to Deploy an Angular Application to Production on Code Capsules"},{"location":"deployment/how-to-deploy-angular-application-to-production/#set-up","text":"Code Capsules connects to GitHub repositories to deploy applications. For this tutorial, you'll need: - A Code Capsules account. - A GitHub account. To demonstrate how to deploy an Angular application with Code Capsules, we'll use our example application . Follow the link above and fork the application by clicking \"fork\" at the top-right of the repository. With the Angular application forked to your GitHub account, we are ready to deploy it on Code Capsules.","title":"Set Up"},{"location":"deployment/how-to-deploy-angular-application-to-production/#sign-up-for-code-capsules","text":"If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just signed up for an account, you'll be directed to the Welcome page on your first login. Click on the \"Go To Personal Team\" button. After clicking on the \"Go To Personal Team\" button, you will be redirected to the Spaces tab for your Personal Team. A Team is an environment for you to manage your Spaces and Capsules. Teams can have multiple members interacting with the projects associated with that particular Team. Code Capsules gives every account a Personal Team as the default.","title":"Sign Up for Code Capsules"},{"location":"deployment/how-to-deploy-angular-application-to-production/#create-a-space-for-your-apps","text":"Spaces are an organisational tool for your applications. Click the \"Create A New Space For Your Apps\" button and follow the prompts, naming the Space anything you'd like. Now that we've created a Space, we need to connect the GitHub repository we forked to our Code Capsules.","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-angular-application-to-production/#link-to-github","text":"To host our application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. We can link the GitHub repository by clicking the profile image at the top right of the screen, and finding the \"GitHub\" button under \"GitHub Details\". Click the \"GitHub\" button. To give Code Capsules access to the Angular application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the contents of the selected repositories. All that's left to deploy the application is to add the repo to your Team and create a Capsule . Capsules act as storage space for the different types of applications you'd host on Code Capsules.","title":"Link to GitHub"},{"location":"deployment/how-to-deploy-angular-application-to-production/#add-repo-to-team","text":"Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-angular-application-to-production/#create-and-build-the-capsule","text":"It's time to create a Capsule . To do this, navigate to the Spaces tab and open the Space you created for this tutorial. Once inside the Space, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button and follow the instructions below. Choose a \"Frontend\" Capsule. Select the \"Trial - Static Site Hosting\" product. Choose the GitHub repository we forked. Press next. Use npm run build for the \"Build command\" and dist for \"Static content folder path\". Press \"Create Capsule\". You can view the build logs under the Build and Deploy tab in your Capsule. When the Capsule builds, navigate to the Overview tab and click on the provided URL to view the application. For a better understanding of Capsules, read this explanation on Capsules . If you want to deploy another Angular application in the future, it'll be useful to check out the script Code Capsules used to build the Angular application. Navigate to the Angular repository we forked and take a look at the package.json file. On line four, you'll see the script Code Capsules used to deploy the application.","title":"Create and Build the Capsule"},{"location":"deployment/how-to-deploy-express-application-to-production/","text":"How to Deploy an Express.js Application to Production on Code Capsules In this tutorial, we'll see how to deploy an Express.js application as well as learn how to host backend code on Code Capsules. Code Capsules connects to GitHub repositories to deploy code online, so you'll need a GitHub account to follow along. Get Some Example Code Let's get some example code first by forking the repository containing our example Express.js application . We'll use this ready-to-be-deployed application to jump straight to the intricacies of how to deploy with Code Capsules. To use the repository mentioned above, fork the application by navigating to the repository and clicking \"Fork\" at the top-right of the screen. Once you've forked the application, we are ready to deploy it. Code Capsules Sign Up Navigate to Code Capsules and click on the \"Sign Up\" button in the top right corner of the webpage. Enter your details to sign up for an account. Alternatively, if you have an account already, go ahead and log in. If you've just signed up for an account, you'll be directed to the Welcome page on your first login. Click on the \"Go To Personal Team\" button to advance to the next step. A Team is an environment for you to manage your spaces and capsules. After clicking on the \"Go To Personal Team\" button, you will be redirected to the Spaces tab for your Personal Team. Code Capsules gives every account a Personal Team as a default. Code Capsules requires us to add payment information in order to use a backend Capsule, which we'll need in this tutorial. Do this by navigating to \"Team Settings\" at the top of the screen, then add a payment method under \"Payment Methods\". Once you've added payment information, we need to create a Space which will contain our application. Create a Space for Your Apps Now click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new space for this tutorial or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region, enter a name for your space, and press \"Create Space\". Linking to GitHub The next step is to link the GitHub repository we forked earlier to our Code Capsules account. To do this, click the profile image at the top right of the screen, and find the \"GitHub\" button under GitHub Details . Click the \"GitHub\" button to give Code Capsules access to the Express application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the contents of the selected repositories. All that's left to deploy the application is to add the repo to your Team and create a Capsule . Add Repo to Team Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo. Create the Capsule Capsules provide the server for hosting applications on Code Capsules. For a closer look at a Capsule's properties, read this explanation on Capsules . Go back to the Spaces tab. Next, click on the Space you just created or are using, and create a new Capsule in that Space. To do this, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the Space. Choose a \"Backend Capsule\". Select the \"Sandbox\" product. Choose the GitHub repository we forked. Press \"Next\". Leave the \"Run Command\" blank and create the Capsule. You can view the build logs under the \"Build and Deploy\" tab in your Capsule whilst it is building. When the Capsule is built, navigate to the Overview tab and click on the URL provided to view the application. This application also exposes a GET endpoint at /api/data . If curl is installed on your computer (MacOSX and Linux distributions generally have curl installed), we can request the data exposed at that endpoint using the URL that Code Capsules provided. Try this in your terminal: curl https://<Your-CodeCapsules-URL/api/data The response should look like: { \"data\":[{\"id\":1,\"title\":\"Some data\"},{\"id\":2,\"title\":\"Some other data\"}]} If you'd like to deploy another Express.js application in the future, take a close look at the package.json file in the repository we forked . On line six you can see the \"start\" script that Code Capsules used to build and deploy the Express.js application.","title":"Express"},{"location":"deployment/how-to-deploy-express-application-to-production/#how-to-deploy-an-expressjs-application-to-production-on-code-capsules","text":"In this tutorial, we'll see how to deploy an Express.js application as well as learn how to host backend code on Code Capsules. Code Capsules connects to GitHub repositories to deploy code online, so you'll need a GitHub account to follow along.","title":"How to Deploy an Express.js Application to Production on Code Capsules"},{"location":"deployment/how-to-deploy-express-application-to-production/#get-some-example-code","text":"Let's get some example code first by forking the repository containing our example Express.js application . We'll use this ready-to-be-deployed application to jump straight to the intricacies of how to deploy with Code Capsules. To use the repository mentioned above, fork the application by navigating to the repository and clicking \"Fork\" at the top-right of the screen. Once you've forked the application, we are ready to deploy it.","title":"Get Some Example Code"},{"location":"deployment/how-to-deploy-express-application-to-production/#code-capsules-sign-up","text":"Navigate to Code Capsules and click on the \"Sign Up\" button in the top right corner of the webpage. Enter your details to sign up for an account. Alternatively, if you have an account already, go ahead and log in. If you've just signed up for an account, you'll be directed to the Welcome page on your first login. Click on the \"Go To Personal Team\" button to advance to the next step. A Team is an environment for you to manage your spaces and capsules. After clicking on the \"Go To Personal Team\" button, you will be redirected to the Spaces tab for your Personal Team. Code Capsules gives every account a Personal Team as a default. Code Capsules requires us to add payment information in order to use a backend Capsule, which we'll need in this tutorial. Do this by navigating to \"Team Settings\" at the top of the screen, then add a payment method under \"Payment Methods\". Once you've added payment information, we need to create a Space which will contain our application.","title":"Code Capsules Sign Up"},{"location":"deployment/how-to-deploy-express-application-to-production/#create-a-space-for-your-apps","text":"Now click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new space for this tutorial or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region, enter a name for your space, and press \"Create Space\".","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-express-application-to-production/#linking-to-github","text":"The next step is to link the GitHub repository we forked earlier to our Code Capsules account. To do this, click the profile image at the top right of the screen, and find the \"GitHub\" button under GitHub Details . Click the \"GitHub\" button to give Code Capsules access to the Express application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the contents of the selected repositories. All that's left to deploy the application is to add the repo to your Team and create a Capsule .","title":"Linking to GitHub"},{"location":"deployment/how-to-deploy-express-application-to-production/#add-repo-to-team","text":"Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-express-application-to-production/#create-the-capsule","text":"Capsules provide the server for hosting applications on Code Capsules. For a closer look at a Capsule's properties, read this explanation on Capsules . Go back to the Spaces tab. Next, click on the Space you just created or are using, and create a new Capsule in that Space. To do this, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the Space. Choose a \"Backend Capsule\". Select the \"Sandbox\" product. Choose the GitHub repository we forked. Press \"Next\". Leave the \"Run Command\" blank and create the Capsule. You can view the build logs under the \"Build and Deploy\" tab in your Capsule whilst it is building. When the Capsule is built, navigate to the Overview tab and click on the URL provided to view the application. This application also exposes a GET endpoint at /api/data . If curl is installed on your computer (MacOSX and Linux distributions generally have curl installed), we can request the data exposed at that endpoint using the URL that Code Capsules provided. Try this in your terminal: curl https://<Your-CodeCapsules-URL/api/data The response should look like: { \"data\":[{\"id\":1,\"title\":\"Some data\"},{\"id\":2,\"title\":\"Some other data\"}]} If you'd like to deploy another Express.js application in the future, take a close look at the package.json file in the repository we forked . On line six you can see the \"start\" script that Code Capsules used to build and deploy the Express.js application.","title":"Create the Capsule"},{"location":"deployment/how-to-deploy-flask-application-to-production/","text":"How to Deploy a Flask Application to Production on Code Capsules Deploy a Flask application and learn how to host backend code on Code Capsules. Set Up Here, we'll learn how to deploy backend code with Code Capsules and Flask. Because Code Capsules connects with GitHub to deploy code, you'll need a GitHub account to follow this tutorial. We'll use a sample Flask application provided by Code Capsules to demonstrate deployment \u2013 you can find the GitHub repository for the application here . To deploy this repository, we'll need to fork the application by clicking \"Fork\" at the top right of the GitHub repository. Once forked, we're ready to deploy the application \u2013 feel free to make any edits to it, otherwise continue. Creating an Account with Code Capsules First, we'll need to create an account with Code Capsules . Do so, and make sure to confirm your account by checking your email. After creating a new account, you'll be greeted with a screen that looks like this: Click on the \"Go To Personal Team\" button, and you will be redirected to the Spaces tab for your Personal Team. Code Capsules provides a personal Team and a personal Space (located in the middle of the screen) to every new user. For this tutorial, we'll need to add payment information to create a backend Capsule. Navigate to \"Team Settings\" at the top of the screen, then add a payment method under \"Payment Methods\". Once you've added payment information, we need to permit Code Capsules to access our GitHub repositories. Linking to GitHub In order to host our Flask application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. Find the profile image at the top right of the page and click on it. You'll see a GitHub button located under \"GitHub\" details. Click on the \"GitHub\" button. You can authorise Code Capsules to connect to the Flask application by: Clicking your GitHub username. Selecting \"Only Select Repositories\". Choosing the GitHub repository we forked. Pressing \"Install & Authorize\". Once you've clicked the \"Install & Authorize\" button, Code Capsules will link to the GitHub repository containing the Flask application. The next step is to add the repository to our \"Personal Team\" so that all Capsules created under that Team can read its data. Add Repo to Team Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your team will have access to this repo. Now, all we have left to do is to create a Capsule that will host our Flask application. But first, let's create a space for the capsule. Create a Space for Your Apps Navigate to the Spaces tab and click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new space for this tutorial or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region and enter a name for your space and press \"Create Space\". Create the Capsule Capsules provide the server for hosting applications on Code Capsules. We can deploy our Flask application to Code Capsules by clicking the \"Create a New Capsule for Your Space\" button. Do so, then: Choose a \"Backend Capsule\". Select the \"Sandbox\" product. Choose the GitHub repository we forked. Press next. Leave the \"Run Command\" blank and create the Capsule. While the Capsule is building, you can view its logs under the \"Build and Deploy\" tab in the Capsule. Once built, you can navigate to the \"Overview\" tab and click on the provided URL to view the application. For a better understanding of Capsules, take a look at this explanation . If you'd like to deploy your own Flask application, take a close look at the Flask repository we forked. There, you'll find a file named Procfile . Code Capsules reads Procfiles to build and deploy Flask applications. Click here to read more about Procfiles.","title":"Flask"},{"location":"deployment/how-to-deploy-flask-application-to-production/#how-to-deploy-a-flask-application-to-production-on-code-capsules","text":"Deploy a Flask application and learn how to host backend code on Code Capsules.","title":"How to Deploy a Flask Application to Production on Code Capsules"},{"location":"deployment/how-to-deploy-flask-application-to-production/#set-up","text":"Here, we'll learn how to deploy backend code with Code Capsules and Flask. Because Code Capsules connects with GitHub to deploy code, you'll need a GitHub account to follow this tutorial. We'll use a sample Flask application provided by Code Capsules to demonstrate deployment \u2013 you can find the GitHub repository for the application here . To deploy this repository, we'll need to fork the application by clicking \"Fork\" at the top right of the GitHub repository. Once forked, we're ready to deploy the application \u2013 feel free to make any edits to it, otherwise continue.","title":"Set Up"},{"location":"deployment/how-to-deploy-flask-application-to-production/#creating-an-account-with-code-capsules","text":"First, we'll need to create an account with Code Capsules . Do so, and make sure to confirm your account by checking your email. After creating a new account, you'll be greeted with a screen that looks like this: Click on the \"Go To Personal Team\" button, and you will be redirected to the Spaces tab for your Personal Team. Code Capsules provides a personal Team and a personal Space (located in the middle of the screen) to every new user. For this tutorial, we'll need to add payment information to create a backend Capsule. Navigate to \"Team Settings\" at the top of the screen, then add a payment method under \"Payment Methods\". Once you've added payment information, we need to permit Code Capsules to access our GitHub repositories.","title":"Creating an Account with Code Capsules"},{"location":"deployment/how-to-deploy-flask-application-to-production/#linking-to-github","text":"In order to host our Flask application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. Find the profile image at the top right of the page and click on it. You'll see a GitHub button located under \"GitHub\" details. Click on the \"GitHub\" button. You can authorise Code Capsules to connect to the Flask application by: Clicking your GitHub username. Selecting \"Only Select Repositories\". Choosing the GitHub repository we forked. Pressing \"Install & Authorize\". Once you've clicked the \"Install & Authorize\" button, Code Capsules will link to the GitHub repository containing the Flask application. The next step is to add the repository to our \"Personal Team\" so that all Capsules created under that Team can read its data.","title":"Linking to GitHub"},{"location":"deployment/how-to-deploy-flask-application-to-production/#add-repo-to-team","text":"Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your team will have access to this repo. Now, all we have left to do is to create a Capsule that will host our Flask application. But first, let's create a space for the capsule.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-flask-application-to-production/#create-a-space-for-your-apps","text":"Navigate to the Spaces tab and click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new space for this tutorial or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region and enter a name for your space and press \"Create Space\".","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-flask-application-to-production/#create-the-capsule","text":"Capsules provide the server for hosting applications on Code Capsules. We can deploy our Flask application to Code Capsules by clicking the \"Create a New Capsule for Your Space\" button. Do so, then: Choose a \"Backend Capsule\". Select the \"Sandbox\" product. Choose the GitHub repository we forked. Press next. Leave the \"Run Command\" blank and create the Capsule. While the Capsule is building, you can view its logs under the \"Build and Deploy\" tab in the Capsule. Once built, you can navigate to the \"Overview\" tab and click on the provided URL to view the application. For a better understanding of Capsules, take a look at this explanation . If you'd like to deploy your own Flask application, take a close look at the Flask repository we forked. There, you'll find a file named Procfile . Code Capsules reads Procfiles to build and deploy Flask applications. Click here to read more about Procfiles.","title":"Create the Capsule"},{"location":"deployment/how-to-deploy-java-application-to-production/","text":"How to Deploy a Java Application to Production on Code Capsules Learn how to deploy backend Code on Code Capsules by deploying a Java application. Set Up Code Capsules connects to GitHub repositories to deploy code online, so you'll need a GitHub account to follow along. We're going to learn how to deploy backend code on Code Capsules using an example Java application provided by Code Capsules. The source code for the application can be found here on our GitHub account. We can use this repository by forking it. Navigate to the repository and \"Fork\" it by clicking the fork button at the top right of the repository. After forking the application, we can deploy it on Code Capsules. Sign Up for Code Capsules Account If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just signed up for an account, make sure to confirm it by checking for an email from Code Capsules. On your first login, you' will be directed to the Welcome page. Click on the \"Go To Personal Team\" button to advance to the next step. A Team is an environment for you to manage your Spaces and Capsules. Code Capsules gives every account a Personal Team as a default. Create a Space for Your Apps Now click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new Space for this tutorial or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region, enter a name for your Space and press \"Create Space\". Add Payment Information Because we're deploying backend code, we need to add our payment information. Add payment information by navigating to \"Team Settings\" on the top navigation bar. Add a payment method by clicking \"Payment Methods\" and then \"Add Payment Method\". After adding payment information, we need to give Code Capsules access to the Java application that we forked. Then we can get to deploying the application. Link to GitHub To give Code Capsules access to the Java application, we need to link our forked Java repository to our Code Capsules account. To link the repository, click the profile image at the top right of the screen. Next, find the \"GitHub\" button under GitHub Details . Click the \"GitHub\" button. To give Code Capsules access to the Java application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will have access to the Java application. The next step is to add the repository to our \"Personal Team\" so that all Capsules created under that Team can read its data. Add Repo to Team Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo. Now all that's left to do before deploying the application is to create a Capsule . This Capsule will act as storage space for the Java application. Create the Capsule Go back to the Spaces tab. Next, click on the Space you just created or are using, and create a new Capsule in that Space. To do this, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the Space. To deploy the Java application, click the button \"Create a New Capsule for Your Space\". Next: Choose a \"Backend Capsule\". Select the \"Sandbox\" product. Choose the GitHub repository we forked. Press next. Leave the \"Run Command\" blank and create the Capsule. After creating the Capsule, the Capsule will build the Java application. You can view the build logs by clicking the \"Build and Deploy\" tab in the Capsule. Once built, navigate to the \"Overview\" tab. Code Capsules provides a default URL for viewing applications - find this under \"domains\". Click the URL to view the application. If you'd like to deploy another Java application in the future, take a look at the Java repository to see how the project was set up. Maven was used to build the application and the spring Spring framework.","title":"Java"},{"location":"deployment/how-to-deploy-java-application-to-production/#how-to-deploy-a-java-application-to-production-on-code-capsules","text":"Learn how to deploy backend Code on Code Capsules by deploying a Java application.","title":"How to Deploy a Java Application to Production on Code Capsules"},{"location":"deployment/how-to-deploy-java-application-to-production/#set-up","text":"Code Capsules connects to GitHub repositories to deploy code online, so you'll need a GitHub account to follow along. We're going to learn how to deploy backend code on Code Capsules using an example Java application provided by Code Capsules. The source code for the application can be found here on our GitHub account. We can use this repository by forking it. Navigate to the repository and \"Fork\" it by clicking the fork button at the top right of the repository. After forking the application, we can deploy it on Code Capsules.","title":"Set Up"},{"location":"deployment/how-to-deploy-java-application-to-production/#sign-up-for-code-capsules-account","text":"If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just signed up for an account, make sure to confirm it by checking for an email from Code Capsules. On your first login, you' will be directed to the Welcome page. Click on the \"Go To Personal Team\" button to advance to the next step. A Team is an environment for you to manage your Spaces and Capsules. Code Capsules gives every account a Personal Team as a default.","title":"Sign Up for Code Capsules Account"},{"location":"deployment/how-to-deploy-java-application-to-production/#create-a-space-for-your-apps","text":"Now click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new Space for this tutorial or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region, enter a name for your Space and press \"Create Space\".","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-java-application-to-production/#add-payment-information","text":"Because we're deploying backend code, we need to add our payment information. Add payment information by navigating to \"Team Settings\" on the top navigation bar. Add a payment method by clicking \"Payment Methods\" and then \"Add Payment Method\". After adding payment information, we need to give Code Capsules access to the Java application that we forked. Then we can get to deploying the application.","title":"Add Payment Information"},{"location":"deployment/how-to-deploy-java-application-to-production/#link-to-github","text":"To give Code Capsules access to the Java application, we need to link our forked Java repository to our Code Capsules account. To link the repository, click the profile image at the top right of the screen. Next, find the \"GitHub\" button under GitHub Details . Click the \"GitHub\" button. To give Code Capsules access to the Java application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will have access to the Java application. The next step is to add the repository to our \"Personal Team\" so that all Capsules created under that Team can read its data.","title":"Link to GitHub"},{"location":"deployment/how-to-deploy-java-application-to-production/#add-repo-to-team","text":"Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo. Now all that's left to do before deploying the application is to create a Capsule . This Capsule will act as storage space for the Java application.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-java-application-to-production/#create-the-capsule","text":"Go back to the Spaces tab. Next, click on the Space you just created or are using, and create a new Capsule in that Space. To do this, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the Space. To deploy the Java application, click the button \"Create a New Capsule for Your Space\". Next: Choose a \"Backend Capsule\". Select the \"Sandbox\" product. Choose the GitHub repository we forked. Press next. Leave the \"Run Command\" blank and create the Capsule. After creating the Capsule, the Capsule will build the Java application. You can view the build logs by clicking the \"Build and Deploy\" tab in the Capsule. Once built, navigate to the \"Overview\" tab. Code Capsules provides a default URL for viewing applications - find this under \"domains\". Click the URL to view the application. If you'd like to deploy another Java application in the future, take a look at the Java repository to see how the project was set up. Maven was used to build the application and the spring Spring framework.","title":"Create the Capsule"},{"location":"deployment/how-to-deploy-react-application-to-production/","text":"How to Deploy a React Application to Production on Code Capsules React is an efficient and flexible JavaScript library which is great for building user interfaces. If you've built a web app with React, you'll want to deploy it to production so you can share it with the rest of the world. In this tutorial, we'll show you how to do just that, step by step. To follow along, you'll need: A GitHub account. A Code Capsules account. Get Some Example Code We'll use our example React application for the demonstration. You can use your own React application instead, or work from ours as a starting point. Fork the project to your own account by clicking on the above link and pressing \"fork\" in the top right. Sign Up for Code Capsules If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just signed up for an account, you'll be directed to the Welcome page on your first login. Click on the \"Go To Personal Team\" button. You will be redirected to the Spaces tab for your Personal Team. Code Capsules gives every account a Personal Team as a default. Create a Space for Your Apps Next, click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, click on the \"New Space\" button to create a new space for this tutorial, or select any of your existing ones. Whichever way you go about it, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region and enter a name for your space, then click \"Create Space\". Link to GitHub To host our React application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. We can link the GitHub repository by clicking the profile image at the top right of the screen, and finding the GitHub button under \"GitHub Details\". Click the \"GitHub\" button. To give Code Capsules access to the React application, you need to: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the contents of the selected repositories. All that's left to deploy the application is to add the repo to your team and create a Capsule . This Capsule will act as a storage space for the React application. Add Repo to Team Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the Edit Team Repos screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. Once this is done, all Spaces in your team will have access to this repo. Create the Capsule Return to the Spaces tab. Next, click on the Space you just created or are using, and create a new capsule in that space. To do this, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the space. Since we want to host a React application, choose to create a frontend capsule as shown below. Select the repository with the project you want to host on Code Capsules and enter the build command that will be used by Code Capsules when building your project. Also enter the static folder holding the static files for your project. After creating the Capsule, the Capsule will build the React application. You can view the build logs by clicking the \"Build and Deploy\" tab in the Capsule and then \"View build log\". Once built, navigate to the \"Overview\" tab. Code Capsules provides a default URL for viewing applications \u2013 find this under \"Domains\". Click the URL to view the application. If you'd like to deploy another React application in the future, take a look at the React repository . Code Capsules was able to deploy the application by reading the package.json file. You can find the script that Code Capsules used to run the application on line 16 of the package.json file.","title":"React"},{"location":"deployment/how-to-deploy-react-application-to-production/#how-to-deploy-a-react-application-to-production-on-code-capsules","text":"React is an efficient and flexible JavaScript library which is great for building user interfaces. If you've built a web app with React, you'll want to deploy it to production so you can share it with the rest of the world. In this tutorial, we'll show you how to do just that, step by step. To follow along, you'll need: A GitHub account. A Code Capsules account.","title":"How to Deploy a React Application to Production on Code Capsules"},{"location":"deployment/how-to-deploy-react-application-to-production/#get-some-example-code","text":"We'll use our example React application for the demonstration. You can use your own React application instead, or work from ours as a starting point. Fork the project to your own account by clicking on the above link and pressing \"fork\" in the top right.","title":"Get Some Example Code"},{"location":"deployment/how-to-deploy-react-application-to-production/#sign-up-for-code-capsules","text":"If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just signed up for an account, you'll be directed to the Welcome page on your first login. Click on the \"Go To Personal Team\" button. You will be redirected to the Spaces tab for your Personal Team. Code Capsules gives every account a Personal Team as a default.","title":"Sign Up for Code Capsules"},{"location":"deployment/how-to-deploy-react-application-to-production/#create-a-space-for-your-apps","text":"Next, click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, click on the \"New Space\" button to create a new space for this tutorial, or select any of your existing ones. Whichever way you go about it, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region and enter a name for your space, then click \"Create Space\".","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-react-application-to-production/#link-to-github","text":"To host our React application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. We can link the GitHub repository by clicking the profile image at the top right of the screen, and finding the GitHub button under \"GitHub Details\". Click the \"GitHub\" button. To give Code Capsules access to the React application, you need to: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the contents of the selected repositories. All that's left to deploy the application is to add the repo to your team and create a Capsule . This Capsule will act as a storage space for the React application.","title":"Link to GitHub"},{"location":"deployment/how-to-deploy-react-application-to-production/#add-repo-to-team","text":"Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the Edit Team Repos screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. Once this is done, all Spaces in your team will have access to this repo.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-react-application-to-production/#create-the-capsule","text":"Return to the Spaces tab. Next, click on the Space you just created or are using, and create a new capsule in that space. To do this, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the space. Since we want to host a React application, choose to create a frontend capsule as shown below. Select the repository with the project you want to host on Code Capsules and enter the build command that will be used by Code Capsules when building your project. Also enter the static folder holding the static files for your project. After creating the Capsule, the Capsule will build the React application. You can view the build logs by clicking the \"Build and Deploy\" tab in the Capsule and then \"View build log\". Once built, navigate to the \"Overview\" tab. Code Capsules provides a default URL for viewing applications \u2013 find this under \"Domains\". Click the URL to view the application. If you'd like to deploy another React application in the future, take a look at the React repository . Code Capsules was able to deploy the application by reading the package.json file. You can find the script that Code Capsules used to run the application on line 16 of the package.json file.","title":"Create the Capsule"},{"location":"deployment/how-to-deploy-static-html-to-production/","text":"How to Deploy an HTML Site to Production on Code Capsules Deploy a static HTML site and learn how to host frontend code on Code Capsules. Set Up For this tutorial, you'll need: - A Code Capsules account. - A GitHub account. This tutorial will focus on deploying frontend code to Code Capsules \u2013 we'll deploy a simple static HTML website and see how this process works. The HTML code has already been provided by Code Capsules. Follow this link to view the repository. In order to deploy this repository to Code Capsules, we'll need to fork the repository by clicking \"fork\" at the top-right of the repository. Feel free to make any edits to the HTML code if you want to. Then, we can move on to deploying the static website. Sign Up for Code Capsules If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just created an account, make sure to confirm it by checking your email for a message from Code Capsules. On your first login, you'll be directed to the Welcome page. Click on the \"Go To Personal Team\" button. After clicking on the \"Go To Personal Team\" button, you will be redirected to the Spaces tab for your Personal Team. A Team is an environment for you to manage your Spaces and Capsules. Teams can have multiple members interacting with the projects associated with that particular Team. Code Capsules gives every account a Personal Team as the default. For this tutorial, we'll use the provided Team to host our static frontend website for free. Create a Space for Your Apps Spaces are an organisational tool for your applications. Click the \"Create A New Space For Your Apps\" button and follow the prompts, naming the Space anything you'd like. Now that we've created a Space, we need to connect the GitHub repository we forked to our Code Capsules. Link to GitHub Code Capsules deploys code online by \"linking\" to your GitHub repositories. For Code Capsules to gain access to the forked repository containing the HTML code, we need to give it permission. We can do this by clicking the profile image at the top right of the page. Here, we'll see a \"GitHub button\" located under \"GitHub Details\". Click on the \"GitHub\" button. You can authorise Code Capsules to connect to the forked repository by: Clicking your GitHub username. Selecting \"Only Select Repositories\". Choosing the GitHub repository we forked. Pressing \"Install & Authorize\". Once authorised on your GitHub account, Code Capsules will be able to access the repository and deploy the code. Now we just need to tell Code Capsules to deploy the HTML code, by adding the repository to our Personal Team and creating a Capsule . Add Repo to Team On Code Capsules, click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo. Create the Capsule The next step is to create a Capsule which provides the server for hosting our application on Code Capsules. To do this, click \"Spaces\" on the top navigation bar to switch to the Spaces tab and open the Space you created above. Once inside the Space, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button and follow the instructions below. Choose a \"Frontend\" Capsule. Select the \"Trial \u2013 Static Site Hosting\" product. Choose the GitHub repository we forked. Press next. Leave the \"Build command\" and \"Static content folder path\" blank and create the Capsule. While the Capsule is building, you can view its logs under the \"Build and Deploy\" tab in the Capsule. Once built, you can navigate to the Overview tab and click on the provided URL to view the application. For a better understanding of Capsules, read this explanation on Capsules .","title":"HTML"},{"location":"deployment/how-to-deploy-static-html-to-production/#how-to-deploy-an-html-site-to-production-on-code-capsules","text":"Deploy a static HTML site and learn how to host frontend code on Code Capsules.","title":"How to Deploy an HTML Site to Production on Code Capsules"},{"location":"deployment/how-to-deploy-static-html-to-production/#set-up","text":"For this tutorial, you'll need: - A Code Capsules account. - A GitHub account. This tutorial will focus on deploying frontend code to Code Capsules \u2013 we'll deploy a simple static HTML website and see how this process works. The HTML code has already been provided by Code Capsules. Follow this link to view the repository. In order to deploy this repository to Code Capsules, we'll need to fork the repository by clicking \"fork\" at the top-right of the repository. Feel free to make any edits to the HTML code if you want to. Then, we can move on to deploying the static website.","title":"Set Up"},{"location":"deployment/how-to-deploy-static-html-to-production/#sign-up-for-code-capsules","text":"If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just created an account, make sure to confirm it by checking your email for a message from Code Capsules. On your first login, you'll be directed to the Welcome page. Click on the \"Go To Personal Team\" button. After clicking on the \"Go To Personal Team\" button, you will be redirected to the Spaces tab for your Personal Team. A Team is an environment for you to manage your Spaces and Capsules. Teams can have multiple members interacting with the projects associated with that particular Team. Code Capsules gives every account a Personal Team as the default. For this tutorial, we'll use the provided Team to host our static frontend website for free.","title":"Sign Up for Code Capsules"},{"location":"deployment/how-to-deploy-static-html-to-production/#create-a-space-for-your-apps","text":"Spaces are an organisational tool for your applications. Click the \"Create A New Space For Your Apps\" button and follow the prompts, naming the Space anything you'd like. Now that we've created a Space, we need to connect the GitHub repository we forked to our Code Capsules.","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-static-html-to-production/#link-to-github","text":"Code Capsules deploys code online by \"linking\" to your GitHub repositories. For Code Capsules to gain access to the forked repository containing the HTML code, we need to give it permission. We can do this by clicking the profile image at the top right of the page. Here, we'll see a \"GitHub button\" located under \"GitHub Details\". Click on the \"GitHub\" button. You can authorise Code Capsules to connect to the forked repository by: Clicking your GitHub username. Selecting \"Only Select Repositories\". Choosing the GitHub repository we forked. Pressing \"Install & Authorize\". Once authorised on your GitHub account, Code Capsules will be able to access the repository and deploy the code. Now we just need to tell Code Capsules to deploy the HTML code, by adding the repository to our Personal Team and creating a Capsule .","title":"Link to GitHub"},{"location":"deployment/how-to-deploy-static-html-to-production/#add-repo-to-team","text":"On Code Capsules, click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-static-html-to-production/#create-the-capsule","text":"The next step is to create a Capsule which provides the server for hosting our application on Code Capsules. To do this, click \"Spaces\" on the top navigation bar to switch to the Spaces tab and open the Space you created above. Once inside the Space, click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button and follow the instructions below. Choose a \"Frontend\" Capsule. Select the \"Trial \u2013 Static Site Hosting\" product. Choose the GitHub repository we forked. Press next. Leave the \"Build command\" and \"Static content folder path\" blank and create the Capsule. While the Capsule is building, you can view its logs under the \"Build and Deploy\" tab in the Capsule. Once built, you can navigate to the Overview tab and click on the provided URL to view the application. For a better understanding of Capsules, read this explanation on Capsules .","title":"Create the Capsule"},{"location":"deployment/how-to-deploy-vue-application-to-production/","text":"How to Deploy a Vue Application to Production on Code Capsules Deploy a Vue application and learn how to host frontend code on Code Capsules. Set Up Code Capsules connects to GitHub repositories to deploy applications. For this tutorial, you'll need: - A Code Capsules account. - A GitHub account. We'll deploy a Vue application on Code Capsules using example source code provided by Code Capsules on their GitHub. You can find the repository here . You can also link any of your GitHub repositories to Code Capsules, and Code Capsules will deploy it. In order to deploy this repository to Code Capsules, make sure to fork the Vue application. You can do so by visiting the repository and clicking the \"Fork\" button at the top right. After forking the application, we can deploy it. Make any edits you'd like to the repository and continue. Sign Up for Code Capsules If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just created an account, make sure to confirm it by checking your email for a message from Code Capsules. On your first login, you'll be directed to the Welcome page. Click on the \"Go To Personal Team\" button. A Team is an environment for you to manage your Spaces and Capsules. Code Capsules gives every account a Personal Team as a default. The default Personal Team allows users to host static frontend websites for free. Create a Space for Your Apps Spaces are an organisational tool for your applications. Click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new Space for this tutorial, or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region, enter a name for your space, and press \"Create Space\". Link to GitHub To host our Vue application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. We can link the Vue application by clicking the profile image at the top right of the screen, and finding the \"GitHub\" button under \"GitHub Details\" Click the \"GitHub\" button. To give Code Capsules access to the Vue application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the repository containing the Vue application. All that's left to deploy the application is to add the repo to our Team and create a Capsule . Add Repo to Team Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo. Create the Capsule Capsules act as storage spaces for applications. For a better understanding of Capsules, read this explanation on Capsules . To deploy the Vue application, go back to the Spaces tab. Next, click on the Space you just created or are using, and create a new Capsule in that Space. Click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the Space. Next: Choose a \"Frontend\" Capsule. Select the \"Trial \u2013 Static Site Hosting\" product. Choose the GitHub repository we forked. Press next. Use npm run build for the \"Build command\" and dist for \"Static content folder path\". Press \"Create Capsule\". After creating the Capsule, the Capsule will build the Vue application. You can view the build logs by clicking the \"Logs\" tab in the Capsule. Once built, navigate to the Overview tab. Code Capsules provides a default URL for viewing applications; you can find this under \"domains\". Click the URL to view the application. If you'd like to deploy another Vue application in the future, take a look at the Vue repository . Code Capsules was able to deploy the application by reading the package.json file. You can find the script that Code Capsules used to run the application on line five in the package.json file.","title":"Vue"},{"location":"deployment/how-to-deploy-vue-application-to-production/#how-to-deploy-a-vue-application-to-production-on-code-capsules","text":"Deploy a Vue application and learn how to host frontend code on Code Capsules.","title":"How to Deploy a Vue Application to Production on Code Capsules"},{"location":"deployment/how-to-deploy-vue-application-to-production/#set-up","text":"Code Capsules connects to GitHub repositories to deploy applications. For this tutorial, you'll need: - A Code Capsules account. - A GitHub account. We'll deploy a Vue application on Code Capsules using example source code provided by Code Capsules on their GitHub. You can find the repository here . You can also link any of your GitHub repositories to Code Capsules, and Code Capsules will deploy it. In order to deploy this repository to Code Capsules, make sure to fork the Vue application. You can do so by visiting the repository and clicking the \"Fork\" button at the top right. After forking the application, we can deploy it. Make any edits you'd like to the repository and continue.","title":"Set Up"},{"location":"deployment/how-to-deploy-vue-application-to-production/#sign-up-for-code-capsules","text":"If you don't already have a Code Capsules account, head to the site and click the \"Sign Up\" button in the top right. Enter your details to create an account, or log into an existing one. If you've just created an account, make sure to confirm it by checking your email for a message from Code Capsules. On your first login, you'll be directed to the Welcome page. Click on the \"Go To Personal Team\" button. A Team is an environment for you to manage your Spaces and Capsules. Code Capsules gives every account a Personal Team as a default. The default Personal Team allows users to host static frontend websites for free.","title":"Sign Up for Code Capsules"},{"location":"deployment/how-to-deploy-vue-application-to-production/#create-a-space-for-your-apps","text":"Spaces are an organisational tool for your applications. Click on the \"Create A New Space For Your Apps\" button. Alternatively, if you had logged into an existing Code Capsules account, you could click on the \"New Space\" button to create a new Space for this tutorial, or select any of your existing ones. After actioning either of these steps, a UI similar to the one shown below should slide in from the right of your screen. Select an appropriate region, enter a name for your space, and press \"Create Space\".","title":"Create a Space for Your Apps"},{"location":"deployment/how-to-deploy-vue-application-to-production/#link-to-github","text":"To host our Vue application on Code Capsules, we need to link our forked GitHub repository to our Code Capsules account. We can link the Vue application by clicking the profile image at the top right of the screen, and finding the \"GitHub\" button under \"GitHub Details\" Click the \"GitHub\" button. To give Code Capsules access to the Vue application: Click your GitHub username. Select \"Only Select Repositories\". Choose the GitHub repository we forked. Press \"Install & Authorize\". After authorising, Code Capsules will be able to read the repository containing the Vue application. All that's left to deploy the application is to add the repo to our Team and create a Capsule .","title":"Link to GitHub"},{"location":"deployment/how-to-deploy-vue-application-to-production/#add-repo-to-team","text":"Click on \"Team Settings\" on the top navigation bar to switch to the Team Settings tab. Once there, click on the \"Modify\" button under the Team Repos section to add the repo to your Personal Team. When the \"Edit Team Repos\" screen slides in, select \"Add\" next to the repo you want to add to your Personal Team and then confirm. After this is done, all Spaces in your Team will have access to this repo.","title":"Add Repo to Team"},{"location":"deployment/how-to-deploy-vue-application-to-production/#create-the-capsule","text":"Capsules act as storage spaces for applications. For a better understanding of Capsules, read this explanation on Capsules . To deploy the Vue application, go back to the Spaces tab. Next, click on the Space you just created or are using, and create a new Capsule in that Space. Click the \"New Capsule\" or \"Create A New Capsule For Your Space\" button when inside the Space. Next: Choose a \"Frontend\" Capsule. Select the \"Trial \u2013 Static Site Hosting\" product. Choose the GitHub repository we forked. Press next. Use npm run build for the \"Build command\" and dist for \"Static content folder path\". Press \"Create Capsule\". After creating the Capsule, the Capsule will build the Vue application. You can view the build logs by clicking the \"Logs\" tab in the Capsule. Once built, navigate to the Overview tab. Code Capsules provides a default URL for viewing applications; you can find this under \"domains\". Click the URL to view the application. If you'd like to deploy another Vue application in the future, take a look at the Vue repository . Code Capsules was able to deploy the application by reading the package.json file. You can find the script that Code Capsules used to run the application on line five in the package.json file.","title":"Create the Capsule"},{"location":"reference/","text":"Reference documentation Looking to do something specific? You should find it here. If not, join our Slack community to let us know and we'll get on it!","title":"Overview"},{"location":"reference/#reference-documentation","text":"Looking to do something specific? You should find it here. If not, join our Slack community to let us know and we'll get on it!","title":"Reference documentation"},{"location":"reference/custom_domains/","text":"Custom Domains For every application deployed to Code Capsules, Code Capsules provides a default domain that looks something like this: capsulename.xxxx.codecapsules.co.za . If you have purchased a domain like example.com from a domain registrar and would like to replace it with the default Code Capsules domain, Code Capsules lets you use your own domain instead (for free). You can find everything relating to your Capsule's domains (including your default domain) under the \"Overview\" tab in the Capsule. This is also where you can add a purchased custom domain to your application. How to Add a Custom Domain To add a custom domain to your application on Code Capsules, click on the \"Overview\" tab in the Capsule hosting your application. Under Domains, you'll see all of the domains associated with your Capsule; including the default domain provided by Code Capsules. There is also an \"Add a Custom Domain\" button at the bottom of the page. Before adding a custom domain , consider: - Your capsule may route to only one root domain. You may not add multiple root domains to your Capsule. To add a custom domain: Click the \"Add a Custom Domain\" button. Save the IP address provided under \"A Record Route\" (this will be used shortly). Enter the custom domain you've purchased from a domain registrar under \"Domain Name\". Make sure that you've entered a root domain only - do not include a subdomain. A root domain contains only your domain name and your top-level domain (TLD). Take example.com . Here, \"example\" is the domain name, and \".com\" is the TLD. Once you've entered your root domain, add it by clicking the Create Domain button. Creating an A record After adding your custom domain on Code Capsules, you need to create an A record for the domain you've purchased. You'll use the IP that was saved previously when creating the A record for your domain. You can add an A record to your purchased domain by visiting your domain registrar's website. Your A record table should look something like this: Record Type Name IPv4 Address A Record @ provided-IP-Address where, \"@\" refers to your root domain. provided-IP-Address is the IP address found previously under \"A Record Route\" Consult your domain registrar for specific instructions on adding A records to your domain. Keep in mind, when making changes to your domain's DNS records , changes may take several hours to take effect. How to Add a Subdomain Before adding a subdomain to your application hosted on Code Capsules, make sure you have already created an A record for your purchased domain that routes to an application on Code Capsules. When adding a subdomain to your application hosted on Code Capsules, keep in mind: Applications hosted on Code Capsules can have a maximum of five subdomains. Wildcard subdomains are not allowed on Code Capsules - you'll need to create a CNAME record in your purchased domain for each subdomain you want to create. To add a subdomain for your application, follow the same process detailed previously , with some changes: This time you must include the subdomain you want to create. This means that instead of entering the root domain domain-name.tld , you should specify your subdomain as well, such as: app.example.com . You do not need to save the IP address provided under \"A Record Route\" when adding subdomains on Code Capsules. After clicking the Create Domain button, you must create a CNAME record for your purchased domain with information about the subdomain you'd like to create. Creating CNAME Records Creating CNAME records for purchased domains vary for different domain registrars. Consult your domain registrar for information on creating CNAME records. In general, the CNAME record table for your domain should look something like this: Record Type Name Host/Target CNAME subdomain your-root-domain where, subdomain is the subdomain you would like to create (e.g. app , www ) your-root-domain is your root domain that contains an A record routing to your application on Code Capsules. As with adding an A record, CNAME records or any other changes to your domain's DNS records may take several hours to take effect. Removing Domains and Subdomains If you would like to remove any domains or subdomains associated with your Capsule, navigate to the \"Overview\" tab in your Capsule. Under Domains, you will see a list of all the domains that are associated with your Capsule. Next to each custom domain and subdomain, you'll find a trash can icon. Click the trash can icon to remove the custom domain or subdomain. Note, removing a custom domain or subdomain does not affect your domain's DNS records: When removing a root domain on Code Capsules, your A record will still be associated with the IP address provided by Code Capsules. Make sure to revert your domain's A record to its default value. When removing a subdomain on Code Capsules, make sure to delete the corresponding CNAME record in your purchased domain. Glossary of Terms & Concepts Here is a list of defined terms and concepts used throughout this article. Divided into three sections, here you'll find definitions for: structures related to URLs, DNS records, and information related to HTTP. Makeup of a URL Uniform Resource Locator (URL) : In the above image, www.example.com is the URL. A URL is a combination of three different aspects of a domain: A subdomain, a second-level domain, and a top-level domain. Subdomain : Subdomains are the first part of a URL, the most common being www . Subdomains provide users with a consistent naming strategy to access service you may provide (for example, hr.myapplication.com may route users to your business' human resources portal). Second-level domain (SLD): Second level domains make up the middle of a URL. This is your domain's name. Top-level domain (TLD): Top-level domains are the text at the right-hand side of a URL. TLDs give users an idea about your website. For example, the .de TLD lets users know the website probably caters to a German audience. Root Domain : The root domain is a combination of a second-level and top-level domain without a subdomain. example.com is an example of a root domain, whereas www.example.com is not a root domain. DNS records Domain Registrar : A company that sells and manages domains. A Record : An A record routes a domain (e.g. example.com to an IP addresses (e.g. 123.456.567.8 ) Wildcard subdomain : A wildcard subdomain points all subdomains not created for your purchased domain to a specific place. For example, if a wildcard subdomain was created for example.com , and the subdomains info and 123 were not created for example.com , both info.example.com and 123.example.com would route to example.com . CNAME Record : A CNAME record, also known as an alias , routes subdomains to other domain names. For example, mail.example.com may route to mail.google.com . CNAME records are unlike A records, which route to a specific IP address. HTTP and SSL Hypertext Transfer Protocol (HTTP): HTTP is a protocol for transferring data from a server (a web-application) to a client (your web-browser). Hypertext Transfer Protocol Secure (HTTPS): HTTPS is like HTTP, except the data transferred from the server to client is encrypted for better security. Secure Sockets Layer Certificate (SSL): An SSL Certificate authenticates a domain and allows encrypted information to send to the domains server - with an SSL certificate you can connect to your domain via HTTPS, i.e: https://www.example.com.","title":"Custom Domains"},{"location":"reference/custom_domains/#custom-domains","text":"For every application deployed to Code Capsules, Code Capsules provides a default domain that looks something like this: capsulename.xxxx.codecapsules.co.za . If you have purchased a domain like example.com from a domain registrar and would like to replace it with the default Code Capsules domain, Code Capsules lets you use your own domain instead (for free). You can find everything relating to your Capsule's domains (including your default domain) under the \"Overview\" tab in the Capsule. This is also where you can add a purchased custom domain to your application.","title":"Custom Domains"},{"location":"reference/custom_domains/#how-to-add-a-custom-domain","text":"To add a custom domain to your application on Code Capsules, click on the \"Overview\" tab in the Capsule hosting your application. Under Domains, you'll see all of the domains associated with your Capsule; including the default domain provided by Code Capsules. There is also an \"Add a Custom Domain\" button at the bottom of the page. Before adding a custom domain , consider: - Your capsule may route to only one root domain. You may not add multiple root domains to your Capsule. To add a custom domain: Click the \"Add a Custom Domain\" button. Save the IP address provided under \"A Record Route\" (this will be used shortly). Enter the custom domain you've purchased from a domain registrar under \"Domain Name\". Make sure that you've entered a root domain only - do not include a subdomain. A root domain contains only your domain name and your top-level domain (TLD). Take example.com . Here, \"example\" is the domain name, and \".com\" is the TLD. Once you've entered your root domain, add it by clicking the Create Domain button.","title":"How to Add a Custom Domain"},{"location":"reference/custom_domains/#creating-an-a-record","text":"After adding your custom domain on Code Capsules, you need to create an A record for the domain you've purchased. You'll use the IP that was saved previously when creating the A record for your domain. You can add an A record to your purchased domain by visiting your domain registrar's website. Your A record table should look something like this: Record Type Name IPv4 Address A Record @ provided-IP-Address where, \"@\" refers to your root domain. provided-IP-Address is the IP address found previously under \"A Record Route\" Consult your domain registrar for specific instructions on adding A records to your domain. Keep in mind, when making changes to your domain's DNS records , changes may take several hours to take effect.","title":"Creating an A record"},{"location":"reference/custom_domains/#how-to-add-a-subdomain","text":"Before adding a subdomain to your application hosted on Code Capsules, make sure you have already created an A record for your purchased domain that routes to an application on Code Capsules. When adding a subdomain to your application hosted on Code Capsules, keep in mind: Applications hosted on Code Capsules can have a maximum of five subdomains. Wildcard subdomains are not allowed on Code Capsules - you'll need to create a CNAME record in your purchased domain for each subdomain you want to create. To add a subdomain for your application, follow the same process detailed previously , with some changes: This time you must include the subdomain you want to create. This means that instead of entering the root domain domain-name.tld , you should specify your subdomain as well, such as: app.example.com . You do not need to save the IP address provided under \"A Record Route\" when adding subdomains on Code Capsules. After clicking the Create Domain button, you must create a CNAME record for your purchased domain with information about the subdomain you'd like to create.","title":"How to Add a Subdomain"},{"location":"reference/custom_domains/#creating-cname-records","text":"Creating CNAME records for purchased domains vary for different domain registrars. Consult your domain registrar for information on creating CNAME records. In general, the CNAME record table for your domain should look something like this: Record Type Name Host/Target CNAME subdomain your-root-domain where, subdomain is the subdomain you would like to create (e.g. app , www ) your-root-domain is your root domain that contains an A record routing to your application on Code Capsules. As with adding an A record, CNAME records or any other changes to your domain's DNS records may take several hours to take effect.","title":"Creating CNAME Records"},{"location":"reference/custom_domains/#removing-domains-and-subdomains","text":"If you would like to remove any domains or subdomains associated with your Capsule, navigate to the \"Overview\" tab in your Capsule. Under Domains, you will see a list of all the domains that are associated with your Capsule. Next to each custom domain and subdomain, you'll find a trash can icon. Click the trash can icon to remove the custom domain or subdomain. Note, removing a custom domain or subdomain does not affect your domain's DNS records: When removing a root domain on Code Capsules, your A record will still be associated with the IP address provided by Code Capsules. Make sure to revert your domain's A record to its default value. When removing a subdomain on Code Capsules, make sure to delete the corresponding CNAME record in your purchased domain.","title":"Removing Domains and Subdomains"},{"location":"reference/custom_domains/#glossary-of-terms-concepts","text":"Here is a list of defined terms and concepts used throughout this article. Divided into three sections, here you'll find definitions for: structures related to URLs, DNS records, and information related to HTTP.","title":"Glossary of Terms &amp; Concepts"},{"location":"reference/custom_domains/#makeup-of-a-url","text":"Uniform Resource Locator (URL) : In the above image, www.example.com is the URL. A URL is a combination of three different aspects of a domain: A subdomain, a second-level domain, and a top-level domain. Subdomain : Subdomains are the first part of a URL, the most common being www . Subdomains provide users with a consistent naming strategy to access service you may provide (for example, hr.myapplication.com may route users to your business' human resources portal). Second-level domain (SLD): Second level domains make up the middle of a URL. This is your domain's name. Top-level domain (TLD): Top-level domains are the text at the right-hand side of a URL. TLDs give users an idea about your website. For example, the .de TLD lets users know the website probably caters to a German audience. Root Domain : The root domain is a combination of a second-level and top-level domain without a subdomain. example.com is an example of a root domain, whereas www.example.com is not a root domain.","title":"Makeup of a URL"},{"location":"reference/custom_domains/#dns-records","text":"Domain Registrar : A company that sells and manages domains. A Record : An A record routes a domain (e.g. example.com to an IP addresses (e.g. 123.456.567.8 ) Wildcard subdomain : A wildcard subdomain points all subdomains not created for your purchased domain to a specific place. For example, if a wildcard subdomain was created for example.com , and the subdomains info and 123 were not created for example.com , both info.example.com and 123.example.com would route to example.com . CNAME Record : A CNAME record, also known as an alias , routes subdomains to other domain names. For example, mail.example.com may route to mail.google.com . CNAME records are unlike A records, which route to a specific IP address.","title":"DNS records"},{"location":"reference/custom_domains/#http-and-ssl","text":"Hypertext Transfer Protocol (HTTP): HTTP is a protocol for transferring data from a server (a web-application) to a client (your web-browser). Hypertext Transfer Protocol Secure (HTTPS): HTTPS is like HTTP, except the data transferred from the server to client is encrypted for better security. Secure Sockets Layer Certificate (SSL): An SSL Certificate authenticates a domain and allows encrypted information to send to the domains server - with an SSL certificate you can connect to your domain via HTTPS, i.e: https://www.example.com.","title":"HTTP and SSL"},{"location":"reference/set-up-file-data-capsule/","text":"How to Set Up a Persistent File Data Capsule You need persistent storage to develop your application that solves a real-world problem, but you don't want a full-blown database. In this tutorial, we'll show you how to create a persistent file Data Capsule that you can use with your backend applications running on Code Capsules. Create a File Data Capsule Log in to your Code Capsules account and navigate to the Space your file data capsule will be contained in. Click \"New Capsule\" and select the \"Data Capsule\" option from the \"Create New Capsule\" dialog that slides in from the right. In the \"New Data Capsule\" dialog, choose \"A persistent storage mounted directly to your capsule.\" as your data type, then click the \"Create Capsule\" button. Binding a Data Capsule to a Backend Capsule You need to bind the Data Capsule to a Backend Capsule hosted on Code Capsules before you can connect to it and use it. Navigate to the Backend Capsule and click \"Configure\" to open the capsule's config tab. Scroll down to the \"Bind Data capsule\" section where your recently created data capsule will show. Click \"Bind\" to bind your Data and Backend Capsules. During the bind process, Code Capsules creates a PERSISTENT_STORAGE_DIR environment variable to let your Backend Capsule know where your Data Capsule resides in order to access its features. Once the two capsules have been bound, you can scroll to the top of the Configure tab to find the value of this variable. The next step is to use this environment variable in code in order to read and write to our Data Capsule. Copy the value of the PERSISTENT_STORAGE_DIR variable and paste it in your code as the value of the db_directory variable. Alternatively, reference it directly in your code using os.getenv for Python or process.env for Node.js. Connecting to a File Data Capsule From a Python Application If your backend capsule is a Python application, use the following code to connect to your file data capsule: import os db_directory = os . getenv ( 'PERSISTENT_STORAGE_DIR' ) ### Do something with the db_directory variable here file_to_write = os . path . join ( db_directory , \"test.txt\" ) file1 = open ( file_to_write , \"w\" ) file1 . write ( \"File writing test\" ) file1 . close () Connecting to a File Data Capsule From a Node.js Application If your backend capsule is a Node.js application, use the following code to connect to your file data capsule: db_directory = process . env . PERSISTENT_STORAGE_DIR const fs = require ( 'fs' ) const content = 'Some content!' // Do something with the db_directory variable here fs . writeFile ( db_directory + '/test.txt' , content , err => { if ( err ) { console . error ( err ) return } //file written successfully })","title":"File Data Capsule"},{"location":"reference/set-up-file-data-capsule/#how-to-set-up-a-persistent-file-data-capsule","text":"You need persistent storage to develop your application that solves a real-world problem, but you don't want a full-blown database. In this tutorial, we'll show you how to create a persistent file Data Capsule that you can use with your backend applications running on Code Capsules.","title":"How to Set Up a Persistent File Data Capsule"},{"location":"reference/set-up-file-data-capsule/#create-a-file-data-capsule","text":"Log in to your Code Capsules account and navigate to the Space your file data capsule will be contained in. Click \"New Capsule\" and select the \"Data Capsule\" option from the \"Create New Capsule\" dialog that slides in from the right. In the \"New Data Capsule\" dialog, choose \"A persistent storage mounted directly to your capsule.\" as your data type, then click the \"Create Capsule\" button.","title":"Create a File Data Capsule"},{"location":"reference/set-up-file-data-capsule/#binding-a-data-capsule-to-a-backend-capsule","text":"You need to bind the Data Capsule to a Backend Capsule hosted on Code Capsules before you can connect to it and use it. Navigate to the Backend Capsule and click \"Configure\" to open the capsule's config tab. Scroll down to the \"Bind Data capsule\" section where your recently created data capsule will show. Click \"Bind\" to bind your Data and Backend Capsules. During the bind process, Code Capsules creates a PERSISTENT_STORAGE_DIR environment variable to let your Backend Capsule know where your Data Capsule resides in order to access its features. Once the two capsules have been bound, you can scroll to the top of the Configure tab to find the value of this variable. The next step is to use this environment variable in code in order to read and write to our Data Capsule. Copy the value of the PERSISTENT_STORAGE_DIR variable and paste it in your code as the value of the db_directory variable. Alternatively, reference it directly in your code using os.getenv for Python or process.env for Node.js.","title":"Binding a Data Capsule to a Backend Capsule"},{"location":"reference/set-up-file-data-capsule/#connecting-to-a-file-data-capsule-from-a-python-application","text":"If your backend capsule is a Python application, use the following code to connect to your file data capsule: import os db_directory = os . getenv ( 'PERSISTENT_STORAGE_DIR' ) ### Do something with the db_directory variable here file_to_write = os . path . join ( db_directory , \"test.txt\" ) file1 = open ( file_to_write , \"w\" ) file1 . write ( \"File writing test\" ) file1 . close ()","title":"Connecting to a File Data Capsule From a Python Application"},{"location":"reference/set-up-file-data-capsule/#connecting-to-a-file-data-capsule-from-a-nodejs-application","text":"If your backend capsule is a Node.js application, use the following code to connect to your file data capsule: db_directory = process . env . PERSISTENT_STORAGE_DIR const fs = require ( 'fs' ) const content = 'Some content!' // Do something with the db_directory variable here fs . writeFile ( db_directory + '/test.txt' , content , err => { if ( err ) { console . error ( err ) return } //file written successfully })","title":"Connecting to a File Data Capsule From a Node.js Application"},{"location":"reference/set-up-mongodb-data-capsule/","text":"How to Set Up a MongoDB Data Capsule MongoDB provides reliable NoSQL persistent storage for your applications. In this tutorial, we look at how to create a MongoDB instance you can use with your backend applications that are running on Code Capsules and elsewhere. Create a MongoDB Data Capsule Log in to your Code Capsules account and navigate to the Space your MongoDB data capsule will be contained in. Click \"New Capsule\" and select the \"Data Capsule\" option from the Create New Capsule dialog that slides in from the right. In the New Data Capsule dialog, choose \"MongoDB Database Cluster\" as your data type, then click the \"Create Capsule\" button. To allow your data capsule to be publicly accessible, navigate to the \"Overview\" tab of the capsule details screen and toggle the switch under \"Public Access\" to on. Select this option if you plan on connecting your data capsule to an application that's not hosted on Code Capsules. Binding a Data Capsule to a Backend Capsule To connect a data capsule to a backend capsule hosted on Code Capsules you need to bind the two together before you can connect to and use your data capsule. If you're not hosting your backend application on Code Capsules you can jump to this section as the binding step is not applicable in that use case. Navigate to the backend capsule and click \"Config\" to open the capsule's config tab. Scroll down to the \"Bind Data capsule\" section where your recently created data capsule will show. Click \"Bind\" to bind your data and backend capsules. During the bind process, Code Capsules creates a DATABASE_URL environmental variable to let your backend capsule know how to access services and features of your data capsule. Once the two capsules have been bound, you can scroll to the top of the Config tab to find the value of this variable. We can use this database variable in code to read and write to our data capsule. Copy the value of the DATABASE_URL variable and append /your_db_name?authSource=admin to it as a query parameter. Make sure to replace your_db_name with the actual name of your database. This tells the data capsule to read and write to the specified database. If a database named your_db_name doesn't exist, the data capsule will create it. This allows you to have multiple databases in one data capsule. Connecting to a MongoDB Data Capsule From a Python Application If your backend capsule is a Python application, use the following code to connect to your MongoDB Data Capsule: import os import pymongo data_capsule_url = os . getenv ( 'DATABASE_URL' ) database_one_url = data_capsule_url + \"/database_one?authSource=admin\" production_database_url = data_capsule_url + \"/production_database?authSource=admin\" client = pymongo . MongoClient ( database_one_url ) db = client . database_one ### Do something with the db variable here Connecting to a MongoDB Data Capsule From a Node.js Application If your backend capsule is a Node.js application, use the following code to connect to your MongoDB Data Capsule: data_capsule_url = process . env . DATABASE_URL database_one_url = data_capsule_url + \"/database_one?authSource=admin\" production_database_url = data_capsule_url + \"/production_database?authSource=admin\" var MongoClient = require ( 'mongodb' ). MongoClient ; MongoClient . connect ( database_one_url , function ( err , db ) { // Do something with the db variable here }); Connecting to a MongoDB Data Capsule From Outside Code Capsules If you're not hosting your backend application on Code Capsules you can still connect your data capsule to it. The first step is to allow public access to your data capsule. Make sure this option is turned on in the \"Overview\" tab of your data capsule's details screen. If public access to your data capsule is enabled, a connection string is visible below the \"Public Access\" switch, as shown in the above picture. Copy this connection string and paste it into your backend application's code to access your data capsule's services. Take note if you copy the connection string from the capsule it will already include the database name eg. in the screenshot above this part of the connection string /app?ssl=true includes the database name which is app in this case. Connecting to a MongoDB Data Capsule From an Externally Hosted Python Application If your backend application is written in Python, use the following code to connect to your MongoDB Data Capsule: import pymongo database_url = \"<connection_string_here>\" + \"/database_one?authSource=admin\" client = pymongo . MongoClient ( database_url ) db = client . database_one ### Do something with the db variable here You'll notice in the code that we appended /database_one?authSource=admin to the connection string. This tells the data capsule to create a database with the name database_one if it doesn't exist, or to connect to it if it does.","title":"MongoDB Data Capsule"},{"location":"reference/set-up-mongodb-data-capsule/#how-to-set-up-a-mongodb-data-capsule","text":"MongoDB provides reliable NoSQL persistent storage for your applications. In this tutorial, we look at how to create a MongoDB instance you can use with your backend applications that are running on Code Capsules and elsewhere.","title":"How to Set Up a MongoDB Data Capsule"},{"location":"reference/set-up-mongodb-data-capsule/#create-a-mongodb-data-capsule","text":"Log in to your Code Capsules account and navigate to the Space your MongoDB data capsule will be contained in. Click \"New Capsule\" and select the \"Data Capsule\" option from the Create New Capsule dialog that slides in from the right. In the New Data Capsule dialog, choose \"MongoDB Database Cluster\" as your data type, then click the \"Create Capsule\" button. To allow your data capsule to be publicly accessible, navigate to the \"Overview\" tab of the capsule details screen and toggle the switch under \"Public Access\" to on. Select this option if you plan on connecting your data capsule to an application that's not hosted on Code Capsules.","title":"Create a MongoDB Data Capsule"},{"location":"reference/set-up-mongodb-data-capsule/#binding-a-data-capsule-to-a-backend-capsule","text":"To connect a data capsule to a backend capsule hosted on Code Capsules you need to bind the two together before you can connect to and use your data capsule. If you're not hosting your backend application on Code Capsules you can jump to this section as the binding step is not applicable in that use case. Navigate to the backend capsule and click \"Config\" to open the capsule's config tab. Scroll down to the \"Bind Data capsule\" section where your recently created data capsule will show. Click \"Bind\" to bind your data and backend capsules. During the bind process, Code Capsules creates a DATABASE_URL environmental variable to let your backend capsule know how to access services and features of your data capsule. Once the two capsules have been bound, you can scroll to the top of the Config tab to find the value of this variable. We can use this database variable in code to read and write to our data capsule. Copy the value of the DATABASE_URL variable and append /your_db_name?authSource=admin to it as a query parameter. Make sure to replace your_db_name with the actual name of your database. This tells the data capsule to read and write to the specified database. If a database named your_db_name doesn't exist, the data capsule will create it. This allows you to have multiple databases in one data capsule.","title":"Binding a Data Capsule to a Backend Capsule"},{"location":"reference/set-up-mongodb-data-capsule/#connecting-to-a-mongodb-data-capsule-from-a-python-application","text":"If your backend capsule is a Python application, use the following code to connect to your MongoDB Data Capsule: import os import pymongo data_capsule_url = os . getenv ( 'DATABASE_URL' ) database_one_url = data_capsule_url + \"/database_one?authSource=admin\" production_database_url = data_capsule_url + \"/production_database?authSource=admin\" client = pymongo . MongoClient ( database_one_url ) db = client . database_one ### Do something with the db variable here","title":"Connecting to a MongoDB Data Capsule From a Python Application"},{"location":"reference/set-up-mongodb-data-capsule/#connecting-to-a-mongodb-data-capsule-from-a-nodejs-application","text":"If your backend capsule is a Node.js application, use the following code to connect to your MongoDB Data Capsule: data_capsule_url = process . env . DATABASE_URL database_one_url = data_capsule_url + \"/database_one?authSource=admin\" production_database_url = data_capsule_url + \"/production_database?authSource=admin\" var MongoClient = require ( 'mongodb' ). MongoClient ; MongoClient . connect ( database_one_url , function ( err , db ) { // Do something with the db variable here });","title":"Connecting to a MongoDB Data Capsule From a Node.js Application"},{"location":"reference/set-up-mongodb-data-capsule/#connecting-to-a-mongodb-data-capsule-from-outside-code-capsules","text":"If you're not hosting your backend application on Code Capsules you can still connect your data capsule to it. The first step is to allow public access to your data capsule. Make sure this option is turned on in the \"Overview\" tab of your data capsule's details screen. If public access to your data capsule is enabled, a connection string is visible below the \"Public Access\" switch, as shown in the above picture. Copy this connection string and paste it into your backend application's code to access your data capsule's services. Take note if you copy the connection string from the capsule it will already include the database name eg. in the screenshot above this part of the connection string /app?ssl=true includes the database name which is app in this case.","title":"Connecting to a MongoDB Data Capsule From Outside Code Capsules"},{"location":"reference/set-up-mongodb-data-capsule/#connecting-to-a-mongodb-data-capsule-from-an-externally-hosted-python-application","text":"If your backend application is written in Python, use the following code to connect to your MongoDB Data Capsule: import pymongo database_url = \"<connection_string_here>\" + \"/database_one?authSource=admin\" client = pymongo . MongoClient ( database_url ) db = client . database_one ### Do something with the db variable here You'll notice in the code that we appended /database_one?authSource=admin to the connection string. This tells the data capsule to create a database with the name database_one if it doesn't exist, or to connect to it if it does.","title":"Connecting to a MongoDB Data Capsule From an Externally Hosted Python Application"},{"location":"reference/set-up-mysql-data-capsule/","text":"How to Set Up a MySQL Data Capsule In this tutorial, we'll create a MySQL Data Capsule to provide persistent storage for your applications hosted on Code Capsules. Create a MySQL Data Capsule Log in to your Code Capsules account and navigate to the Space your MySQL Data Capsule will be contained in. Click \"New Capsule\" and select the \"Data Capsule\" option from the Create New Capsule dialog that slides in from the right. In the New Data Capsule dialog, choose \"Mysql Database Cluster\" as your data type, then click the \"Create Capsule\" button. Binding a Data Capsule to a Backend Capsule To use the Data Capsule with your Backend Capsule, you'll need to link the two. Navigate to the Backend Capsule and click \"Configure\" to open the Capsule's configuration tab. Scroll down to the \"Bind Data capsule\" section and you'll see your recently created data capsule. Click \"Bind\" to bind your Data and Backend Capsules. During the bind process, Code Capsules creates a DATABASE_URL environmental variable to let your Backend Capsule know how to access your Data Capsule's services and features. Once the two capsules have been bound, you can scroll to the top of the \"Configure\" tab to find the value of this variable under the \"Capsule parameters\" section. We can use this database variable in code to read and write to our Data Capsule. Copy the value of the DATABASE_URL variable and append /your_db_name to it as a query parameter. Make sure to replace your_db_name with the actual name of your database. This tells the Data Capsule to read and write to the specified database. If a database named your_db_name doesn't exist, the Data Capsule will create it. This allows you to have multiple databases in one Data Capsule. Take note if you copy the DATABASE_URL value from the capsule it will already include the name of the default database you used whilst creating the data capsule as part of the string. Connecting to a MySQL Data Capsule from a Python Application If your Backend Capsule is a Python application, use the following code to connect to your MySQL Data Capsule: import os import mysql.connector data_capsule_url = os . getenv ( 'DATABASE_URL' ) employees_database_url = data_capsule_url + \"/employees\" cnx = mysql . connector . connect ( user = 'yourusername' , password = 'yourpassword' , host = employees_database_url , database = 'employees' ) ### Do something with the cnx variable here cnx . close () Connecting to a MySQL Data Capsule from a Node.js Application If your Backend Capsule is a Node.js application, use the following code to connect to your MySQL Data Capsule: var mysql = require ( 'mysql' ); var data_capsule_url = process . env . DATABASE_URL var employees_database_url = data_capsule_url + \"/employees\" var con = mysql . createConnection ({ host : employees_database_url , user : \"yourusername\" , password : \"yourpassword\" }); con . connect ( function ( err ) { if ( err ) throw err ; console . log ( \"Connected!\" ); // Do something with the db here });","title":"MySQL Data Capsule"},{"location":"reference/set-up-mysql-data-capsule/#how-to-set-up-a-mysql-data-capsule","text":"In this tutorial, we'll create a MySQL Data Capsule to provide persistent storage for your applications hosted on Code Capsules.","title":"How to Set Up a MySQL Data Capsule"},{"location":"reference/set-up-mysql-data-capsule/#create-a-mysql-data-capsule","text":"Log in to your Code Capsules account and navigate to the Space your MySQL Data Capsule will be contained in. Click \"New Capsule\" and select the \"Data Capsule\" option from the Create New Capsule dialog that slides in from the right. In the New Data Capsule dialog, choose \"Mysql Database Cluster\" as your data type, then click the \"Create Capsule\" button.","title":"Create a MySQL Data Capsule"},{"location":"reference/set-up-mysql-data-capsule/#binding-a-data-capsule-to-a-backend-capsule","text":"To use the Data Capsule with your Backend Capsule, you'll need to link the two. Navigate to the Backend Capsule and click \"Configure\" to open the Capsule's configuration tab. Scroll down to the \"Bind Data capsule\" section and you'll see your recently created data capsule. Click \"Bind\" to bind your Data and Backend Capsules. During the bind process, Code Capsules creates a DATABASE_URL environmental variable to let your Backend Capsule know how to access your Data Capsule's services and features. Once the two capsules have been bound, you can scroll to the top of the \"Configure\" tab to find the value of this variable under the \"Capsule parameters\" section. We can use this database variable in code to read and write to our Data Capsule. Copy the value of the DATABASE_URL variable and append /your_db_name to it as a query parameter. Make sure to replace your_db_name with the actual name of your database. This tells the Data Capsule to read and write to the specified database. If a database named your_db_name doesn't exist, the Data Capsule will create it. This allows you to have multiple databases in one Data Capsule. Take note if you copy the DATABASE_URL value from the capsule it will already include the name of the default database you used whilst creating the data capsule as part of the string.","title":"Binding a Data Capsule to a Backend Capsule"},{"location":"reference/set-up-mysql-data-capsule/#connecting-to-a-mysql-data-capsule-from-a-python-application","text":"If your Backend Capsule is a Python application, use the following code to connect to your MySQL Data Capsule: import os import mysql.connector data_capsule_url = os . getenv ( 'DATABASE_URL' ) employees_database_url = data_capsule_url + \"/employees\" cnx = mysql . connector . connect ( user = 'yourusername' , password = 'yourpassword' , host = employees_database_url , database = 'employees' ) ### Do something with the cnx variable here cnx . close ()","title":"Connecting to a MySQL Data Capsule from a Python Application"},{"location":"reference/set-up-mysql-data-capsule/#connecting-to-a-mysql-data-capsule-from-a-nodejs-application","text":"If your Backend Capsule is a Node.js application, use the following code to connect to your MySQL Data Capsule: var mysql = require ( 'mysql' ); var data_capsule_url = process . env . DATABASE_URL var employees_database_url = data_capsule_url + \"/employees\" var con = mysql . createConnection ({ host : employees_database_url , user : \"yourusername\" , password : \"yourpassword\" }); con . connect ( function ( err ) { if ( err ) throw err ; console . log ( \"Connected!\" ); // Do something with the db here });","title":"Connecting to a MySQL Data Capsule from a Node.js Application"},{"location":"tutorials/","text":"Tutorial Guides If you're looking to build cool applications that you can host on Code Capsules, you can find tutorials for: Building a Slackbot Creating a Flask API Customising Domain Creating a Telegram Bot Building a Frontend Portfolio Developing a Persistent Sleep Tracker Stripe Checkout and Email Subscription Building a Web File Store","title":"Tutorial Guides"},{"location":"tutorials/#tutorial-guides","text":"If you're looking to build cool applications that you can host on Code Capsules, you can find tutorials for: Building a Slackbot Creating a Flask API Customising Domain Creating a Telegram Bot Building a Frontend Portfolio Developing a Persistent Sleep Tracker Stripe Checkout and Email Subscription Building a Web File Store","title":"Tutorial Guides"},{"location":"tutorials/build-a-web-file-store/","text":"Building a Web File Store An online file storage drive you can access from all your devices is a very useful tool. It's the basis of services like Dropbox and Google Drive. Code Capsules's File System Data Capsule mounts as a standard file system to a Backend Capsule, providing a convenient file storage option you can use instead of a blob store on other platforms. The file systems are well supported in most programming languages and familiar to programmers. In this tutorial, we'll build a basic web interface to upload, download and delete files, secured with a simple, single-user authentication scheme. We'll use a Backend Capsule with a file store Data Capsule, Node.js as the programming language, and Express as the web framework. Overview and Requirements You'll need the following services and software set up for this tutorial Git set up and installed, and a registered GitHub account . Node.js installed. A registered Code Capsules account. An IDE or text editor to code the project in. We used Visual Studio Code in this tutorial, but you can use any tool you like. Setting Up The Project With our requirements in place, let's get started setting them for our web file store project. Creating a New Repo First, we need a place to store our code, from which Code Capsules can deploy it to a capsule. Head over to GitHub and create a new repo. We're calling it filedrop here, but you can call it whatever you like. You can choose a Node .gitignore file to get started. Clone the new GitHub repo onto your computer and navigate to that directory in terminal (or command prompt, if you're on Windows). Initializing the Base Project We'll use the Express.js application generator to create the project base. Type in the following: npx express-generator --hbs npm install Here we've created a few files and folders that we can edit. The --hbs option tells the generator to use Handlebars as the HTML template language. We're using Handlebars as it's close to plain HTML, making it easier to pick up quickly. The command npm install downloads and installs all the dependencies and packages required by the base project. Open the folder with Visual Studio Code or your chosen editor, and browse through the files to get familiar with them. The app.js file in the project root is the main entry point for the app. It's time to push this boilerplate project up to Git. Type the following into command prompt or terminal: git add . git commit -am 'added base files for project' git push origin Creating a New Backend Capsule Now we need a place to host our app. Log in to Code Capsules , and create a Team and Space for this project. Link Code Capsules to the GitHub repository created above. You can do this by clicking your username at the top right, and choosing Edit Profile . Now you can click the Github button to link to a repo. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository we created and linked to. If you're only using the repo for this project, you can leave the Repo Subpath field empty. You may need to add your repo to the team repo if you haven't already. Click the Modify Team Repos to do so. Click Next , then on the following page, click Create Capsule . Creating a New Data Capsule We'll need some data storage to store the files uploaded to the web drive. Create a new Capsule, selecting the \"Data Capsule\" type. Select \"A persistent storage mounted directly to your capsule\" as the Data Type. Choose a product size, and give the capsule a name. Click \"Create Capsule\". Linking the Capsules To use the Data Capsule with the Backend Capsule, we need to link the two. Head over to the backend capsule you created earlier, and click on the \"Configure\" tab. Scroll down to \"Bind Data Capsule\", and click \"Bind\" under the name of the data capsule you created. After binding the capsules, scroll up to the section \"Capsule Parameters\". You'll notice that an environment variable, PERSISTENT_STORAGE_DIR , is automatically added with the mount point. We'll use this environment variable in the code to access the storage drive. Writing the Web Files Code Now that we have all our systems setup, we can get onto the best part - coding! Getting the File List Open the file index.js in the routes folder of our project. This is the server code file for the default route / in the application. We'll use this route to show the file listing. To interact with the storage capsule and the files on it, we'll use the built-in fs , or file system, module included in Node.js. Add a reference to this module at the top of the file: const fs = require ( 'fs' ); Then, modify the default get route to use the fs module to get the file listing on the storage drive: router . get ( '/' , function ( req , res , next ) { fs . readdir ( process . env . PERSISTENT_STORAGE_DIR , function ( err , files ){ if ( err ) return res . sendStatus ( 500 ); files . sort (); return res . render ( 'index' , { title : \"File Drop\" , files : files }); }); }); This code uses the readdir function to get an array of all the files in the storage drive. Note that we use the environment variable that was automatically setup when we bound the capsules to specify the path to the storage drive. Environment variables are accessible through the process.env object in Node.js. The readdir function calls a callback function once it has the file list. The callback has 2 arguments: err , which will contain an error object if the folder could not be read, and files , which is a string array of all the filenames in the folder, if the call was successful. If the err object is populated, we immediately return with an HTTP code 500 using the sendStatus function. The code 500 means that the server encountered an error processing a request, so the browser can show an error page. Since the readdir function doesn't return the files in any order, we use the built-in array sort function to sort the files. By default, the sort function sorts the files in ascending alphabetical order. If you'd like a different sort order, you can supply a function to customise the behaviour here. The sorted files can now be returned to the browser. We call the res.render function, which specifies the Handlebars template to use as the return web page. The templates are stored in the views folder of the project. The function also accepts a data object as an argument. Handlebars then combines this data with the template to fill in the values on the page. Rendering the File List Our backend route gets the file list, and passes it through to the index HTML template. Let's customise that template to display the files. Open index.hbs in the views folder, and update the contents to this code: < h1 > {{title}} </ h1 > < div > < h2 > File list </ h2 > < table > < tr > < th > File Name </ th > </ tr > {{#each files}} < tr > < td > {{this}} </ td > </ tr > {{/each}} </ table > </ div > Handlebars uses the sequence {{ }} to indicate sections of the template to be populated. In the first line, {{title}} will be replaced with the title we specified in the return from the GET / route we added earlier. Then we set up a simple table, and use the Handlebars each function to iterate over the elements in the files array we passed from the Get / route. The Handlebars keyword {{this}} is used to reference the current file name on each iteration. You can save, commit and push your changes so far. Our code should deploy automatically on Code Capsules . After deploying, you can visit the public URL, and you should see something like this: This is good, but a little uninteresting without any files to view! Adding the File Upload Route Let's add functionality to upload a file, then we'll be able to view it in the list. We'll first add an HTML upload form to the index.hbs file in the views folder. Add this code under the <h1>{{title}}</h1> line: < div > < h2 > Upload a file </ h2 > < form ref = 'uploadForm' id = 'uploadForm' action = '/' method = 'post' encType = \"multipart/form-data\" > < input type = \"file\" name = \"newFile\" /> < input type = 'submit' value = 'Upload' /> </ form > </ div > This code adds in a new HTML form, which makes a POST request to the root / (our index page) on submit. We've given the form 2 inputs: a file upload field specified by the type=\"file\" attribute, and the submit button. Note the name given to the file input - we'll need to remember this when processing the upload on the server side. Now that we have a way for the user to select a file to upload and send to the server, we need to create a route to process the submitted file. In the index.js file in the routes folder, we'll add a new HTTP route. This one will be a POST route, as we are using it to upload a new file (or resource) onto the server. Add this stub for the route in the index.js file: router . post ( '/' , function ( req , res ){ }); To handle file uploads with Express, we'll use a package that takes care of all the encoding and streaming concerns of file uploads. Open up the terminal and install the express-fileupload package using npm: npm install express-fileupload To use this package, we need to add it into the middleware of our Express server. Open up the app.js file in the root folder of the project, and import the package by adding the following require statement at the top of the file: const fileUpload = require ( 'express-fileupload' ); Now insert the package into the Express middleware pipeline by adding the following line just under the var app = express(); statement: app . use ( fileUpload ()); The express-fileupload module adds a files attribute to our req object. Through the files attribute we can access any uploads as their own objects, which are named the same as the HTML form inputs . Now we can expand on the route stub. In the index.js file, complete the POST route as follows: router . post ( '/' , function ( req , res ){ if ( ! req . files || Object . keys ( req . files ). length === 0 ) { return res . status ( 400 ). send ( 'No files were uploaded.' ); } const newFile = req . files . newFile ; const uploadPath = process . env . PERSISTENT_STORAGE_DIR + '/' + newFile . name ; newFile . mv ( uploadPath , function ( err ) { if ( err ) return res . status ( 500 ). send ( err ); return res . redirect ( '/' ); }); }); First, we check whether the files object exists on the route, and if it does exist, we check whether it has sub-objects on the list (no sub-objects means no form input fields were populated). If no files objects or sub-objects exist on the route, there is no file for the code to process, so we return early with an HTTP status 400 code and a message to the user. Status code 400 means there is an input error from the user side. Otherwise, having established that a file has been uploaded, we get the file object by referencing the same name we gave to our HTML input field ( newFile ) on the files object that the express-fileupload package added to the req object. Now that we have the file object, we can construct a path to the data capsule's location to save the file. We use the environment variable for the data capsule mount point (located in the Backend Capsule's \"Capsule Parameters\"), along with the path separator / and the name of the uploaded file. You can see all the properties available on the file object at the express-fileupload npm page . All we need to do now is to save the file to the upload path. The express-fileupload package provides the method mv on the file object to save the file to a disk location. It then calls a provided callback function when done, or if an error occurs. If we get a error back, we send an HTTP code 500 back to the client, which means that there was an error on the server side. Otherwise, if all goes well, we redirect the client to the index / page, which will call the GET route added earlier to refresh the file list on the client side. This is a good point to commit the code to Git, and test the new deployment on Code Capsules. After the capsule finishes rebuilding, navigate to the site. It should look something like this: The upload control may look slightly different depending on the web browser and operating system you use. Try choosing a file and uploading it, and you should see it appear in the browser. Downloading a File We've got the functionality to upload files, and to list what files are on the server. Now let's add functionality to download files. We'll add a route with the format /filename to get the requested file. We'll make use of the download functionality built into Express to send the file back to the browser. Add this route to the index.js file. router . get ( '/:filename' , function ( req , res , next ){ const filepath = process . env . PERSISTENT_STORAGE_DIR + '/' + req . params . filename ; return res . download ( filepath ); }); This sets up a GET route, with the requested filename as a parameter. Then the function constructs a path to the file, using the environment variable for the data capsule mount point, along with the path separator / and the name of the requested file. Then we call the download method on the res (result) object with the constructed path. This sends the file to the browser. Now we need a way to call this route from the front end. Open the index.hbs file in the views folder, and modify the {{this}} template in the file list table to an HTML anchor <a> tag , with the href to the route we added above. We'll also add the download attribute to the tag so that the link will not be opened in the browser, but downloaded instead. The updated file list table should look like this now: < div > < h2 > File list </ h2 > < table > < tr > < th > File Name </ th > </ tr > {{#each files}} < tr > < td > < a href = '/{{this}}' download > {{this}} </ a > </ td > </ tr > {{/each}} </ table > </ div > Commit these changes, and wait for Code Capsules to redeploy the site. If you navigate to the site now, you should see the file you uploaded earlier as a hyperlink. Clicking on the link should download the file. Deleting a File Now that we can upload and download files, we'll probably also need to remove files. We can use the HTTP DELETE verb on a route for this. Since the data capsule appears just like a regular file system to our code, we can use the built-in Node.js fs module here again. It has a method called unlink which deletes a file from a file system. We supply it with a path to the file, and a callback function to let us know the result of the delete file request. If we get an error, we'll send an HTTP code 500 status back to the browser, to let the browser know that an error occurred. If the delete action is successful, we'll send a status code 200 , which lets the browser know that the operation was a success. Add this code to the index.js file to implement the DELETE route: router . delete ( '/:filename' , function ( req , res ){ const filepath = process . env . PERSISTENT_STORAGE_DIR + '/' + req . params . filename ; fs . unlink ( filepath , function ( err ) { if ( err ) return res . sendStatus ( 500 ); else return res . sendStatus ( 200 ); }); }); Now let's update the front end to be able to call this route. Open the index.hbs file, and add a new header column to the file table, along with a button for each file in the new column to delete it: < div > < h2 > File list </ h2 > < table > < tr > < th > File Name </ th > < th ></ th > </ tr > {{#each files}} < tr > < td > < a href = '/{{this}}' target = \"_blank\" > {{this}} </ a > </ td > < td > < button > Delete </ button > </ td > </ tr > {{/each}} </ table > </ div > Next we'll create some front-end JavaScript code for the button to call when clicked. We'll use the browser-side fetch function to call the DELETE file route. Add this script block at the bottom of the index.hbs file: < script type = \"text/javascript\" > function deleteFile ( filename ){ var confirmation = confirm ( 'Do you really want to delete the file ' + filename + '?' ); if ( confirmation === true ){ fetch ( '/' + filename , { method : 'DELETE' }) . then ( response => location . reload ()) . catch ( error => alert ( 'Error deleting the file! ' + error )); } } < /script> This adds a new function deleteFile to the front-end index page. It has one argument: the name of the file to delete. First, we make use of the built-in confirm function which exists in all browsers. This brings up a dialog box with the message Do you really want to delete the file? , just to make sure the user didn't click the delete button accidentally. If the user clicks \"Yes\", the dialog box returns a true value. Then we call our DELETE route using fetch . We need to pass in the route to call, and we also send an init object which specifies that the DELETE HTTP verb must be used to call this route. The fetch function returns a promise . This is an alternative to callbacks. If the call was successful, the code in the .then() handler is called. This reloads the page, so that the file listing is updated to show that the file is now deleted. If the call fails, the code in the catch handler is called. This uses another standard browser dialog, an alert , to let the user know that something went wrong. Now let's hook this function up to the button we added for each file. We'll use the onclick event on the buttons to call the function, along with the filename to be deleted. Update the button code like this: < button onclick = \"deleteFile('{{this}}')\" > Delete </ button > Commit these changes, and wait for Code Capsules to redeploy the site. Then navigate to the site and try out the \"Delete\" button next to the filename. Adding Authentication We've created the basic functions of a web drive, but anyone can get to the site and upload, download or delete documents. We need a way to control access. For this tutorial, we'll implement a very simple access control system that only allows access to one pre-defined user. We're going to use Passport to handle our access control. Passport is a modular package that allows for very simple authentication schemes to very elaborate ones, so you can upgrade the security of this app as you need. Our basic access control scheme is a username and password combination, entered on an HTML form that is posted to a login route. A session cookie will remember the logged-in user while they use the site, and we'll use the package express-session to manage the session. Passport's local strategy plugin will enable our username and password scheme. Let's start by installing all these packages and plugins. Type the following in the terminal: npm install passport passport-local express-session Now add references to these packages to the top section of the app.js file. A good place to add them is after the var logger = require('morgan'); line. Here's the code you'll need: var passport = require ( 'passport' ); var LocalStrategy = require ( 'passport-local' ). Strategy ; var session = require ( \"express-session\" ); The first thing to add to the app is the session middleware, then the Passport authentication middleware. Add the following after the app.use(express.static(path.join(__dirname, 'public'))); line: app . use ( session ({ secret : \"<YOUR_SECRET>\" })); app . use ( passport . initialize ()); app . use ( passport . session ()); This inserts the session middleware into the app pipeline, to read and write persistent sessions to the app cookie. Replace the <YOUR_SECRET> parameter with a string of your choosing. This secret is used to sign the session information in the cookie. Normally, this is kept very secret, as anyone who has access to the secret could construct a session cookie that looks legitimate to the server and give them access to any account on the server. You can also add an environment variable to store this secret, rather than store it in the code repo. Next, we initialize Passport into the middleware pipeline, and add in the code for Passport to use sessions to check and record authentication. When using sessions with Passport, we need to implement serialisation and deserialisation of user objects from session information, so that Passport can add the user object to the req object in the app pipeline. Add these functions to the bottom of the app.js file: passport . serializeUser ( function ( user , done ) { process . nextTick ( function (){ done ( null , user ); }); }); passport . deserializeUser ( function ( user , done ) { process . nextTick ( function (){ done ( null , user ); }); }); In our case, since we are implementing a super-simple authentication scheme with just one user, we don't need to call out to a database or other store to get user information. In fact, since there is no real user information that is of use to our app at the moment, we just return the user object that Passport sends to us straight back, as we don't really have a use for it. Even though we are doing nothing with the information, we need to register these functions with Passport, as it calls them regardless. Now we can set up the rest of the logic for Passport. Add this code just above the serialisation code: passport . use ( new LocalStrategy ( function ( username , password , done ) { if ( username === process . env . USERNAME && password === process . env . PASSWORD ){ return done ( null , { username : process . env . USERNAME }); } else { return done ( null , false , { message : \"Incorrect username or password\" }); } }) ); This plugs in and registers the local authentication strategy module into Passport. Passport's local strategy uses a simple username and password, checked on the local server, so we'll need a function to accept a username and password for validation. The function checks if entered credentials are valid, and sends back a user object if they are, using the done callback. If the credentials don't checkout, the user gets an error message. Our function checks the username and password against what is stored in our environment variables. If the credentials to be checked match the credentials in our environment variables, we authenticate the user. Head over to the \"Configure\" tab on your backend Code Capsule, and add 2 new environment variables : USERNAME and PASSWORD . Supply values of your own to set your username and password, then click the \"Update Capsule\" button to save the changes. Note: While this method of storing user credentials is appropriate for a small, single-user hobby project, it is not sufficient for production with customer credentials. Look to implementing a more robust user store, with password hashing and salting, or using a third-party authentication service such as a social network or an OAuth provider Passport offers many other authentication strategies , from OAuth 2.0 strategies allowing authentication through Facebook, Google, Twitter and other OAuth 2.0 providers, to API authentication strategies such as Bearer Tokens. Now that we have set the username and password for our app, we can add the login page routes to render the login page and send the form POST with user credentials to Passport. Add these 2 routes just above the index routes ( app.use('/', indexRouter); ) in app.js : app . get ( '/login' , function ( req , res ){ return res . render ( 'login' ) }); app . post ( '/login' , passport . authenticate ( 'local' , { successRedirect : '/' , failureRedirect : '/login' })); The first GET route adds a /login url to our app. The route handler function calls the res.render Express method to serve up the login template, which we'll add shortly. The second POST route handles a form submission from the /login route, and passes it through to Passport. We supply a parameter to tell Passport to use our local strategy to process this authentication request. We also supply the redirects: to the main file list if authentication is successful, or back to the login page if not. There's one more bit of code to include before we add the front-end login form. We need to check if a user is successfully authenticated before they can access the file list and other functionality. To do this, we'll insert a call to an authentication check function in our app middleware. Add this code just above the app.use('/', indexRouter); line, so it's called before the routes above are served: app . use ( isAuthenticated ); Now, let's implement the reference isAuthenticated middleware. Add this function to the bottom of the app.js file: function isAuthenticated ( req , res , next ) { if ( req . isAuthenticated ()) return next (); else return res . redirect ( '/login' ); } If a user is successfully authenticated, the isAuthenticated() method, which is added by Passport to the req object, will return true . In that case, we can safely let the pipeline proceed to the next middleware function (in this case, one of the protected routes). If the authentication check comes back false , we redirect back to the login page, away from our protected pages. Now we have all the back-end pieces for authentication in place, let's add the login page and form. Add a new file called login.hbs in the views folder. Place this code into the new file: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Log In\" /> </ div > </ form > Here we're adding a very simple form to make a POST request back to our /login route, with inputs for a username and password. We're done with authentication. Commit these changes, and wait for Code Capsules to redeploy the site, then navigate over and test it out. This time, the site should prompt for your username and password (which you added to the environment variables) before letting you through to the files page. Congratulations, you have completed building a personal web drive using Code Capsules and Node.js ! Next Steps This project has some decent basic functionality, but there are many things you could add to upgrade it, such as: Add styling to make it look better Add support for sub-folders Add support for multi-file upload Add logout functionality, using the Passport logout function Add better authentication, and perhaps separate user accounts for a multi-user drive","title":"Web File Store"},{"location":"tutorials/build-a-web-file-store/#building-a-web-file-store","text":"An online file storage drive you can access from all your devices is a very useful tool. It's the basis of services like Dropbox and Google Drive. Code Capsules's File System Data Capsule mounts as a standard file system to a Backend Capsule, providing a convenient file storage option you can use instead of a blob store on other platforms. The file systems are well supported in most programming languages and familiar to programmers. In this tutorial, we'll build a basic web interface to upload, download and delete files, secured with a simple, single-user authentication scheme. We'll use a Backend Capsule with a file store Data Capsule, Node.js as the programming language, and Express as the web framework.","title":"Building a Web File Store"},{"location":"tutorials/build-a-web-file-store/#overview-and-requirements","text":"You'll need the following services and software set up for this tutorial Git set up and installed, and a registered GitHub account . Node.js installed. A registered Code Capsules account. An IDE or text editor to code the project in. We used Visual Studio Code in this tutorial, but you can use any tool you like.","title":"Overview and Requirements"},{"location":"tutorials/build-a-web-file-store/#setting-up-the-project","text":"With our requirements in place, let's get started setting them for our web file store project.","title":"Setting Up The Project"},{"location":"tutorials/build-a-web-file-store/#creating-a-new-repo","text":"First, we need a place to store our code, from which Code Capsules can deploy it to a capsule. Head over to GitHub and create a new repo. We're calling it filedrop here, but you can call it whatever you like. You can choose a Node .gitignore file to get started. Clone the new GitHub repo onto your computer and navigate to that directory in terminal (or command prompt, if you're on Windows).","title":"Creating a New Repo"},{"location":"tutorials/build-a-web-file-store/#initializing-the-base-project","text":"We'll use the Express.js application generator to create the project base. Type in the following: npx express-generator --hbs npm install Here we've created a few files and folders that we can edit. The --hbs option tells the generator to use Handlebars as the HTML template language. We're using Handlebars as it's close to plain HTML, making it easier to pick up quickly. The command npm install downloads and installs all the dependencies and packages required by the base project. Open the folder with Visual Studio Code or your chosen editor, and browse through the files to get familiar with them. The app.js file in the project root is the main entry point for the app. It's time to push this boilerplate project up to Git. Type the following into command prompt or terminal: git add . git commit -am 'added base files for project' git push origin","title":"Initializing the Base Project"},{"location":"tutorials/build-a-web-file-store/#creating-a-new-backend-capsule","text":"Now we need a place to host our app. Log in to Code Capsules , and create a Team and Space for this project. Link Code Capsules to the GitHub repository created above. You can do this by clicking your username at the top right, and choosing Edit Profile . Now you can click the Github button to link to a repo. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository we created and linked to. If you're only using the repo for this project, you can leave the Repo Subpath field empty. You may need to add your repo to the team repo if you haven't already. Click the Modify Team Repos to do so. Click Next , then on the following page, click Create Capsule .","title":"Creating a New Backend Capsule"},{"location":"tutorials/build-a-web-file-store/#creating-a-new-data-capsule","text":"We'll need some data storage to store the files uploaded to the web drive. Create a new Capsule, selecting the \"Data Capsule\" type. Select \"A persistent storage mounted directly to your capsule\" as the Data Type. Choose a product size, and give the capsule a name. Click \"Create Capsule\".","title":"Creating a New Data Capsule"},{"location":"tutorials/build-a-web-file-store/#linking-the-capsules","text":"To use the Data Capsule with the Backend Capsule, we need to link the two. Head over to the backend capsule you created earlier, and click on the \"Configure\" tab. Scroll down to \"Bind Data Capsule\", and click \"Bind\" under the name of the data capsule you created. After binding the capsules, scroll up to the section \"Capsule Parameters\". You'll notice that an environment variable, PERSISTENT_STORAGE_DIR , is automatically added with the mount point. We'll use this environment variable in the code to access the storage drive.","title":"Linking the Capsules"},{"location":"tutorials/build-a-web-file-store/#writing-the-web-files-code","text":"Now that we have all our systems setup, we can get onto the best part - coding!","title":"Writing the Web Files Code"},{"location":"tutorials/build-a-web-file-store/#getting-the-file-list","text":"Open the file index.js in the routes folder of our project. This is the server code file for the default route / in the application. We'll use this route to show the file listing. To interact with the storage capsule and the files on it, we'll use the built-in fs , or file system, module included in Node.js. Add a reference to this module at the top of the file: const fs = require ( 'fs' ); Then, modify the default get route to use the fs module to get the file listing on the storage drive: router . get ( '/' , function ( req , res , next ) { fs . readdir ( process . env . PERSISTENT_STORAGE_DIR , function ( err , files ){ if ( err ) return res . sendStatus ( 500 ); files . sort (); return res . render ( 'index' , { title : \"File Drop\" , files : files }); }); }); This code uses the readdir function to get an array of all the files in the storage drive. Note that we use the environment variable that was automatically setup when we bound the capsules to specify the path to the storage drive. Environment variables are accessible through the process.env object in Node.js. The readdir function calls a callback function once it has the file list. The callback has 2 arguments: err , which will contain an error object if the folder could not be read, and files , which is a string array of all the filenames in the folder, if the call was successful. If the err object is populated, we immediately return with an HTTP code 500 using the sendStatus function. The code 500 means that the server encountered an error processing a request, so the browser can show an error page. Since the readdir function doesn't return the files in any order, we use the built-in array sort function to sort the files. By default, the sort function sorts the files in ascending alphabetical order. If you'd like a different sort order, you can supply a function to customise the behaviour here. The sorted files can now be returned to the browser. We call the res.render function, which specifies the Handlebars template to use as the return web page. The templates are stored in the views folder of the project. The function also accepts a data object as an argument. Handlebars then combines this data with the template to fill in the values on the page.","title":"Getting the File List"},{"location":"tutorials/build-a-web-file-store/#rendering-the-file-list","text":"Our backend route gets the file list, and passes it through to the index HTML template. Let's customise that template to display the files. Open index.hbs in the views folder, and update the contents to this code: < h1 > {{title}} </ h1 > < div > < h2 > File list </ h2 > < table > < tr > < th > File Name </ th > </ tr > {{#each files}} < tr > < td > {{this}} </ td > </ tr > {{/each}} </ table > </ div > Handlebars uses the sequence {{ }} to indicate sections of the template to be populated. In the first line, {{title}} will be replaced with the title we specified in the return from the GET / route we added earlier. Then we set up a simple table, and use the Handlebars each function to iterate over the elements in the files array we passed from the Get / route. The Handlebars keyword {{this}} is used to reference the current file name on each iteration. You can save, commit and push your changes so far. Our code should deploy automatically on Code Capsules . After deploying, you can visit the public URL, and you should see something like this: This is good, but a little uninteresting without any files to view!","title":"Rendering the File List"},{"location":"tutorials/build-a-web-file-store/#adding-the-file-upload-route","text":"Let's add functionality to upload a file, then we'll be able to view it in the list. We'll first add an HTML upload form to the index.hbs file in the views folder. Add this code under the <h1>{{title}}</h1> line: < div > < h2 > Upload a file </ h2 > < form ref = 'uploadForm' id = 'uploadForm' action = '/' method = 'post' encType = \"multipart/form-data\" > < input type = \"file\" name = \"newFile\" /> < input type = 'submit' value = 'Upload' /> </ form > </ div > This code adds in a new HTML form, which makes a POST request to the root / (our index page) on submit. We've given the form 2 inputs: a file upload field specified by the type=\"file\" attribute, and the submit button. Note the name given to the file input - we'll need to remember this when processing the upload on the server side. Now that we have a way for the user to select a file to upload and send to the server, we need to create a route to process the submitted file. In the index.js file in the routes folder, we'll add a new HTTP route. This one will be a POST route, as we are using it to upload a new file (or resource) onto the server. Add this stub for the route in the index.js file: router . post ( '/' , function ( req , res ){ }); To handle file uploads with Express, we'll use a package that takes care of all the encoding and streaming concerns of file uploads. Open up the terminal and install the express-fileupload package using npm: npm install express-fileupload To use this package, we need to add it into the middleware of our Express server. Open up the app.js file in the root folder of the project, and import the package by adding the following require statement at the top of the file: const fileUpload = require ( 'express-fileupload' ); Now insert the package into the Express middleware pipeline by adding the following line just under the var app = express(); statement: app . use ( fileUpload ()); The express-fileupload module adds a files attribute to our req object. Through the files attribute we can access any uploads as their own objects, which are named the same as the HTML form inputs . Now we can expand on the route stub. In the index.js file, complete the POST route as follows: router . post ( '/' , function ( req , res ){ if ( ! req . files || Object . keys ( req . files ). length === 0 ) { return res . status ( 400 ). send ( 'No files were uploaded.' ); } const newFile = req . files . newFile ; const uploadPath = process . env . PERSISTENT_STORAGE_DIR + '/' + newFile . name ; newFile . mv ( uploadPath , function ( err ) { if ( err ) return res . status ( 500 ). send ( err ); return res . redirect ( '/' ); }); }); First, we check whether the files object exists on the route, and if it does exist, we check whether it has sub-objects on the list (no sub-objects means no form input fields were populated). If no files objects or sub-objects exist on the route, there is no file for the code to process, so we return early with an HTTP status 400 code and a message to the user. Status code 400 means there is an input error from the user side. Otherwise, having established that a file has been uploaded, we get the file object by referencing the same name we gave to our HTML input field ( newFile ) on the files object that the express-fileupload package added to the req object. Now that we have the file object, we can construct a path to the data capsule's location to save the file. We use the environment variable for the data capsule mount point (located in the Backend Capsule's \"Capsule Parameters\"), along with the path separator / and the name of the uploaded file. You can see all the properties available on the file object at the express-fileupload npm page . All we need to do now is to save the file to the upload path. The express-fileupload package provides the method mv on the file object to save the file to a disk location. It then calls a provided callback function when done, or if an error occurs. If we get a error back, we send an HTTP code 500 back to the client, which means that there was an error on the server side. Otherwise, if all goes well, we redirect the client to the index / page, which will call the GET route added earlier to refresh the file list on the client side. This is a good point to commit the code to Git, and test the new deployment on Code Capsules. After the capsule finishes rebuilding, navigate to the site. It should look something like this: The upload control may look slightly different depending on the web browser and operating system you use. Try choosing a file and uploading it, and you should see it appear in the browser.","title":"Adding the File Upload Route"},{"location":"tutorials/build-a-web-file-store/#downloading-a-file","text":"We've got the functionality to upload files, and to list what files are on the server. Now let's add functionality to download files. We'll add a route with the format /filename to get the requested file. We'll make use of the download functionality built into Express to send the file back to the browser. Add this route to the index.js file. router . get ( '/:filename' , function ( req , res , next ){ const filepath = process . env . PERSISTENT_STORAGE_DIR + '/' + req . params . filename ; return res . download ( filepath ); }); This sets up a GET route, with the requested filename as a parameter. Then the function constructs a path to the file, using the environment variable for the data capsule mount point, along with the path separator / and the name of the requested file. Then we call the download method on the res (result) object with the constructed path. This sends the file to the browser. Now we need a way to call this route from the front end. Open the index.hbs file in the views folder, and modify the {{this}} template in the file list table to an HTML anchor <a> tag , with the href to the route we added above. We'll also add the download attribute to the tag so that the link will not be opened in the browser, but downloaded instead. The updated file list table should look like this now: < div > < h2 > File list </ h2 > < table > < tr > < th > File Name </ th > </ tr > {{#each files}} < tr > < td > < a href = '/{{this}}' download > {{this}} </ a > </ td > </ tr > {{/each}} </ table > </ div > Commit these changes, and wait for Code Capsules to redeploy the site. If you navigate to the site now, you should see the file you uploaded earlier as a hyperlink. Clicking on the link should download the file.","title":"Downloading a File"},{"location":"tutorials/build-a-web-file-store/#deleting-a-file","text":"Now that we can upload and download files, we'll probably also need to remove files. We can use the HTTP DELETE verb on a route for this. Since the data capsule appears just like a regular file system to our code, we can use the built-in Node.js fs module here again. It has a method called unlink which deletes a file from a file system. We supply it with a path to the file, and a callback function to let us know the result of the delete file request. If we get an error, we'll send an HTTP code 500 status back to the browser, to let the browser know that an error occurred. If the delete action is successful, we'll send a status code 200 , which lets the browser know that the operation was a success. Add this code to the index.js file to implement the DELETE route: router . delete ( '/:filename' , function ( req , res ){ const filepath = process . env . PERSISTENT_STORAGE_DIR + '/' + req . params . filename ; fs . unlink ( filepath , function ( err ) { if ( err ) return res . sendStatus ( 500 ); else return res . sendStatus ( 200 ); }); }); Now let's update the front end to be able to call this route. Open the index.hbs file, and add a new header column to the file table, along with a button for each file in the new column to delete it: < div > < h2 > File list </ h2 > < table > < tr > < th > File Name </ th > < th ></ th > </ tr > {{#each files}} < tr > < td > < a href = '/{{this}}' target = \"_blank\" > {{this}} </ a > </ td > < td > < button > Delete </ button > </ td > </ tr > {{/each}} </ table > </ div > Next we'll create some front-end JavaScript code for the button to call when clicked. We'll use the browser-side fetch function to call the DELETE file route. Add this script block at the bottom of the index.hbs file: < script type = \"text/javascript\" > function deleteFile ( filename ){ var confirmation = confirm ( 'Do you really want to delete the file ' + filename + '?' ); if ( confirmation === true ){ fetch ( '/' + filename , { method : 'DELETE' }) . then ( response => location . reload ()) . catch ( error => alert ( 'Error deleting the file! ' + error )); } } < /script> This adds a new function deleteFile to the front-end index page. It has one argument: the name of the file to delete. First, we make use of the built-in confirm function which exists in all browsers. This brings up a dialog box with the message Do you really want to delete the file? , just to make sure the user didn't click the delete button accidentally. If the user clicks \"Yes\", the dialog box returns a true value. Then we call our DELETE route using fetch . We need to pass in the route to call, and we also send an init object which specifies that the DELETE HTTP verb must be used to call this route. The fetch function returns a promise . This is an alternative to callbacks. If the call was successful, the code in the .then() handler is called. This reloads the page, so that the file listing is updated to show that the file is now deleted. If the call fails, the code in the catch handler is called. This uses another standard browser dialog, an alert , to let the user know that something went wrong. Now let's hook this function up to the button we added for each file. We'll use the onclick event on the buttons to call the function, along with the filename to be deleted. Update the button code like this: < button onclick = \"deleteFile('{{this}}')\" > Delete </ button > Commit these changes, and wait for Code Capsules to redeploy the site. Then navigate to the site and try out the \"Delete\" button next to the filename.","title":"Deleting a File"},{"location":"tutorials/build-a-web-file-store/#adding-authentication","text":"We've created the basic functions of a web drive, but anyone can get to the site and upload, download or delete documents. We need a way to control access. For this tutorial, we'll implement a very simple access control system that only allows access to one pre-defined user. We're going to use Passport to handle our access control. Passport is a modular package that allows for very simple authentication schemes to very elaborate ones, so you can upgrade the security of this app as you need. Our basic access control scheme is a username and password combination, entered on an HTML form that is posted to a login route. A session cookie will remember the logged-in user while they use the site, and we'll use the package express-session to manage the session. Passport's local strategy plugin will enable our username and password scheme. Let's start by installing all these packages and plugins. Type the following in the terminal: npm install passport passport-local express-session Now add references to these packages to the top section of the app.js file. A good place to add them is after the var logger = require('morgan'); line. Here's the code you'll need: var passport = require ( 'passport' ); var LocalStrategy = require ( 'passport-local' ). Strategy ; var session = require ( \"express-session\" ); The first thing to add to the app is the session middleware, then the Passport authentication middleware. Add the following after the app.use(express.static(path.join(__dirname, 'public'))); line: app . use ( session ({ secret : \"<YOUR_SECRET>\" })); app . use ( passport . initialize ()); app . use ( passport . session ()); This inserts the session middleware into the app pipeline, to read and write persistent sessions to the app cookie. Replace the <YOUR_SECRET> parameter with a string of your choosing. This secret is used to sign the session information in the cookie. Normally, this is kept very secret, as anyone who has access to the secret could construct a session cookie that looks legitimate to the server and give them access to any account on the server. You can also add an environment variable to store this secret, rather than store it in the code repo. Next, we initialize Passport into the middleware pipeline, and add in the code for Passport to use sessions to check and record authentication. When using sessions with Passport, we need to implement serialisation and deserialisation of user objects from session information, so that Passport can add the user object to the req object in the app pipeline. Add these functions to the bottom of the app.js file: passport . serializeUser ( function ( user , done ) { process . nextTick ( function (){ done ( null , user ); }); }); passport . deserializeUser ( function ( user , done ) { process . nextTick ( function (){ done ( null , user ); }); }); In our case, since we are implementing a super-simple authentication scheme with just one user, we don't need to call out to a database or other store to get user information. In fact, since there is no real user information that is of use to our app at the moment, we just return the user object that Passport sends to us straight back, as we don't really have a use for it. Even though we are doing nothing with the information, we need to register these functions with Passport, as it calls them regardless. Now we can set up the rest of the logic for Passport. Add this code just above the serialisation code: passport . use ( new LocalStrategy ( function ( username , password , done ) { if ( username === process . env . USERNAME && password === process . env . PASSWORD ){ return done ( null , { username : process . env . USERNAME }); } else { return done ( null , false , { message : \"Incorrect username or password\" }); } }) ); This plugs in and registers the local authentication strategy module into Passport. Passport's local strategy uses a simple username and password, checked on the local server, so we'll need a function to accept a username and password for validation. The function checks if entered credentials are valid, and sends back a user object if they are, using the done callback. If the credentials don't checkout, the user gets an error message. Our function checks the username and password against what is stored in our environment variables. If the credentials to be checked match the credentials in our environment variables, we authenticate the user. Head over to the \"Configure\" tab on your backend Code Capsule, and add 2 new environment variables : USERNAME and PASSWORD . Supply values of your own to set your username and password, then click the \"Update Capsule\" button to save the changes. Note: While this method of storing user credentials is appropriate for a small, single-user hobby project, it is not sufficient for production with customer credentials. Look to implementing a more robust user store, with password hashing and salting, or using a third-party authentication service such as a social network or an OAuth provider Passport offers many other authentication strategies , from OAuth 2.0 strategies allowing authentication through Facebook, Google, Twitter and other OAuth 2.0 providers, to API authentication strategies such as Bearer Tokens. Now that we have set the username and password for our app, we can add the login page routes to render the login page and send the form POST with user credentials to Passport. Add these 2 routes just above the index routes ( app.use('/', indexRouter); ) in app.js : app . get ( '/login' , function ( req , res ){ return res . render ( 'login' ) }); app . post ( '/login' , passport . authenticate ( 'local' , { successRedirect : '/' , failureRedirect : '/login' })); The first GET route adds a /login url to our app. The route handler function calls the res.render Express method to serve up the login template, which we'll add shortly. The second POST route handles a form submission from the /login route, and passes it through to Passport. We supply a parameter to tell Passport to use our local strategy to process this authentication request. We also supply the redirects: to the main file list if authentication is successful, or back to the login page if not. There's one more bit of code to include before we add the front-end login form. We need to check if a user is successfully authenticated before they can access the file list and other functionality. To do this, we'll insert a call to an authentication check function in our app middleware. Add this code just above the app.use('/', indexRouter); line, so it's called before the routes above are served: app . use ( isAuthenticated ); Now, let's implement the reference isAuthenticated middleware. Add this function to the bottom of the app.js file: function isAuthenticated ( req , res , next ) { if ( req . isAuthenticated ()) return next (); else return res . redirect ( '/login' ); } If a user is successfully authenticated, the isAuthenticated() method, which is added by Passport to the req object, will return true . In that case, we can safely let the pipeline proceed to the next middleware function (in this case, one of the protected routes). If the authentication check comes back false , we redirect back to the login page, away from our protected pages. Now we have all the back-end pieces for authentication in place, let's add the login page and form. Add a new file called login.hbs in the views folder. Place this code into the new file: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Log In\" /> </ div > </ form > Here we're adding a very simple form to make a POST request back to our /login route, with inputs for a username and password. We're done with authentication. Commit these changes, and wait for Code Capsules to redeploy the site, then navigate over and test it out. This time, the site should prompt for your username and password (which you added to the environment variables) before letting you through to the files page. Congratulations, you have completed building a personal web drive using Code Capsules and Node.js !","title":"Adding Authentication"},{"location":"tutorials/build-a-web-file-store/#next-steps","text":"This project has some decent basic functionality, but there are many things you could add to upgrade it, such as: Add styling to make it look better Add support for sub-folders Add support for multi-file upload Add logout functionality, using the Passport logout function Add better authentication, and perhaps separate user accounts for a multi-user drive","title":"Next Steps"},{"location":"tutorials/build-slackbot-with-node/","text":"Build a Slackbot with Node.js to Monitor your Applications Slack is a really useful communication tool when working in teams. Many developers find themselves using it almost constantly when working on projects. One of the stand out features of Slack is the rich API it exposes, to allow developers to integrate with it. In this tutorial, we'll use the Slack API to give our apps a voice. We'll be able to talk to our apps running on Code Capsules, to ask their status and see if they are up and running. They will also be able to alert us when they boot up, so we know if they have been successfully deployed or restarted. Overview and Requirements As we're building a Slackbot, you'll need to sign up for an account on Slack , if you haven't already got one. Ideally, for this tutorial you should use a Slack workspace that you can safely send many test messages to while we are creating this bot, without disturbing people. We'll also need the following: Git set up and installed, and a registered GitHub account. Node.js installed. A registered Code Capsules account. An IDE or text editor to create the project in. This tutorial was made using Visual Studio Code , but feel free to use any tool you like. Setting Up the Project With our requirements in place, we can get started on setting them up to work as needed for our Slackbot project. Create a new repo on GitHub We need a place to store our code from which Code Capsules can deploy to a capsule. A repository on GitHub is just what we need. Head over to GitHub, and create a new repo. We're calling it slackbot here, but you can call it whatever you like. Note: You can also add this code to an existing backend project if you would like to monitor it; perhaps something you built in an earlier tutorial. Initialise the base project Now we can get some base code set up. Let's start by cloning the new GitHub repo onto our local computer. Now, go into the directory of the repo you've just cloned. We can initialise a new Node.js project by typing the following at the terminal (or command prompt, if you're on Windows): npm init We can just press enter for each of the questions it asks; the defaults are good to start with. Install our packages Now that we have our project initialised, we can add the packages we need to create our bot. These are: Express : This acts as our web server and HTTP request router. We'll use this to route requests from Slack to the correct logic. body-parser : This interprets and parses payload data from HTTP requests. We'll need this to parse the URL-encoded data Slack sends to us with a request. superagent : This package allows us to make outgoing HTTP requests. We'll need this to send a message to Slack. Let's type in the following at the terminal to install the packages: npm install express body-parser superagent Now let's create an index.js file, which will be the main file for our app. A simple way to do this is to open up your project folder in an editor, like Visual Studio Code . Now you can create a new index.js file. Save this blank file. Great, it's time to push this boilerplate project up to Git. We can do it from the terminal with the following: git add . git commit -am 'added base files for project' git push origin Create a new Code Capsule We'll need a place to host our app. Log in to Code Capsules , and create a Team and Space as necessary. Link Code Capsules to the GitHub repository you created earlier. You can do this by clicking your username at the top right, and choosing \"Edit Profile\". Now click the \"GitHub\" button to link to a repo. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository you created above. If you are only using the repo for this project, you can leave the \"Repo Subpath\" field empty. You may need to add your repo to the team repo if you haven't already. Click the \"Modify Team Repos\" to do so. Click \"Next\", then on the following page, click \"Create Capsule\". Register an app on Slack After you've created a workspace on Slack, or logged into an existing one, head over to https://api.slack.com and click on \"Create a custom app\". On the dialog that comes up, we can give our app a name, and choose which workspace we want to add it to. You can choose any name you wish \u2013 we've used Serverbot here. Now we can click \"Create App\". Great! We've created our app. Now we can configure it. For this tutorial, we would like the following two functions: Our Code Capsules app should automatically send us a notification whenever it starts up. This allows us to easily know when a new deployment is successful. It can also alert us to any potential crashes and restarts. We want to query our Code Capsules app from Slack at any time to see how it's doing. Our first requirement can be configured on the Slack side by clicking \"OAuth & Permissions\" on the left panel. Scroll down to the Scopes section, and click \"Add an OAuth Scope\" under the Bot Token Scopes section, and choose \"Chat:Write\" from the options list. This now allows our bot to initiate and post messages to us when it starts up. Our second requirement can be configured by setting up a slash command . Click on the \"Slash Commands\" menu item on the left, under Features . Then click \"Create a new Command\". We'll give the command the name /stats . For the Request URL , copy the Domain name from your Code Capsules Overview page. Paste your domain into the Request URL box on Slack, and add /slack/command/stats to the end of it. We can fill in a description as well, something like 'Returns key stats from the app'. Great, now we can click \"Save\" at the bottom of the page to finish setting up our slash command. Writing the Slackbot Code Now that we have all our systems set up, we can get onto the coding part. Adding the base code Let's add the boilerplate code to startup a new Express server. Open up the index.js file and add the following: const express = require ( 'express' ); const app = express (); let port = process . env . PORT || 3000 ; app . listen ( port , ()=>{ console . log ( `App listening on port ${ port } ` ); }); Sending a startup message to Slack Ok, cool, we've got the base code to create an Express app, and start it up to begin listening for requests. Now we can add some code to send a message to Slack when it boots up, not just locally to the console. If we look at the docs on Slack , we see that we can POST to the endpoint https://slack.com/api/chat.postMessage to send a message. In their example, they specify that we need: 1. An access token. 2. The channel ID of the channel to post the message to. 3. The message we want to post as the requirements. To get the access token, head over to your app dashboard on Slack, and click on the \"OAuth & Permissions\" menu item on the left-hand side. Then click the \"Install to Workspace\" button, and then the \"Allow\" button. After this, you should see a newly generated \"Bot User OAuth Token\". Copy this token \u2013 this is our access token. We could just put this token in our code. However, this is not really considered best practice for sensitive secrets and credentials. Rather, let's add this secret as an Environment Variable , and access it from the Node.js process object, on the .env property . To add the access token to the environment in Code Capsules, head over to the capsule we created earlier, and click on the \"Config\" tab. Now we can fill in our environment variable for the access token. Add a new environment variable with name SLACK_BOT_TOKEN and set the value to the token copied from Slack. Now that we've added our access token, we need to find the ID of the channel we want to post to. Find a channel on your Slack workspace that you want to send to, or create a new channel. Now we can get the channel ID by right-clicking on the channel name to bring up a context menu. Now, we can choose \"Copy Link\" from that menu: If we paste that link, we get something like https://<workspace-name>.slack.com/archives/C01SZ6Z3TCY . The last part of that URL is the channel ID; in this example case, C01SZ6Z3TCY . Let's add this to our environment variables as well, as it keeps all the configurations in one place. Head back over to your Capsule, and add in an environment variable with the name SLACK_CHANNEL_ID and set the value to the channel ID we extracted above. Click the \"Update & Start Build\" button to save the changes to the environment variables. We also need to invite our bot to the chosen channel, so that it will be able to post there. Go to the channel, and @ mention the name you gave the bot to add it. Click \"Invite Them\" when Slack prompts you. Now let's add the code to call Slack on startup, and write a message to our channel. We can modify our boilerplate code above to make the HTTP POST to the endpoint https://slack.com/api/chat.postMessage. We'll use Superagent to make the call. const express = require ( 'express' ); const superagent = require ( 'superagent' ); const app = express (); let port = process . env . PORT || 3000 ; app . listen ( port , ()=>{ console . log ( `App listening on port ${ port } ` ); sendStartupMessageToSlack (); }); function sendStartupMessageToSlack (){ superagent . post ( 'https://slack.com/api/chat.postMessage' ) . send ({ channel : process . env . SLACK_CHANNEL_ID , text : \"I'm alive and running\" }) . set ( 'accept' , 'json' ) . set ( 'Authorization' , 'Bearer ' + process . env . SLACK_BOT_TOKEN ) . end (( err , result ) => { }); } We've added in a function sendStartupMessageToSlack which makes the call out to Slack. Notice that we send the auth token in a header, using .set('Authorization', 'Bearer '+ process.env.SLACK_BOT_TOKEN) . The Authorization header is a standard HTTP header. The channel and the message are sent in the body. Feel free to modify the startup message from I'm alive and running to whatever you'd like. Deploying to Code Capsules This seems like a great time to test out our app on Code Capsules. But before we do that, there is one thing we have to do to make it work. We need to tell Code Capsules how to run our app. By default, Code Capsules will call npm start after deploying the code. Therefore, we just need to add a start script to our package.json file in order for our code to be run on Code Capsules. Open the package.json file. Under the scripts section, add the line \"start\": \"node index.js\" . The package.json file should look like this now: { \"name\" : \"slackbot\" , \"version\" : \"1.0.0\" , \"description\" : \"\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"start\" : \"node index.js\" }, \"author\" : \"\" , \"license\" : \"ISC\" , \"dependencies\" : { \"body-parser\" : \"^1.19.0\" , \"express\" : \"^4.17.1\" , \"superagent\" : \"^6.1.0\" } } Ok, let's save all the files we've created, add and commit, and then push to our repo. When Code Capsules sees that there is a new commit, it will automatically deploy our code. git add . git commit -am 'added code to call Slack on startup' git push origin If all goes well, in a few minutes you should get a message on your Slack channel from your code! Adding a slash command Now that our app can send us messages, can we send messages back to it? Let's implement the slash command, which will allow us to ask our app for some of its important stats and info. This time, Slack will send an HTTP POST to our app. If we take a look at the Slack docs again , we notice that Slack will send the slash command instruction to the URL we specified in the command set up earlier. We can also see that the POST payload is in the format application/x-www-form-urlencoded . We can set up a body-parser to interpret this data. Let's extend our code with the snippet below to implement the slash command receiver as specified in the Slack docs. First add a require statement for body-parser at the top. const bodyParser = require ( \"body-parser\" ); Then add the code below: app . use ( bodyParser . urlencoded ()); app . post ( '/slack/command/stats' , [ function ( req , res ){ const slackReqObj = req . body ; const packageJson = require ( './package.json' ); const current_time = new Date (); const stats = { name : packageJson . name , version : packageJson . version , environment : process . env . NODE_ENV , platform : process . platform , architecture : process . arch , node_version : process . version , pid : process . pid , current_server_time : current_time . toString (), uptime : process . uptime (), memory_usage : process . memoryUsage () }; const response = { response_type : 'in_channel' , channel : slackReqObj . channel_id , text : JSON . stringify ( stats , null , '\\t' ) }; return res . json ( response ); }]); This code listens for incoming POST calls on the line app.post('/slack/command/stats', [function(req,res){ . If we receive one, we build up a return object, consisting of various interesting stats and info. This includes the current time on the server (in case it is in a different time zone to us), the name and version of our app as set in the package.json file, and various environment and process info. Then it replies to the request in the format specified by Slack in their docs. We use the line text: JSON.stringify(stats, null, '\\t') to turn our info and stats object into a nicely formatted text string, in the style of a JSON object. Then, in the line return res.json(response); , we return all the info back to Slack to display as the response to a matching slash command. Great, now we can commit and push this code. git commit -am 'added handler for slash command' git push origin After the code has finished deploying on Code Capsules (it should send a startup message again when it's ready), we can test the slash command. Type /stats in the channel we chose earlier. After a second or two, the app should respond with its current vital stats and information. Adding verification We can ask our app via Slack (which we use constantly!) how it's doing; pretty cool, huh? There is a problem though. If we call our slash command endpoint from anywhere else, for instance if we just call it using Postman , it also returns all the information and stats! This would not be good for a production system, as sensitive information will be easily found by attackers. So how can we ensure that the request comes from our Slack workspace? Luckily, Slack has thought about this, and sends a message signature with its requests . From the guide in Slack's docs , we can put together some code to check that the request is legitimately from Slack. The main parts of the check, copied from the docs, looks like this: Retrieve the X-Slack-Request-Timestamp header on the HTTP request, and the body of the request. Concatenate the version number, the timestamp, and the body of the request to form a basestring. Use a colon as the delimiter between the three elements. For example, v0:123456789:command=/weather&text=94070. The version number right now is always v0. With the help of HMAC SHA256 implemented in your favorite programming language, hash the above basestring, using the Slack Signing Secret as the key. Compare this computed signature to the X-Slack-Signature header on the request. We can also check the timestamp to ensure that it is not a replay attack of a message from long ago. Ok, let's implement this in our project. First, we somehow need to access the raw body of the request, before it has been parsed by body-parser . This is to ensure that the signing hash we calculate is using the same data that Slack did. After parsing, there could be extra characters and formatting etc. Luckily, the body parser package has a verify option , which passes a binary buffer of the raw body request to a user defined function. Let's make a function that conforms to the specs given by body-parser . Add this code to your index.js file: var rawBodySaver = function ( req , res , buf , encoding ) { if ( buf && buf . length ) { req . rawBody = buf . toString ( encoding || 'utf8' ); } } In this function, we grab the bit stream buffer buf , and check that it is not null and that it is not empty (by checking that it has a length). Then we tack it onto the request req as a new property rawBody . We also convert the buffer to a string, using the encoding supplied, or fall back to utf8 as a default. Now that the rawBody is added to the request, it will be available for use by subsequent middleware. We can add it to the body parser by modifying the code where we add the body parser to the app. app . use ( bodyParser . urlencoded ({ verify : rawBodySaver })); In the code above, we added options to our body parser initialisation. We set the verify option to the method we added above. Now, let's make a new middleware function to calculate the signature and compare it. We'll be able to call this middleware before our current code for responding to our Slack slash command. Making it a middleware function will also allow us to easily re-use it on other routes, if we want to add more slash commands, or other commands from Slack in the future. We'll make a new file to hold this code. We'll call it signing.js . In the new file, let's add this code: const crypto = require ( 'crypto' ); function checkSlackMessageSignature ( req , res , next ){ const timestamp = req . headers [ 'x-slack-request-timestamp' ]; const fiveMinutesAgo = Math . floor ( Date . now () / 1000 ) - ( 60 * 5 ); if ( timestamp < fiveMinutesAgo ) { return res . sendFail ( 401 , \"mismatched timestamp\" ); } const signing_secret = process . env . SLACK_SIGNING_SECRET ; const slack_signature = req . headers [ 'x-slack-signature' ]; const [ version , slack_hash ] = slack_signature . split ( '=' ); const sig_basestring = version + ':' + timestamp + ':' + req . rawBody ; const hmac = crypto . createHmac ( 'sha256' , signing_secret ); hmac . update ( sig_basestring ); const our_hash = hmac . digest ( 'hex' ); if ( crypto . timingSafeEqual ( Buffer . from ( slack_hash ), Buffer . from ( our_hash ))) { return next (); } else { return res . send ( 401 , \"Invalid request signature\" ); } } module . exports = checkSlackMessageSignature ; Let's take a look at this code. Firstly, we import the crypto (cryptography) library . We don't need to install this as a package, as it is built into Node.js. This library will allow us to perform the hash of the basestring to compare with the signature. Next, we create a function, with the standard Express middleware parameters : - req , representing the request data. - res , representing an output object that we return results to the user via. - next , representing a function to call if we want to hand control to the next middleware function in the chain. It can also be used to pass an error object back up if something goes wrong processing the request. Then, on the first few lines of the function, we get the timestamp Slack sends from the request headers, and check that it is within the last few minutes. Note the name of the header is all in lowercase, even though Slack specifies that the header is capitalised. This is because Express converts all header keys to lowercase when serving a request. After that, we retrieve the Slack Signing Secret from our environment variables. Let's get our Signing Secret from Slack and add it to the Code Capsules environment now. Head over to your Slack app dashboard, and click on \"Basic Information\" in the left-hand sidebar. Then scroll down to App Credentials , and look for the Signing Secret . Click \"Show\", and copy the secret. Now head over to your Capsule on Code Capsules, and click on the Config tab. Add a new environment variable with Name SLACK_SIGNING_SECRET and paste in the value of the Signing Secret we copied above. Click \"Update & Start Build\" to save the changes. Ok, back to the function. After we retrieve the signing secret from the environment variables, we read out the hash calculated and sent by Slack from the headers using const slack_signature = req.headers['x-slack-signature'] . This will be a string that looks something like v0=xxxxxxxxxxxxxxxxxxxxxxx , where the xxxx represents the actual hash value. We need to split the version identifier v0 from the beginning of the string though, as this is not part of the hash value. We do this in the next line, const [version, slack_hash] = slack_signature.split('=') . Now we have both the version, and the hash string in variables that we can access. After this, we construct our basestring, made from the version we extracted above, the timestamp of the request, and the rawBody (which we extracted in our body parser verify function earlier). The next two lines are where we actually calculate the hash. First, we set up the crypto module with our crypto algorithm type SHA256 , and with our unique Signing Secret. This allows us to then create an HMAC \u2013 or Hash Based Message Authentication code , which is the fancy name for the message signature. We then use the update method on our newly created HMAC to load in our basestring that we constructed above. Now that the crypto HMAC is primed with all the info it needs, we can call the digest function to actually calculate the hash. We pass in as a parameter hex to indicate that we want the result back in hexadecimal format , as this is the same format that Slack sends their calculated hash value in. Great, so now we have Slack's signature hash, and our hash. We need to check that they are the same, which will prove that the message was legitimately sent by Slack. We could just use a normal string compare, i.e. if (slack_hash === our_hash) , but there is a slight security issue with this, known as a timing attack . This type of attack is based on the knowledge that a normal string compare function takes a different amount of time to compare two strings, depending on how close the strings are to each other. An attacker can take advantage of this timing difference to repeatedly send messages and, based on the time for our server to respond, can guess at how close their hash is to what we are expecting. With much patience and many thousands of messages, an attacker could eventually guess our Signing Secret, compromising all our checks. Luckily, there is a simple way to protect from this, and it's built right into the crypto library. This is where we call crypto.timingSafeEqual . This compare always returns in the same amount of time, regardless of how close the hashes are to each other. Therefore, we don't give any extra information away to would-be attackers. Now, if the hashes are equal, from our timingSafeEqual test, we just call return next() which exits our function and passes control to the next middleware function (which will be our slash command handler). If the hashes are not equal, then we know this request is not genuinely from Slack, so we can end early and send a 401 , which is a standard HTTP code for Unauthorized . Basically, we boot the imposter out. Now, the last line in this file is module.exports = checkSlackMessageSignature . This allows our middleware function to be visible to other modules that import this file. Ok, now that we've got this middleware created, let's link it to our slash command handler. Head on back to the index.js file, and import the middleware function by adding this line near the top of the file: const checkSlackMessageSignature = require ( './signing' ); Now, we can navigate to our slack command handler, which started like this: app.post('/slack/command/stats' . Modify that to include a call to the message signature check before the actual handler, like this: app . post ( '/slack/command/stats' , [ checkSlackMessageSignature , function ( req , res ){ Fantastic, now our app is secure. You can commit all the changes, and push it up to Git, which will kick off our final deploy to Code Capsules: git add . git commit -am 'added message signature checking' git push origin Once the code is up and running on Code Capsules, test it out to see that it still responds to the Slack slash command. Then you can try again from Postman or other similar apps, and see that it will not send any info without a valid signature (you can use v0=a2114d57b48eac39b9ad189dd8316235a7b4a8d21a10bd27519666489c69b503 as an example x-slack-signature parameter): Things to Try Next What else can we do? It's almost endless! Add this code to an existing app you have built to get easy info straight from Slack! Add in more slash commands for more info \u2013 for example, you could get current user count on your app, number of database records etc. Basically, any information you could need for dev ops . Look at some of the other functionality Slack offers for integration; for example, using modals , or listening in for keywords in messages .","title":"Slackbot with Node.js"},{"location":"tutorials/build-slackbot-with-node/#build-a-slackbot-with-nodejs-to-monitor-your-applications","text":"Slack is a really useful communication tool when working in teams. Many developers find themselves using it almost constantly when working on projects. One of the stand out features of Slack is the rich API it exposes, to allow developers to integrate with it. In this tutorial, we'll use the Slack API to give our apps a voice. We'll be able to talk to our apps running on Code Capsules, to ask their status and see if they are up and running. They will also be able to alert us when they boot up, so we know if they have been successfully deployed or restarted.","title":"Build a Slackbot with Node.js to Monitor your Applications"},{"location":"tutorials/build-slackbot-with-node/#overview-and-requirements","text":"As we're building a Slackbot, you'll need to sign up for an account on Slack , if you haven't already got one. Ideally, for this tutorial you should use a Slack workspace that you can safely send many test messages to while we are creating this bot, without disturbing people. We'll also need the following: Git set up and installed, and a registered GitHub account. Node.js installed. A registered Code Capsules account. An IDE or text editor to create the project in. This tutorial was made using Visual Studio Code , but feel free to use any tool you like.","title":"Overview and Requirements"},{"location":"tutorials/build-slackbot-with-node/#setting-up-the-project","text":"With our requirements in place, we can get started on setting them up to work as needed for our Slackbot project.","title":"Setting Up the Project"},{"location":"tutorials/build-slackbot-with-node/#create-a-new-repo-on-github","text":"We need a place to store our code from which Code Capsules can deploy to a capsule. A repository on GitHub is just what we need. Head over to GitHub, and create a new repo. We're calling it slackbot here, but you can call it whatever you like. Note: You can also add this code to an existing backend project if you would like to monitor it; perhaps something you built in an earlier tutorial.","title":"Create a new repo on GitHub"},{"location":"tutorials/build-slackbot-with-node/#initialise-the-base-project","text":"Now we can get some base code set up. Let's start by cloning the new GitHub repo onto our local computer. Now, go into the directory of the repo you've just cloned. We can initialise a new Node.js project by typing the following at the terminal (or command prompt, if you're on Windows): npm init We can just press enter for each of the questions it asks; the defaults are good to start with.","title":"Initialise the base project"},{"location":"tutorials/build-slackbot-with-node/#install-our-packages","text":"Now that we have our project initialised, we can add the packages we need to create our bot. These are: Express : This acts as our web server and HTTP request router. We'll use this to route requests from Slack to the correct logic. body-parser : This interprets and parses payload data from HTTP requests. We'll need this to parse the URL-encoded data Slack sends to us with a request. superagent : This package allows us to make outgoing HTTP requests. We'll need this to send a message to Slack. Let's type in the following at the terminal to install the packages: npm install express body-parser superagent Now let's create an index.js file, which will be the main file for our app. A simple way to do this is to open up your project folder in an editor, like Visual Studio Code . Now you can create a new index.js file. Save this blank file. Great, it's time to push this boilerplate project up to Git. We can do it from the terminal with the following: git add . git commit -am 'added base files for project' git push origin","title":"Install our packages"},{"location":"tutorials/build-slackbot-with-node/#create-a-new-code-capsule","text":"We'll need a place to host our app. Log in to Code Capsules , and create a Team and Space as necessary. Link Code Capsules to the GitHub repository you created earlier. You can do this by clicking your username at the top right, and choosing \"Edit Profile\". Now click the \"GitHub\" button to link to a repo. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository you created above. If you are only using the repo for this project, you can leave the \"Repo Subpath\" field empty. You may need to add your repo to the team repo if you haven't already. Click the \"Modify Team Repos\" to do so. Click \"Next\", then on the following page, click \"Create Capsule\".","title":"Create a new Code Capsule"},{"location":"tutorials/build-slackbot-with-node/#register-an-app-on-slack","text":"After you've created a workspace on Slack, or logged into an existing one, head over to https://api.slack.com and click on \"Create a custom app\". On the dialog that comes up, we can give our app a name, and choose which workspace we want to add it to. You can choose any name you wish \u2013 we've used Serverbot here. Now we can click \"Create App\". Great! We've created our app. Now we can configure it. For this tutorial, we would like the following two functions: Our Code Capsules app should automatically send us a notification whenever it starts up. This allows us to easily know when a new deployment is successful. It can also alert us to any potential crashes and restarts. We want to query our Code Capsules app from Slack at any time to see how it's doing. Our first requirement can be configured on the Slack side by clicking \"OAuth & Permissions\" on the left panel. Scroll down to the Scopes section, and click \"Add an OAuth Scope\" under the Bot Token Scopes section, and choose \"Chat:Write\" from the options list. This now allows our bot to initiate and post messages to us when it starts up. Our second requirement can be configured by setting up a slash command . Click on the \"Slash Commands\" menu item on the left, under Features . Then click \"Create a new Command\". We'll give the command the name /stats . For the Request URL , copy the Domain name from your Code Capsules Overview page. Paste your domain into the Request URL box on Slack, and add /slack/command/stats to the end of it. We can fill in a description as well, something like 'Returns key stats from the app'. Great, now we can click \"Save\" at the bottom of the page to finish setting up our slash command.","title":"Register an app on Slack"},{"location":"tutorials/build-slackbot-with-node/#writing-the-slackbot-code","text":"Now that we have all our systems set up, we can get onto the coding part.","title":"Writing the Slackbot Code"},{"location":"tutorials/build-slackbot-with-node/#adding-the-base-code","text":"Let's add the boilerplate code to startup a new Express server. Open up the index.js file and add the following: const express = require ( 'express' ); const app = express (); let port = process . env . PORT || 3000 ; app . listen ( port , ()=>{ console . log ( `App listening on port ${ port } ` ); });","title":"Adding the base code"},{"location":"tutorials/build-slackbot-with-node/#sending-a-startup-message-to-slack","text":"Ok, cool, we've got the base code to create an Express app, and start it up to begin listening for requests. Now we can add some code to send a message to Slack when it boots up, not just locally to the console. If we look at the docs on Slack , we see that we can POST to the endpoint https://slack.com/api/chat.postMessage to send a message. In their example, they specify that we need: 1. An access token. 2. The channel ID of the channel to post the message to. 3. The message we want to post as the requirements. To get the access token, head over to your app dashboard on Slack, and click on the \"OAuth & Permissions\" menu item on the left-hand side. Then click the \"Install to Workspace\" button, and then the \"Allow\" button. After this, you should see a newly generated \"Bot User OAuth Token\". Copy this token \u2013 this is our access token. We could just put this token in our code. However, this is not really considered best practice for sensitive secrets and credentials. Rather, let's add this secret as an Environment Variable , and access it from the Node.js process object, on the .env property . To add the access token to the environment in Code Capsules, head over to the capsule we created earlier, and click on the \"Config\" tab. Now we can fill in our environment variable for the access token. Add a new environment variable with name SLACK_BOT_TOKEN and set the value to the token copied from Slack. Now that we've added our access token, we need to find the ID of the channel we want to post to. Find a channel on your Slack workspace that you want to send to, or create a new channel. Now we can get the channel ID by right-clicking on the channel name to bring up a context menu. Now, we can choose \"Copy Link\" from that menu: If we paste that link, we get something like https://<workspace-name>.slack.com/archives/C01SZ6Z3TCY . The last part of that URL is the channel ID; in this example case, C01SZ6Z3TCY . Let's add this to our environment variables as well, as it keeps all the configurations in one place. Head back over to your Capsule, and add in an environment variable with the name SLACK_CHANNEL_ID and set the value to the channel ID we extracted above. Click the \"Update & Start Build\" button to save the changes to the environment variables. We also need to invite our bot to the chosen channel, so that it will be able to post there. Go to the channel, and @ mention the name you gave the bot to add it. Click \"Invite Them\" when Slack prompts you. Now let's add the code to call Slack on startup, and write a message to our channel. We can modify our boilerplate code above to make the HTTP POST to the endpoint https://slack.com/api/chat.postMessage. We'll use Superagent to make the call. const express = require ( 'express' ); const superagent = require ( 'superagent' ); const app = express (); let port = process . env . PORT || 3000 ; app . listen ( port , ()=>{ console . log ( `App listening on port ${ port } ` ); sendStartupMessageToSlack (); }); function sendStartupMessageToSlack (){ superagent . post ( 'https://slack.com/api/chat.postMessage' ) . send ({ channel : process . env . SLACK_CHANNEL_ID , text : \"I'm alive and running\" }) . set ( 'accept' , 'json' ) . set ( 'Authorization' , 'Bearer ' + process . env . SLACK_BOT_TOKEN ) . end (( err , result ) => { }); } We've added in a function sendStartupMessageToSlack which makes the call out to Slack. Notice that we send the auth token in a header, using .set('Authorization', 'Bearer '+ process.env.SLACK_BOT_TOKEN) . The Authorization header is a standard HTTP header. The channel and the message are sent in the body. Feel free to modify the startup message from I'm alive and running to whatever you'd like.","title":"Sending a startup message to Slack"},{"location":"tutorials/build-slackbot-with-node/#deploying-to-code-capsules","text":"This seems like a great time to test out our app on Code Capsules. But before we do that, there is one thing we have to do to make it work. We need to tell Code Capsules how to run our app. By default, Code Capsules will call npm start after deploying the code. Therefore, we just need to add a start script to our package.json file in order for our code to be run on Code Capsules. Open the package.json file. Under the scripts section, add the line \"start\": \"node index.js\" . The package.json file should look like this now: { \"name\" : \"slackbot\" , \"version\" : \"1.0.0\" , \"description\" : \"\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"start\" : \"node index.js\" }, \"author\" : \"\" , \"license\" : \"ISC\" , \"dependencies\" : { \"body-parser\" : \"^1.19.0\" , \"express\" : \"^4.17.1\" , \"superagent\" : \"^6.1.0\" } } Ok, let's save all the files we've created, add and commit, and then push to our repo. When Code Capsules sees that there is a new commit, it will automatically deploy our code. git add . git commit -am 'added code to call Slack on startup' git push origin If all goes well, in a few minutes you should get a message on your Slack channel from your code!","title":"Deploying to Code Capsules"},{"location":"tutorials/build-slackbot-with-node/#adding-a-slash-command","text":"Now that our app can send us messages, can we send messages back to it? Let's implement the slash command, which will allow us to ask our app for some of its important stats and info. This time, Slack will send an HTTP POST to our app. If we take a look at the Slack docs again , we notice that Slack will send the slash command instruction to the URL we specified in the command set up earlier. We can also see that the POST payload is in the format application/x-www-form-urlencoded . We can set up a body-parser to interpret this data. Let's extend our code with the snippet below to implement the slash command receiver as specified in the Slack docs. First add a require statement for body-parser at the top. const bodyParser = require ( \"body-parser\" ); Then add the code below: app . use ( bodyParser . urlencoded ()); app . post ( '/slack/command/stats' , [ function ( req , res ){ const slackReqObj = req . body ; const packageJson = require ( './package.json' ); const current_time = new Date (); const stats = { name : packageJson . name , version : packageJson . version , environment : process . env . NODE_ENV , platform : process . platform , architecture : process . arch , node_version : process . version , pid : process . pid , current_server_time : current_time . toString (), uptime : process . uptime (), memory_usage : process . memoryUsage () }; const response = { response_type : 'in_channel' , channel : slackReqObj . channel_id , text : JSON . stringify ( stats , null , '\\t' ) }; return res . json ( response ); }]); This code listens for incoming POST calls on the line app.post('/slack/command/stats', [function(req,res){ . If we receive one, we build up a return object, consisting of various interesting stats and info. This includes the current time on the server (in case it is in a different time zone to us), the name and version of our app as set in the package.json file, and various environment and process info. Then it replies to the request in the format specified by Slack in their docs. We use the line text: JSON.stringify(stats, null, '\\t') to turn our info and stats object into a nicely formatted text string, in the style of a JSON object. Then, in the line return res.json(response); , we return all the info back to Slack to display as the response to a matching slash command. Great, now we can commit and push this code. git commit -am 'added handler for slash command' git push origin After the code has finished deploying on Code Capsules (it should send a startup message again when it's ready), we can test the slash command. Type /stats in the channel we chose earlier. After a second or two, the app should respond with its current vital stats and information.","title":"Adding a slash command"},{"location":"tutorials/build-slackbot-with-node/#adding-verification","text":"We can ask our app via Slack (which we use constantly!) how it's doing; pretty cool, huh? There is a problem though. If we call our slash command endpoint from anywhere else, for instance if we just call it using Postman , it also returns all the information and stats! This would not be good for a production system, as sensitive information will be easily found by attackers. So how can we ensure that the request comes from our Slack workspace? Luckily, Slack has thought about this, and sends a message signature with its requests . From the guide in Slack's docs , we can put together some code to check that the request is legitimately from Slack. The main parts of the check, copied from the docs, looks like this: Retrieve the X-Slack-Request-Timestamp header on the HTTP request, and the body of the request. Concatenate the version number, the timestamp, and the body of the request to form a basestring. Use a colon as the delimiter between the three elements. For example, v0:123456789:command=/weather&text=94070. The version number right now is always v0. With the help of HMAC SHA256 implemented in your favorite programming language, hash the above basestring, using the Slack Signing Secret as the key. Compare this computed signature to the X-Slack-Signature header on the request. We can also check the timestamp to ensure that it is not a replay attack of a message from long ago. Ok, let's implement this in our project. First, we somehow need to access the raw body of the request, before it has been parsed by body-parser . This is to ensure that the signing hash we calculate is using the same data that Slack did. After parsing, there could be extra characters and formatting etc. Luckily, the body parser package has a verify option , which passes a binary buffer of the raw body request to a user defined function. Let's make a function that conforms to the specs given by body-parser . Add this code to your index.js file: var rawBodySaver = function ( req , res , buf , encoding ) { if ( buf && buf . length ) { req . rawBody = buf . toString ( encoding || 'utf8' ); } } In this function, we grab the bit stream buffer buf , and check that it is not null and that it is not empty (by checking that it has a length). Then we tack it onto the request req as a new property rawBody . We also convert the buffer to a string, using the encoding supplied, or fall back to utf8 as a default. Now that the rawBody is added to the request, it will be available for use by subsequent middleware. We can add it to the body parser by modifying the code where we add the body parser to the app. app . use ( bodyParser . urlencoded ({ verify : rawBodySaver })); In the code above, we added options to our body parser initialisation. We set the verify option to the method we added above. Now, let's make a new middleware function to calculate the signature and compare it. We'll be able to call this middleware before our current code for responding to our Slack slash command. Making it a middleware function will also allow us to easily re-use it on other routes, if we want to add more slash commands, or other commands from Slack in the future. We'll make a new file to hold this code. We'll call it signing.js . In the new file, let's add this code: const crypto = require ( 'crypto' ); function checkSlackMessageSignature ( req , res , next ){ const timestamp = req . headers [ 'x-slack-request-timestamp' ]; const fiveMinutesAgo = Math . floor ( Date . now () / 1000 ) - ( 60 * 5 ); if ( timestamp < fiveMinutesAgo ) { return res . sendFail ( 401 , \"mismatched timestamp\" ); } const signing_secret = process . env . SLACK_SIGNING_SECRET ; const slack_signature = req . headers [ 'x-slack-signature' ]; const [ version , slack_hash ] = slack_signature . split ( '=' ); const sig_basestring = version + ':' + timestamp + ':' + req . rawBody ; const hmac = crypto . createHmac ( 'sha256' , signing_secret ); hmac . update ( sig_basestring ); const our_hash = hmac . digest ( 'hex' ); if ( crypto . timingSafeEqual ( Buffer . from ( slack_hash ), Buffer . from ( our_hash ))) { return next (); } else { return res . send ( 401 , \"Invalid request signature\" ); } } module . exports = checkSlackMessageSignature ; Let's take a look at this code. Firstly, we import the crypto (cryptography) library . We don't need to install this as a package, as it is built into Node.js. This library will allow us to perform the hash of the basestring to compare with the signature. Next, we create a function, with the standard Express middleware parameters : - req , representing the request data. - res , representing an output object that we return results to the user via. - next , representing a function to call if we want to hand control to the next middleware function in the chain. It can also be used to pass an error object back up if something goes wrong processing the request. Then, on the first few lines of the function, we get the timestamp Slack sends from the request headers, and check that it is within the last few minutes. Note the name of the header is all in lowercase, even though Slack specifies that the header is capitalised. This is because Express converts all header keys to lowercase when serving a request. After that, we retrieve the Slack Signing Secret from our environment variables. Let's get our Signing Secret from Slack and add it to the Code Capsules environment now. Head over to your Slack app dashboard, and click on \"Basic Information\" in the left-hand sidebar. Then scroll down to App Credentials , and look for the Signing Secret . Click \"Show\", and copy the secret. Now head over to your Capsule on Code Capsules, and click on the Config tab. Add a new environment variable with Name SLACK_SIGNING_SECRET and paste in the value of the Signing Secret we copied above. Click \"Update & Start Build\" to save the changes. Ok, back to the function. After we retrieve the signing secret from the environment variables, we read out the hash calculated and sent by Slack from the headers using const slack_signature = req.headers['x-slack-signature'] . This will be a string that looks something like v0=xxxxxxxxxxxxxxxxxxxxxxx , where the xxxx represents the actual hash value. We need to split the version identifier v0 from the beginning of the string though, as this is not part of the hash value. We do this in the next line, const [version, slack_hash] = slack_signature.split('=') . Now we have both the version, and the hash string in variables that we can access. After this, we construct our basestring, made from the version we extracted above, the timestamp of the request, and the rawBody (which we extracted in our body parser verify function earlier). The next two lines are where we actually calculate the hash. First, we set up the crypto module with our crypto algorithm type SHA256 , and with our unique Signing Secret. This allows us to then create an HMAC \u2013 or Hash Based Message Authentication code , which is the fancy name for the message signature. We then use the update method on our newly created HMAC to load in our basestring that we constructed above. Now that the crypto HMAC is primed with all the info it needs, we can call the digest function to actually calculate the hash. We pass in as a parameter hex to indicate that we want the result back in hexadecimal format , as this is the same format that Slack sends their calculated hash value in. Great, so now we have Slack's signature hash, and our hash. We need to check that they are the same, which will prove that the message was legitimately sent by Slack. We could just use a normal string compare, i.e. if (slack_hash === our_hash) , but there is a slight security issue with this, known as a timing attack . This type of attack is based on the knowledge that a normal string compare function takes a different amount of time to compare two strings, depending on how close the strings are to each other. An attacker can take advantage of this timing difference to repeatedly send messages and, based on the time for our server to respond, can guess at how close their hash is to what we are expecting. With much patience and many thousands of messages, an attacker could eventually guess our Signing Secret, compromising all our checks. Luckily, there is a simple way to protect from this, and it's built right into the crypto library. This is where we call crypto.timingSafeEqual . This compare always returns in the same amount of time, regardless of how close the hashes are to each other. Therefore, we don't give any extra information away to would-be attackers. Now, if the hashes are equal, from our timingSafeEqual test, we just call return next() which exits our function and passes control to the next middleware function (which will be our slash command handler). If the hashes are not equal, then we know this request is not genuinely from Slack, so we can end early and send a 401 , which is a standard HTTP code for Unauthorized . Basically, we boot the imposter out. Now, the last line in this file is module.exports = checkSlackMessageSignature . This allows our middleware function to be visible to other modules that import this file. Ok, now that we've got this middleware created, let's link it to our slash command handler. Head on back to the index.js file, and import the middleware function by adding this line near the top of the file: const checkSlackMessageSignature = require ( './signing' ); Now, we can navigate to our slack command handler, which started like this: app.post('/slack/command/stats' . Modify that to include a call to the message signature check before the actual handler, like this: app . post ( '/slack/command/stats' , [ checkSlackMessageSignature , function ( req , res ){ Fantastic, now our app is secure. You can commit all the changes, and push it up to Git, which will kick off our final deploy to Code Capsules: git add . git commit -am 'added message signature checking' git push origin Once the code is up and running on Code Capsules, test it out to see that it still responds to the Slack slash command. Then you can try again from Postman or other similar apps, and see that it will not send any info without a valid signature (you can use v0=a2114d57b48eac39b9ad189dd8316235a7b4a8d21a10bd27519666489c69b503 as an example x-slack-signature parameter):","title":"Adding verification"},{"location":"tutorials/build-slackbot-with-node/#things-to-try-next","text":"What else can we do? It's almost endless! Add this code to an existing app you have built to get easy info straight from Slack! Add in more slash commands for more info \u2013 for example, you could get current user count on your app, number of database records etc. Basically, any information you could need for dev ops . Look at some of the other functionality Slack offers for integration; for example, using modals , or listening in for keywords in messages .","title":"Things to Try Next"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/","text":"How to Connect a MongoDB using MongoDB Atlas with your Code Capsules Application What is MongoDB Atlas? MongoDB Atlas is a database as a service that hosts and manages MongoDBs online. In some ways, this service is similar to Code Capsules. Instead of managing and hosting applications, MongoDB Atlas manages and hosts MongoDBs for you \u2013 leaving you to worry about working with your database. If you have a project idea or a project already hosted on Code Capsules that needs a database, this guide will help you. We'll walk step by step through creating an account with MongoDB Atlas and cover how to connect your application on Code Capsules to MongoDB Atlas. Creating an Account, Organization, and Project with MongoDB Atlas First, create an account with MongoDB Atlas and log in. Your MongoDB Atlas account consists of two organisational tools \u2013 Organizations and Projects : Projects contain all the clusters that host your databases. Organizations contain all of the Projects that you've created. Let's start by creating an organization. Navigate to the \"Organizations\" tab on your dashboard and click \"Create an Organization\". Then: Name your organization. Choose your cloud service. Invite anyone you'd like to your organization, then hit \"Create Organization\". Next up is creating a project: Navigate to the \"Projects\" tab. Click \"New Project\" at the top right of the screen. Choose a name for your project and hit \"Next\". Add any necessary project members, then click \"Create Project\". Next, we'll set up a cluster that'll host your database. Setting up a cluster After creating the project, you'll see a \"Build a Cluster\" button. Click it, and follow the instructions to set up a new cluster. You can choose a paid cluster or a free \"Shared Cluster\". These \"Shared Clusters\" are appropriate for small projects or for learning how to use MongoDB. MongoDB Atlas will begin to create your cluster \u2013 this can take a couple of minutes. While the cluster generates, we can set up some configurations for your database. Access configurations MongoDB Atlas requires you to create a \"user\" in order to access the database in your cluster. You can think of \"users\" as administrator accounts. Navigate to the \"Database Access\" tab under \"Security\". Click \"Add New Database User\". Choose the \"Password\" authentication method and follow the instructions. Make sure to select \"read and write to any database\" under \"Database User Privileges\". Now we need to authorize an IP address to connect to the database. Navigate to the \"Network Access\" tab under \"Security\". You'll see a button \"Add IP Address\". Adding an IP address means only computers on that IP address can connect to the database. Click \"Add IP Address\". We have a couple of options for adding an IP address. If you only want to access the database from your current IP address, hit \"Add Current IP Address\" (note: If you select this option, Code Capsules will not be able to access your database). If you already have an application on Code Capsules, or plan on hosting an application on Code Capsules, select \"Allow Access From Anywhere\". By this time, the cluster hosting your database should be ready. Let's see how we can connect to it. Connecting to the Cluster Under \"Data Storage\" on the dashboard: Click \"Clusters\". Find your cluster. Click \"Connect\". There are multiple ways to connect to the a MongoDB Atlas cluster - we want to connect the database to an application, so, click \"Connect your application\". MongoDB Atlas provides drivers for various programming languages to connect to their databases. Choose your driver and version, and check the \"Include full driver code example\" box to see the code you'll need to connect to your database. Below is their Python driver, with \"Fin\" as the user. In your driver, you'll see something like this: mongodb+srv://YOURUSERNAME:<password>@cluster0.e2fw3.mongodb.net/<dbname>?retryWrites=true&w=majorhostity . This is a URI . To connect your application to your database, copy and paste the driver into your code. In your URI, replace <password> and <dbname> with the user's password we created previously . If you plan on hosting your application on Code Capsules, we need to perform one last step. Connecting your Database to Code Capsules Code Capsules connects to your GitHub repository containing your application's code. Therefore, anyone can see your code. This means you should not push your URI to GitHub. If you did, anyone could use your database. To get around this, set up an environment variable in your code for your URI and set the environment variable on Code Capsules. For example, an environment variable in Python program would look like: import os client = pymongo . MongoClient ( os . getenv ( 'DATABASE-URI' )) db = client . test ### Do something here On Code Capsules you would then set an environment variable named DATABASE-URI , containing the URI. To set environment variables on Code Capsules, host your application on Code Capsules and navigate to the \"Config\" tab in your Capsule. Make sure to click \"Update\" when done.","title":"How to Connect a MongoDB using MongoDB Atlas with your Code Capsules Application"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#how-to-connect-a-mongodb-using-mongodb-atlas-with-your-code-capsules-application","text":"","title":"How to Connect a MongoDB using MongoDB Atlas with your Code Capsules Application"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#what-is-mongodb-atlas","text":"MongoDB Atlas is a database as a service that hosts and manages MongoDBs online. In some ways, this service is similar to Code Capsules. Instead of managing and hosting applications, MongoDB Atlas manages and hosts MongoDBs for you \u2013 leaving you to worry about working with your database. If you have a project idea or a project already hosted on Code Capsules that needs a database, this guide will help you. We'll walk step by step through creating an account with MongoDB Atlas and cover how to connect your application on Code Capsules to MongoDB Atlas.","title":"What is MongoDB Atlas?"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#creating-an-account-organization-and-project-with-mongodb-atlas","text":"First, create an account with MongoDB Atlas and log in. Your MongoDB Atlas account consists of two organisational tools \u2013 Organizations and Projects : Projects contain all the clusters that host your databases. Organizations contain all of the Projects that you've created. Let's start by creating an organization. Navigate to the \"Organizations\" tab on your dashboard and click \"Create an Organization\". Then: Name your organization. Choose your cloud service. Invite anyone you'd like to your organization, then hit \"Create Organization\". Next up is creating a project: Navigate to the \"Projects\" tab. Click \"New Project\" at the top right of the screen. Choose a name for your project and hit \"Next\". Add any necessary project members, then click \"Create Project\". Next, we'll set up a cluster that'll host your database.","title":"Creating an Account, Organization, and Project with MongoDB Atlas"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#setting-up-a-cluster","text":"After creating the project, you'll see a \"Build a Cluster\" button. Click it, and follow the instructions to set up a new cluster. You can choose a paid cluster or a free \"Shared Cluster\". These \"Shared Clusters\" are appropriate for small projects or for learning how to use MongoDB. MongoDB Atlas will begin to create your cluster \u2013 this can take a couple of minutes. While the cluster generates, we can set up some configurations for your database.","title":"Setting up a cluster"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#access-configurations","text":"MongoDB Atlas requires you to create a \"user\" in order to access the database in your cluster. You can think of \"users\" as administrator accounts. Navigate to the \"Database Access\" tab under \"Security\". Click \"Add New Database User\". Choose the \"Password\" authentication method and follow the instructions. Make sure to select \"read and write to any database\" under \"Database User Privileges\". Now we need to authorize an IP address to connect to the database. Navigate to the \"Network Access\" tab under \"Security\". You'll see a button \"Add IP Address\". Adding an IP address means only computers on that IP address can connect to the database. Click \"Add IP Address\". We have a couple of options for adding an IP address. If you only want to access the database from your current IP address, hit \"Add Current IP Address\" (note: If you select this option, Code Capsules will not be able to access your database). If you already have an application on Code Capsules, or plan on hosting an application on Code Capsules, select \"Allow Access From Anywhere\". By this time, the cluster hosting your database should be ready. Let's see how we can connect to it.","title":"Access configurations"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#connecting-to-the-cluster","text":"Under \"Data Storage\" on the dashboard: Click \"Clusters\". Find your cluster. Click \"Connect\". There are multiple ways to connect to the a MongoDB Atlas cluster - we want to connect the database to an application, so, click \"Connect your application\". MongoDB Atlas provides drivers for various programming languages to connect to their databases. Choose your driver and version, and check the \"Include full driver code example\" box to see the code you'll need to connect to your database. Below is their Python driver, with \"Fin\" as the user. In your driver, you'll see something like this: mongodb+srv://YOURUSERNAME:<password>@cluster0.e2fw3.mongodb.net/<dbname>?retryWrites=true&w=majorhostity . This is a URI . To connect your application to your database, copy and paste the driver into your code. In your URI, replace <password> and <dbname> with the user's password we created previously . If you plan on hosting your application on Code Capsules, we need to perform one last step.","title":"Connecting to the Cluster"},{"location":"tutorials/connect-mongodb-atlas-to-code-capsules/#connecting-your-database-to-code-capsules","text":"Code Capsules connects to your GitHub repository containing your application's code. Therefore, anyone can see your code. This means you should not push your URI to GitHub. If you did, anyone could use your database. To get around this, set up an environment variable in your code for your URI and set the environment variable on Code Capsules. For example, an environment variable in Python program would look like: import os client = pymongo . MongoClient ( os . getenv ( 'DATABASE-URI' )) db = client . test ### Do something here On Code Capsules you would then set an environment variable named DATABASE-URI , containing the URI. To set environment variables on Code Capsules, host your application on Code Capsules and navigate to the \"Config\" tab in your Capsule. Make sure to click \"Update\" when done.","title":"Connecting your Database to Code Capsules"},{"location":"tutorials/create-and-host-telegram-bot/","text":"How to Create and Host a Telegram Bot on Code Capsules In a previous tutorial , we created and hosted an API on Code Capsules. In this tutorial, we'll create a client for this API in the form of a Telegram bot. This will allow us to pull temperature, weather and exchange rate data on the go by messaging our bot in the Telegram app. We'll also learn how to host this bot on Code Capsules so it can be used by others. Along the way, we'll learn some key concepts about hosting bots securely and efficiently. Let's get started! Requirements To create a Telegram bot, we'll need: Python 3.6+ installed. A GitHub account and Git installed. Virtualenv installed. A Telegram account. A Code Capsules account. An API on Code Capsules, created using the Personal API tutorial . About Telegram Bots Telegram bots appear as contacts on the Telegram interface. Users interact with Telegram bots by messaging them with commands \u2013 these are words preceded by a forward slash, e.g. /weather , or /currency . Commands sent to the bot's account on Telegram will be passed to the bot's backend code (in our case, this will be the code we host on Code Capsules). For example, when we send the command /weather to our bot later in this article, the bot will reply with the weather data from our personal API. Let's create a Telegram bot. Registering a Bot Account and Talking to the BotFather To create a Telegram bot, we need to download Telegram and create a user account. You can use Telegram from either your PC or your phone, or both. Once you have a Telegram account, you can register a new bot by sending a message to BotFather, a bot managed by Telegram themselves. Search for \"BotFather\" and initiate a chat. From the chat interface, follow these steps: Press \"start\". Type /newbot . Choose a name for your bot. Choose a username for your bot (must end in \"bot\"). Once you've chosen a username, the BotFather will reply with an authorisation token . This is a string that enables your bot to send requests to the Telegram Bot API, similar to the authorisation tokens we used to retrieve weather and exchange rate data in the personal API tutorial. Make sure to save this token somewhere safe and private. To see if your bot was successfully created, search for the bot's username. You should see the bot and be able to start a conversation with it. Right now, our bot won't reply to anything you send it, as it doesnt have any backend code yet. Let's change that. Planning and Setup We're going to implement two commands for our bot. When we send the command /weather , our bot will reply with the weather data from the API we created. When we send the command /currency , our bot will reply with the exchange rates from USD to CAD, EUR, and ZAR. Creating a virtual environment and installing requirements First, we need to create a local directory. Give it the same name as our bot. Then, from this directory, open a terminal and create a Python virtual environment by entering the following command: virtualenv env Enter the virtual environment using the appropriate command for your system: Linux/MacOSX : source env/bin/activate Windows : env\\Scripts\\activate.bat The virtual environment will help manage our dependencies for when we host the bot on Code Capsules. To interact with the Telegram Bot API, we need to install the python-telegram-bot library, a Python wrapper for the Telegram Bot API . We'll also use the Python library requests to retrieve data from the weather and currency exchange rate API. To install these requirements, enter the following in your terminal: pip install python-telegram-bot requests Retrieving Data from the API Now we can start coding. Create a file named bot.py in the same directory where we activated the virtual environment. In this file, enter the following code, replacing YOUR-URL-HERE with the URL pointing to the weather and exchange rate API hosted on Code Capsules. import requests url = 'YOUR-URL-HERE/GET' data = requests . get ( url ) # requests data from API data = data . json () # converts return data to json # Retrieve values from API curr_temp = data [ 'curr_temp' ] cad_rate = data [ 'usd_rates' ][ 'CAD' ] eur_rate = data [ 'usd_rates' ][ 'EUR' ] zar_rate = data [ 'usd_rates' ][ 'ZAR' ] def return_weather (): print ( 'Hello. The current temperature in Cape Town is: ' + str ( curr_temp ) + \" celsius.\" ) def return_rates (): print ( \"Hello. Today, USD conversion rates are as follows: USD->CAD = \" + str ( cad_rate ) + \", USD->EUR = \" + str ( eur_rate ) + \", USD->ZAR = \" + str ( zar_rate )) return_weather () return_rates () Here we request the currency and weather data from the API and parse the temperature and conversion rates. Then we print out the data using return_weather() and return_rates() . Try it out! Run the program to ensure everything works, then continue. Creating the Bot Now we can get to creating the actual bot. At the top of the bot.py file, add this line: from telegram.ext import Updater , CommandHandler From the python-telegram-bot library, we import two classes: Updater and CommandHandler . We'll talk about these classes soon. We don't need to print our data anymore \u2013 instead, we'll return a string to our bot, so the bot can display it on Telegram. Replace def return_weather() and def return_rates() with the following: def return_weather (): return 'Hello. The current temperature in Cape Town is: ' + str ( curr_temp ) + \" celsius.\" def return_rates (): return \"Hello. Today, USD conversion rates are as follows: USD->CAD = \" + str ( cad_rate ) + \", USD->EUR = \" + str ( eur_rate ) + \", USD->ZAR = \" + str ( zar_rate ) Now, replace the return_weather() and return_rates() function calls with the code below: def main (): TOKEN = \"YOUR-BOT-TOKEN-HERE\" updater = Updater ( token = TOKEN , use_context = True ) dispatcher = updater . dispatcher weather_handler = CommandHandler ( \"weather\" , weather ) currency_handler = CommandHandler ( \"currency\" , currency ) start_handler = CommandHandler ( \"start\" , start ) dispatcher . add_handler ( weather_handler ) dispatcher . add_handler ( currency_handler ) dispatcher . add_handler ( start_handler ) updater . start_polling () if __name__ == '__main__' : main () At the top of our new main method, which will be called when this file is run, we instantiate updater , an instance of the Telegram library's Updater class. This object will retrieve commands sent to our bot and pass them to an instance of the Dispatcher class. We've assigned this Dispatcher instance to the variable dispatcher for further use. Next, we create three different CommandHandler classes, one for each command that can be sent to our bot: /start , /weather and /currency . We pass two arguments into each instantiation: the command text (without the preceding / ), and a function to call. For example, when a user enters the command /weather , the weather() function will be called. Let's define that function, and the other two. Just above def main() , enter the following three function definitions. def weather ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_weather ()) def currency ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_rates ()) def start ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = \"Hi! I respond to /weather and /currency. Try them!\" ) Each of these functions calls the python-telegram-bot function send_message() with the ID of the current chat and the appropriate text, either returned from one of our other functions or specified as a string. The update and context arguments are supplied automatically by the dispatcher. Back in our main() function, we use dispatch.add_handler to add all three handlers to our dispatcher. Finally, updater.start_polling() will begin polling for updates from Telegram. This means our code will regularly ask Telegram's servers if any commands have been sent to it. Upon receiving commands, the appropriate handler will be invoked. In the next section , we'll discuss the pitfalls of polling and consider an alternative. The code bot.py file should now look like the code below. Once again, make sure to replace YOUR-URL-HERE with the URL of the API you created in the API tutorial. from telegram.ext import Updater , CommandHandler import requests url = 'YOUR-URL-HERE/GET' data = requests . get ( url ) # requests data from API data = data . json () # converts return data to json # Retrieve values from API curr_temp = data [ 'curr_temp' ] cad_rate = data [ 'usd_rates' ][ 'CAD' ] eur_rate = data [ 'usd_rates' ][ 'EUR' ] zar_rate = data [ 'usd_rates' ][ 'ZAR' ] def return_weather (): return 'Hello. The current temperature in Cape Town is: ' + str ( curr_temp ) + \" celsius.\" def return_rates (): return \"Hello. Today, USD conversion rates are as follows: USD->CAD = \" + str ( cad_rate ) + \", USD->EUR = \" + str ( eur_rate ) + \", USD->ZAR = \" + str ( zar_rate ) def weather ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_weather ()) def currency ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_rates ()) def start ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = 'Hi! I respond to /weather and /currency. Try these!' ) def main (): TOKEN = \"YOUR-BOT-TOKEN-HERE\" updater = Updater ( token = TOKEN , use_context = True ) dispatcher = updater . dispatcher weather_handler = CommandHandler ( 'weather' , weather ) currency_handler = CommandHandler ( 'currency' , currency ) start_handler = CommandHandler ( 'start' , start ) dispatcher . add_handler ( weather_handler ) dispatcher . add_handler ( currency_handler ) dispatcher . add_handler ( start_handler ) updater . start_polling () if __name__ == '__main__' : main () Below is a conversation with a bot created using this program. Run bot.py and try it out yourself. We won't be able to send messages to our bot if this program isn't running, so hosting it on Code Capsules will allow us to interact with the bot without having to keep this code permanently running on our development PC. While we could deploy our bot to Code Capsules in its current state, there is a downside to our current implementation that we should remedy first. Polling versus Webhooks There are two ways for our bot.py file to receive commands sent to it on Telegram. Currently, the code polls Telegram constantly, regardless of whether the bot is in use. If we hosted this current version on Code Capsules, we would be wasting bandwidth, as the vast majority of polls would return nothing. Instead of polling Telegram for changes, we can create a webhook . This will allow us to receive commands as they are sent by Telegram users, without having to continuously ask Telegram servers for them. We'll set up a webhook by telling Telegram to send commands sent to our bot account to our bot's Code Capsules URL. Our dispatcher will then process the command using the appropriate handler and send back the requested information. Creating a webhook To set up the webhook, replace the line updater.start_polling() in the main function with the code below: PORT = int ( os . environ . get ( 'PORT' , '443' )) HOOK_URL = 'YOUR-CODECAPSULES-URL-HERE' + '/' + TOKEN updater . start_webhook ( listen = '0.0.0.0' , port = PORT , url_path = TOKEN , webhook_url = HOOK_URL ) updater . idle () Here we start a webhook that will listen on our Code Capsules URL at TCP port 443 and with the path of our token. Thus, Telegram will relay commands sent to our bot to the following URL: https://YOUR-CODECAPSULES-SUBDOMAIN.codecapsules.io:443/TOKEN If you've completed some of our other backend tutorials, you will be familiar with setting up web servers that receive GET and POST requests to different routes. You can think of a webhook as a very simple HTTP server that is intended to be used by bots and automated services rather than humans. Preparing For Deployment Before we push our code to GitHub and deploy it on Code Capsules, we need to make one small code change and create some files. Creating an API key environment variable Because we'll push our code to GitHub, we need to hide our bot's authentication key. If we don't, anyone could use our authentication key and take control of our bot. Replace this line TOKEN = \"YOUR-BOT-TOKEN-HERE\" with the below TOKEN = os . getenv ( 'BOTAPIKEY' ) os.getenv('BOTAPIKEY') will look for an environment variable with the name \"BOTAPIKEY\". When we host our bot on Code Capsules, we'll set this environment variable to the key we received from the BotFather. With that done, we must now create some files before we can push our code to GitHub and deploy it on Code Capsules. Creating a Procfile and requirements.txt Code Capsules requires a couple of files to deploy our application: Procfile and requirements.txt . The first one tells Code Capsules how to run our application, and the second one tells it which libraries it needs to install. To create the Procfile : Navigate to the directory containing the bot.py file and enter the virtual environment. Create a file named Procfile (with no file extension). Open Procfile , enter web: python3 bot.py , and save the file. In the same directory, open a terminal and activate the virtual environment. Then enter pip3 freeze > requirements.txt to generate a list of requirements for our Code Capsules server. Now we can push our code to GitHub. Create a GitHub repository and send the requirements.txt , Procfile , and bot.py files to the repository. Deploying the Bot to Code Capsules With all of the files sent to GitHub, let's deploy the bot to Code Capsules: Log in to Code Capsules and create a Team and Space as necessary. Link Code Capsules to the GitHub repository created previously . Enter your Code Capsules Space. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository containing the bot \u2013 leave \"Repo subpath\" empty and click \"Next\". Leave the \"Run Command\" blank and click \"Create Capsule\". We haven't supplied our webhook a URL yet, and we still need to create an environment variable for our bot's authorisation token. To create an environment variable: Navigate to your Capsule. Click the \"Config\" tab. Add an environment variable with the name \"BOTAPIKEY\" and give it your bot's API key as a value. Make sure to hit the \"Update Capsule\" button after adding the variable. Next, let's supply our webhook with the correct domain. Navigate to the \"Overview\" tab. Copy the domain found under \"Domains\". Open the bot.py file and find the line HOOK_URL = 'YOUR-CODECAPSULES-URL-HERE' + '/' + TOKEN . Replace \"YOUR-CODECAPSULES_URL\" with the domain just copied. Commit and push these changes to GitHub. After pushing these changes, the Capsule will rebuild. Once this is done, the bot is ready. Give it a try! Further Reading We've covered a lot above, from creating a Telegram bot to the differences between webhooks and polling. If you're interested in learning more about what you can do with Telegram bots, check out Telegram's bot developer introduction . If you have some ideas but require a deeper understanding of the python-telegram-bot library, browse their GitHub repository . You can find a thorough explanation of webhooks in this blog post .","title":"Telegram Bot"},{"location":"tutorials/create-and-host-telegram-bot/#how-to-create-and-host-a-telegram-bot-on-code-capsules","text":"In a previous tutorial , we created and hosted an API on Code Capsules. In this tutorial, we'll create a client for this API in the form of a Telegram bot. This will allow us to pull temperature, weather and exchange rate data on the go by messaging our bot in the Telegram app. We'll also learn how to host this bot on Code Capsules so it can be used by others. Along the way, we'll learn some key concepts about hosting bots securely and efficiently. Let's get started!","title":"How to Create and Host a Telegram Bot on Code Capsules"},{"location":"tutorials/create-and-host-telegram-bot/#requirements","text":"To create a Telegram bot, we'll need: Python 3.6+ installed. A GitHub account and Git installed. Virtualenv installed. A Telegram account. A Code Capsules account. An API on Code Capsules, created using the Personal API tutorial .","title":"Requirements"},{"location":"tutorials/create-and-host-telegram-bot/#about-telegram-bots","text":"Telegram bots appear as contacts on the Telegram interface. Users interact with Telegram bots by messaging them with commands \u2013 these are words preceded by a forward slash, e.g. /weather , or /currency . Commands sent to the bot's account on Telegram will be passed to the bot's backend code (in our case, this will be the code we host on Code Capsules). For example, when we send the command /weather to our bot later in this article, the bot will reply with the weather data from our personal API. Let's create a Telegram bot.","title":"About Telegram Bots"},{"location":"tutorials/create-and-host-telegram-bot/#registering-a-bot-account-and-talking-to-the-botfather","text":"To create a Telegram bot, we need to download Telegram and create a user account. You can use Telegram from either your PC or your phone, or both. Once you have a Telegram account, you can register a new bot by sending a message to BotFather, a bot managed by Telegram themselves. Search for \"BotFather\" and initiate a chat. From the chat interface, follow these steps: Press \"start\". Type /newbot . Choose a name for your bot. Choose a username for your bot (must end in \"bot\"). Once you've chosen a username, the BotFather will reply with an authorisation token . This is a string that enables your bot to send requests to the Telegram Bot API, similar to the authorisation tokens we used to retrieve weather and exchange rate data in the personal API tutorial. Make sure to save this token somewhere safe and private. To see if your bot was successfully created, search for the bot's username. You should see the bot and be able to start a conversation with it. Right now, our bot won't reply to anything you send it, as it doesnt have any backend code yet. Let's change that.","title":"Registering a Bot Account and Talking to the BotFather"},{"location":"tutorials/create-and-host-telegram-bot/#planning-and-setup","text":"We're going to implement two commands for our bot. When we send the command /weather , our bot will reply with the weather data from the API we created. When we send the command /currency , our bot will reply with the exchange rates from USD to CAD, EUR, and ZAR.","title":"Planning and Setup"},{"location":"tutorials/create-and-host-telegram-bot/#creating-a-virtual-environment-and-installing-requirements","text":"First, we need to create a local directory. Give it the same name as our bot. Then, from this directory, open a terminal and create a Python virtual environment by entering the following command: virtualenv env Enter the virtual environment using the appropriate command for your system: Linux/MacOSX : source env/bin/activate Windows : env\\Scripts\\activate.bat The virtual environment will help manage our dependencies for when we host the bot on Code Capsules. To interact with the Telegram Bot API, we need to install the python-telegram-bot library, a Python wrapper for the Telegram Bot API . We'll also use the Python library requests to retrieve data from the weather and currency exchange rate API. To install these requirements, enter the following in your terminal: pip install python-telegram-bot requests","title":"Creating a virtual environment and installing requirements"},{"location":"tutorials/create-and-host-telegram-bot/#retrieving-data-from-the-api","text":"Now we can start coding. Create a file named bot.py in the same directory where we activated the virtual environment. In this file, enter the following code, replacing YOUR-URL-HERE with the URL pointing to the weather and exchange rate API hosted on Code Capsules. import requests url = 'YOUR-URL-HERE/GET' data = requests . get ( url ) # requests data from API data = data . json () # converts return data to json # Retrieve values from API curr_temp = data [ 'curr_temp' ] cad_rate = data [ 'usd_rates' ][ 'CAD' ] eur_rate = data [ 'usd_rates' ][ 'EUR' ] zar_rate = data [ 'usd_rates' ][ 'ZAR' ] def return_weather (): print ( 'Hello. The current temperature in Cape Town is: ' + str ( curr_temp ) + \" celsius.\" ) def return_rates (): print ( \"Hello. Today, USD conversion rates are as follows: USD->CAD = \" + str ( cad_rate ) + \", USD->EUR = \" + str ( eur_rate ) + \", USD->ZAR = \" + str ( zar_rate )) return_weather () return_rates () Here we request the currency and weather data from the API and parse the temperature and conversion rates. Then we print out the data using return_weather() and return_rates() . Try it out! Run the program to ensure everything works, then continue.","title":"Retrieving Data from the API"},{"location":"tutorials/create-and-host-telegram-bot/#creating-the-bot","text":"Now we can get to creating the actual bot. At the top of the bot.py file, add this line: from telegram.ext import Updater , CommandHandler From the python-telegram-bot library, we import two classes: Updater and CommandHandler . We'll talk about these classes soon. We don't need to print our data anymore \u2013 instead, we'll return a string to our bot, so the bot can display it on Telegram. Replace def return_weather() and def return_rates() with the following: def return_weather (): return 'Hello. The current temperature in Cape Town is: ' + str ( curr_temp ) + \" celsius.\" def return_rates (): return \"Hello. Today, USD conversion rates are as follows: USD->CAD = \" + str ( cad_rate ) + \", USD->EUR = \" + str ( eur_rate ) + \", USD->ZAR = \" + str ( zar_rate ) Now, replace the return_weather() and return_rates() function calls with the code below: def main (): TOKEN = \"YOUR-BOT-TOKEN-HERE\" updater = Updater ( token = TOKEN , use_context = True ) dispatcher = updater . dispatcher weather_handler = CommandHandler ( \"weather\" , weather ) currency_handler = CommandHandler ( \"currency\" , currency ) start_handler = CommandHandler ( \"start\" , start ) dispatcher . add_handler ( weather_handler ) dispatcher . add_handler ( currency_handler ) dispatcher . add_handler ( start_handler ) updater . start_polling () if __name__ == '__main__' : main () At the top of our new main method, which will be called when this file is run, we instantiate updater , an instance of the Telegram library's Updater class. This object will retrieve commands sent to our bot and pass them to an instance of the Dispatcher class. We've assigned this Dispatcher instance to the variable dispatcher for further use. Next, we create three different CommandHandler classes, one for each command that can be sent to our bot: /start , /weather and /currency . We pass two arguments into each instantiation: the command text (without the preceding / ), and a function to call. For example, when a user enters the command /weather , the weather() function will be called. Let's define that function, and the other two. Just above def main() , enter the following three function definitions. def weather ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_weather ()) def currency ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_rates ()) def start ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = \"Hi! I respond to /weather and /currency. Try them!\" ) Each of these functions calls the python-telegram-bot function send_message() with the ID of the current chat and the appropriate text, either returned from one of our other functions or specified as a string. The update and context arguments are supplied automatically by the dispatcher. Back in our main() function, we use dispatch.add_handler to add all three handlers to our dispatcher. Finally, updater.start_polling() will begin polling for updates from Telegram. This means our code will regularly ask Telegram's servers if any commands have been sent to it. Upon receiving commands, the appropriate handler will be invoked. In the next section , we'll discuss the pitfalls of polling and consider an alternative. The code bot.py file should now look like the code below. Once again, make sure to replace YOUR-URL-HERE with the URL of the API you created in the API tutorial. from telegram.ext import Updater , CommandHandler import requests url = 'YOUR-URL-HERE/GET' data = requests . get ( url ) # requests data from API data = data . json () # converts return data to json # Retrieve values from API curr_temp = data [ 'curr_temp' ] cad_rate = data [ 'usd_rates' ][ 'CAD' ] eur_rate = data [ 'usd_rates' ][ 'EUR' ] zar_rate = data [ 'usd_rates' ][ 'ZAR' ] def return_weather (): return 'Hello. The current temperature in Cape Town is: ' + str ( curr_temp ) + \" celsius.\" def return_rates (): return \"Hello. Today, USD conversion rates are as follows: USD->CAD = \" + str ( cad_rate ) + \", USD->EUR = \" + str ( eur_rate ) + \", USD->ZAR = \" + str ( zar_rate ) def weather ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_weather ()) def currency ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = return_rates ()) def start ( update , context ): context . bot . send_message ( chat_id = update . effective_chat . id , text = 'Hi! I respond to /weather and /currency. Try these!' ) def main (): TOKEN = \"YOUR-BOT-TOKEN-HERE\" updater = Updater ( token = TOKEN , use_context = True ) dispatcher = updater . dispatcher weather_handler = CommandHandler ( 'weather' , weather ) currency_handler = CommandHandler ( 'currency' , currency ) start_handler = CommandHandler ( 'start' , start ) dispatcher . add_handler ( weather_handler ) dispatcher . add_handler ( currency_handler ) dispatcher . add_handler ( start_handler ) updater . start_polling () if __name__ == '__main__' : main () Below is a conversation with a bot created using this program. Run bot.py and try it out yourself. We won't be able to send messages to our bot if this program isn't running, so hosting it on Code Capsules will allow us to interact with the bot without having to keep this code permanently running on our development PC. While we could deploy our bot to Code Capsules in its current state, there is a downside to our current implementation that we should remedy first.","title":"Creating the Bot"},{"location":"tutorials/create-and-host-telegram-bot/#polling-versus-webhooks","text":"There are two ways for our bot.py file to receive commands sent to it on Telegram. Currently, the code polls Telegram constantly, regardless of whether the bot is in use. If we hosted this current version on Code Capsules, we would be wasting bandwidth, as the vast majority of polls would return nothing. Instead of polling Telegram for changes, we can create a webhook . This will allow us to receive commands as they are sent by Telegram users, without having to continuously ask Telegram servers for them. We'll set up a webhook by telling Telegram to send commands sent to our bot account to our bot's Code Capsules URL. Our dispatcher will then process the command using the appropriate handler and send back the requested information.","title":"Polling versus Webhooks"},{"location":"tutorials/create-and-host-telegram-bot/#creating-a-webhook","text":"To set up the webhook, replace the line updater.start_polling() in the main function with the code below: PORT = int ( os . environ . get ( 'PORT' , '443' )) HOOK_URL = 'YOUR-CODECAPSULES-URL-HERE' + '/' + TOKEN updater . start_webhook ( listen = '0.0.0.0' , port = PORT , url_path = TOKEN , webhook_url = HOOK_URL ) updater . idle () Here we start a webhook that will listen on our Code Capsules URL at TCP port 443 and with the path of our token. Thus, Telegram will relay commands sent to our bot to the following URL: https://YOUR-CODECAPSULES-SUBDOMAIN.codecapsules.io:443/TOKEN If you've completed some of our other backend tutorials, you will be familiar with setting up web servers that receive GET and POST requests to different routes. You can think of a webhook as a very simple HTTP server that is intended to be used by bots and automated services rather than humans.","title":"Creating a webhook"},{"location":"tutorials/create-and-host-telegram-bot/#preparing-for-deployment","text":"Before we push our code to GitHub and deploy it on Code Capsules, we need to make one small code change and create some files.","title":"Preparing For Deployment"},{"location":"tutorials/create-and-host-telegram-bot/#creating-an-api-key-environment-variable","text":"Because we'll push our code to GitHub, we need to hide our bot's authentication key. If we don't, anyone could use our authentication key and take control of our bot. Replace this line TOKEN = \"YOUR-BOT-TOKEN-HERE\" with the below TOKEN = os . getenv ( 'BOTAPIKEY' ) os.getenv('BOTAPIKEY') will look for an environment variable with the name \"BOTAPIKEY\". When we host our bot on Code Capsules, we'll set this environment variable to the key we received from the BotFather. With that done, we must now create some files before we can push our code to GitHub and deploy it on Code Capsules.","title":"Creating an API key environment variable"},{"location":"tutorials/create-and-host-telegram-bot/#creating-a-procfile-and-requirementstxt","text":"Code Capsules requires a couple of files to deploy our application: Procfile and requirements.txt . The first one tells Code Capsules how to run our application, and the second one tells it which libraries it needs to install. To create the Procfile : Navigate to the directory containing the bot.py file and enter the virtual environment. Create a file named Procfile (with no file extension). Open Procfile , enter web: python3 bot.py , and save the file. In the same directory, open a terminal and activate the virtual environment. Then enter pip3 freeze > requirements.txt to generate a list of requirements for our Code Capsules server. Now we can push our code to GitHub. Create a GitHub repository and send the requirements.txt , Procfile , and bot.py files to the repository.","title":"Creating a Procfile and requirements.txt"},{"location":"tutorials/create-and-host-telegram-bot/#deploying-the-bot-to-code-capsules","text":"With all of the files sent to GitHub, let's deploy the bot to Code Capsules: Log in to Code Capsules and create a Team and Space as necessary. Link Code Capsules to the GitHub repository created previously . Enter your Code Capsules Space. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository containing the bot \u2013 leave \"Repo subpath\" empty and click \"Next\". Leave the \"Run Command\" blank and click \"Create Capsule\". We haven't supplied our webhook a URL yet, and we still need to create an environment variable for our bot's authorisation token. To create an environment variable: Navigate to your Capsule. Click the \"Config\" tab. Add an environment variable with the name \"BOTAPIKEY\" and give it your bot's API key as a value. Make sure to hit the \"Update Capsule\" button after adding the variable. Next, let's supply our webhook with the correct domain. Navigate to the \"Overview\" tab. Copy the domain found under \"Domains\". Open the bot.py file and find the line HOOK_URL = 'YOUR-CODECAPSULES-URL-HERE' + '/' + TOKEN . Replace \"YOUR-CODECAPSULES_URL\" with the domain just copied. Commit and push these changes to GitHub. After pushing these changes, the Capsule will rebuild. Once this is done, the bot is ready. Give it a try!","title":"Deploying the Bot to Code Capsules"},{"location":"tutorials/create-and-host-telegram-bot/#further-reading","text":"We've covered a lot above, from creating a Telegram bot to the differences between webhooks and polling. If you're interested in learning more about what you can do with Telegram bots, check out Telegram's bot developer introduction . If you have some ideas but require a deeper understanding of the python-telegram-bot library, browse their GitHub repository . You can find a thorough explanation of webhooks in this blog post .","title":"Further Reading"},{"location":"tutorials/creating-and-hosting-a-flask-api/","text":"Creating and Hosting an API with Flask and Code Capsules An API , or Application Programming Interface, is a tool enabling developers to interact with data online. Imagine: you navigate to some website and see your location's temperature displayed on their homepage. How did they present this information? Without a doubt, they used an API. APIs are hosted on a server and operate as an access point between the user and some data. Part of this guide takes a look at the weatherstack API \u2013 an API providing weather data. For the website to retrieve your location's temperature, they would've sent a request to an API like weatherstack. In the request, they would include information about your computer's location. weatherstack's API would then return weather data related to your locale, such as the temperature and cloud cover. The weather website will then display this data on their homepage for you to view. In this tutorial, we'll learn how to create a personal API with Python (using Flask ). Our API will use data from the weatherstack and OpenExchangeRates APIs to give us up-to-the-minute USD exchange rates and the temperature of a given city. We'll host our API on Code Capsules so that anyone will be able to request information from it, no matter their location. Prerequisites Before starting, we'll need a GitHub account and knowledge of how to push code from a local repository to a remote repository . Also ensure you've installed the following: Git Python 3.XX+ Virtualenv Setting Up Our Environment First, let's set up a virtual Python environment using Virtualenv. Virtualenv provides a clean Python install with no third-party libraries or packages, allowing us to work on this project without interfering with the dependencies of our other projects. Open your terminal and create an empty folder. Navigate to the folder via your terminal, and enter: virtualenv env To activate the virtual environment, enter one of the following: Linux/MacOSX source env/bin/activate Windows \\env\\Scripts\\activate.bat If the virtual environment has activated correctly, you'll see (env) to the left of your name in the terminal. Installing the Dependencies Now that we've activated the virtual environment, let's take a look at the packages we'll use to create our API: Flask is a minimal web development framework for Python. Flask provides resources and tools for building and maintaining web applications, websites, and more. Gunicorn is a WSGI server that will help serve our Python application (the API hosted on Code Capsules). Requests is a Python library we will use to interact with APIs. From your terminal where you activated the virtual environment, install these packages with: pip3 install flask gunicorn requests Note pip will have automatically been installed when you set the virtual environment if not you can follow this guide to install it. Registering Accounts on OpenExchangeRates and weatherstack Our API will return the current temperature of a chosen city and the USD exchange rates for three currencies. We'll create our API by combining data from two other APIs \u2013 weatherstack and OpenExchangeRates . As their names suggest, weatherstack will provide the temperature data, and OpenExchangeRates the exchange rate data. Registering an account is required so that we can receive a unique API key . An API key is a password that lets us use a particular API. In APIs with more sensitive data, these are used to prevent unauthorised access, but for open APIs like weatherstack and OpenExchangeRates, they're used for rate limiting to prevent users from sending too many requests at once and overwhelming the system. Creating our accounts First, let's register an account on OpenExchangeRates. Navigate to here and: Sign up and log in. On the dashboard, click \"App IDs\". Take note of your \"App ID\" (API key) you will need to paste it into the code below. Obtaining the weatherstack API key is similar: Create a free account on weatherstack Log in and take note of the API key presented in the control panel, you will need to paste it into the code below. Now we can retrieve data from the OpenExchangeRates and weatherstack APIs using our API keys. Let's try that out now. Getting exchange rates First, let's see how requesting data from OpenExchangeRates works. Create a file named app.py and open it. To request data from an API, we need an endpoint for the type of data we want. APIs often provide multiple endpoints for different information \u2013 for example, a weather API may have one endpoint for temperature and another for humidity. In the code below, the EXCHANGE_URL variable contains the OpenExchangeRates endpoint for retrieving the latest exchange rates. Enter it in your app.py file now, replacing YOUR-API-KEY-HERE with the OpenExchangeRates API key you saved earlier. import requests EXCHANGE_URL = 'https://openexchangerates.org/api/latest.json?app_id=YOUR-API-KEY-HERE' exchange_data = requests . get ( EXCHANGE_URL ) Note that we are including a secret API key in our codebase, which is bad practice. In later tutorials, you'll see how to use environment variables with Code Capsules for better security. In this code, we're using the requests module to fetch data from the API. It does this over HTTPS, the same way your browser would. In fact, if you copy the value of EXCHANGE_URL to your browser now, you'll see exactly what data your code is fetching. Note the format of the URL: https://openexchangerates.org is the website. /api/ is the path containing the API portion of the website. latest.json is the API endpoint which returns the latest exchange rates. ?app_id=YOUR-API-KEY-HERE specifies our password for accessing the API. OpenExchangeRates has many other endpoints, each of which provides a different set of data. For example, you could request data from the historical endpoint ( https://openexchangerates.org/api/historical/ ) to access past exchange rates. Now let's print the data using the .json() method. This method converts the data from raw text into in JSON (Javascript Object Notation), which we can work with like a Python dictionary. print ( exchange_data . json ()) When running the program, you will see a lot of output. This is because we are currently retrieving every exchange rate OpenExchangeRates provides. Let's modify the code to only receive exchange rates from USD to EUR, CAD, and ZAR. Add the following lines below EXCHANGE_URL : EXCHANGE_PARAMS = { 'symbols' : 'ZAR,EUR,CAD' } exchange_data = requests . get ( EXCHANGE_URL , EXCHANGE_PARAMS ) Then change your print statement as follows: print(exchange_data.json()['rates']) # Print only exchange rates Now we've included an EXCHANGE_PARAMS variable. Providing parameters to an API endpoint will alter which data is retrieved. The parameters available will depend on the API endpoint. You can find a list of parameters for the latest endpoint here . In our case, we supplied the parameter symbols with the three currencies we want data for. When you run the program again, you should only see three exchange rates. Getting the temperature Now that we've obtained the exchange rates, we can retrieve the temperature for a city. Let's modify the program by adding the following below the print statement. Make sure to replace YOUR-API-KEY-HERE with the weatherstack API key. WEATHER_URL = 'http://api.weatherstack.com/current?access_key=YOUR-API-KEY-HERE' WEATHER_PARAMS = { 'query' : 'Cape Town' } weather = requests . get ( WEATHER_URL , params = WEATHER_PARAMS ) print ( weather . json ()[ 'current' ][ 'temperature' ]) # will print only the temperature; print without indexing to see all the values returned! Here we retrieve the temperature for Cape Town, South Africa. You can replace \"Cape Town\" with another city of your choice to see its temperature. Creating our API Now we'll get to creating the API with Flask. Our API will package the weatherstack and OpenExchangeRates data together in a single endpoint. This means we can build other applications later which will be able to retrieve all of the data above by calling requests.get(MY_CODE_CAPSULES_URL) . Beginning steps with Flask First, we can remove all the print statements in our app.py file. Afterwards, edit the file accordingly: import requests from flask import Flask , jsonify EXCHANGE_URL = 'https://openexchangerates.org/api/latest.json?app_id=YOUR-API-KEY-HERE' EXCHANGE_PARAMS = { 'symbols' : 'ZAR,EUR,CAD' } WEATHER_URL = 'http://api.weatherstack.com/current?access_key=YOUR-API-KEY-HERE' WEATHER_PARAMS = { 'query' : 'Cape Town' } app = Flask ( __name__ ) @app . route ( '/' ) # Create main page of web-application def index (): return \"Welcome to my API!\" # Display text on main page if __name__ == '__main__' : app . run () # Run the application After instantiating a Flask object, we add @app.route('/') . The @ symbol is known as a Python decorator \u2013 their use isn't very important for our application. Just understand that the below creates the homepage for your API: @app . route ( ` / ` ) def index (): return \"Welcome to my API!\" Once the API is hosted on Code Capsules, you'll see \"Welcome to my API!\" when you visit the app's URL which you can find under the domains section of the capsule. Next, we'll implement the ability to \"get\" (using requests.get() ) our data from the API when it's hosted. Combining the APIs We've already written code to retrieve our data \u2013 now we just need to combine it and create an endpoint to fetch it. We'll do this by creating a new endpoint called /get that returns our selected data. @app . route ( '/get' , methods = [ 'GET' ]) # Add an endpoint to access our API def get (): exchange_data = requests . get ( EXCHANGE_URL , EXCHANGE_PARAMS ) weather = requests . get ( WEATHER_URL , params = WEATHER_PARAMS ) return jsonify ({ 'usd_rates' : exchange_data . json ()[ 'rates' ], 'curr_temp' : weather . json ()[ 'current' ][ 'temperature' ] }) @app.route('/get', methods=['GET']) adds an endpoint, /get , allowing us to retrieve data from the API. When Code Capsules gives us a URL for our API, we'll be able to use this URL plus the endpoint /get to retrieve data from our API, combining the inputs from the two APIs we are calling out to in turn. Next, the statement below returns our data in JSON: return jsonify ({ 'usd_rates' : exchange_data . json ()[ 'rates' ], 'curr_temp' : weather . json ()[ 'current' ][ 'temperature' ] }) Here, the exchange rate data is stored under 'usd_rates' and the temperature data under curr_temp . This means that if we request our data and store it in a variable like my_data , we'll be able to print out the exchange rates by executing print(my_data['usd_rates']) , and print the temperature by executing print(my_data['curr_temp']) . The API is complete \u2013 only a few steps left before hosting it on Code Capsules. Freezing Requirements and Creating the Procfile Before sending our API to GitHub (so Code Capsules can host it), we need the requirements.txt file, and a Procfile. The requirements.txt file contains information about the libraries we've used to make our API, which will allow Code Capsules to install those same libraries when we deploy it. To create this file, first ensure your terminal is still in the virtual environment. Then, in the same directory as the app.py file, enter pip3 freeze > requirements.txt in your terminal. Next, create a new file named Procfile in the same directory. Open the Procfile and enter: web: gunicorn app:app This tells Code Capsules to use the Gunicorn WSGI server to serve the HTTP data sent and received by our Flask API. Hosting the API on Code Capsules The API is now ready to host on Code Capsules. Follow these steps to get it online: Create a remote repository on GitHub. Push the Procfile , requirements.txt , and app.py files to the repository. Link the repository to your Code Capsules account following this guide. Create a new Team and Space (as necessary). With the repository linked to Code Capsules, we just need to store the API on a Capsule: Create a new Capsule. Choose Backend Capsule and continue. Select your product type and GitHub repository, click next. Leave the \"Run Command\" field blank (our Procfile handles this step). Create the Capsule. Once the Capsule has built, the API is hosted! Let's take a quick look at how to interact with it. Viewing and interacting with our API Once the Capsule has been built, Code Capsules will provide you with a URL (found in the \"Overview\" tab). Enter the URL in your browser, and you'll be greeted with \"Welcome to my API!\". To view the API data, add /get to the end of the URL. Depending on your browser (Google Chrome was used below), you'll see something like this: Now try interacting with the API through code. In a new file, enter the following, replacing the URL with your Code Capsules URL (ensure /get is at the end of the URL): import requests MY_URL = 'https://my-code-capsules-url.codecapsules.space/get' api_data = requests . get ( MY_URL ) print ( api_data . json ()) All done! Further Reading We've learned a lot about APIs; how to interact with them, how to use API endpoints, and how to create and host an API with Flask and Code Capsules. If you'd like a more in-depth look at APIs, check out this article . If you're interested in learning more about Flask or want to know what else you can do with it, start with their tutorial or their documentation .","title":"Flask API"},{"location":"tutorials/creating-and-hosting-a-flask-api/#creating-and-hosting-an-api-with-flask-and-code-capsules","text":"An API , or Application Programming Interface, is a tool enabling developers to interact with data online. Imagine: you navigate to some website and see your location's temperature displayed on their homepage. How did they present this information? Without a doubt, they used an API. APIs are hosted on a server and operate as an access point between the user and some data. Part of this guide takes a look at the weatherstack API \u2013 an API providing weather data. For the website to retrieve your location's temperature, they would've sent a request to an API like weatherstack. In the request, they would include information about your computer's location. weatherstack's API would then return weather data related to your locale, such as the temperature and cloud cover. The weather website will then display this data on their homepage for you to view. In this tutorial, we'll learn how to create a personal API with Python (using Flask ). Our API will use data from the weatherstack and OpenExchangeRates APIs to give us up-to-the-minute USD exchange rates and the temperature of a given city. We'll host our API on Code Capsules so that anyone will be able to request information from it, no matter their location.","title":"Creating and Hosting an API with Flask and Code Capsules"},{"location":"tutorials/creating-and-hosting-a-flask-api/#prerequisites","text":"Before starting, we'll need a GitHub account and knowledge of how to push code from a local repository to a remote repository . Also ensure you've installed the following: Git Python 3.XX+ Virtualenv","title":"Prerequisites"},{"location":"tutorials/creating-and-hosting-a-flask-api/#setting-up-our-environment","text":"First, let's set up a virtual Python environment using Virtualenv. Virtualenv provides a clean Python install with no third-party libraries or packages, allowing us to work on this project without interfering with the dependencies of our other projects. Open your terminal and create an empty folder. Navigate to the folder via your terminal, and enter: virtualenv env To activate the virtual environment, enter one of the following: Linux/MacOSX source env/bin/activate Windows \\env\\Scripts\\activate.bat If the virtual environment has activated correctly, you'll see (env) to the left of your name in the terminal.","title":"Setting Up Our Environment"},{"location":"tutorials/creating-and-hosting-a-flask-api/#installing-the-dependencies","text":"Now that we've activated the virtual environment, let's take a look at the packages we'll use to create our API: Flask is a minimal web development framework for Python. Flask provides resources and tools for building and maintaining web applications, websites, and more. Gunicorn is a WSGI server that will help serve our Python application (the API hosted on Code Capsules). Requests is a Python library we will use to interact with APIs. From your terminal where you activated the virtual environment, install these packages with: pip3 install flask gunicorn requests Note pip will have automatically been installed when you set the virtual environment if not you can follow this guide to install it.","title":"Installing the Dependencies"},{"location":"tutorials/creating-and-hosting-a-flask-api/#registering-accounts-on-openexchangerates-and-weatherstack","text":"Our API will return the current temperature of a chosen city and the USD exchange rates for three currencies. We'll create our API by combining data from two other APIs \u2013 weatherstack and OpenExchangeRates . As their names suggest, weatherstack will provide the temperature data, and OpenExchangeRates the exchange rate data. Registering an account is required so that we can receive a unique API key . An API key is a password that lets us use a particular API. In APIs with more sensitive data, these are used to prevent unauthorised access, but for open APIs like weatherstack and OpenExchangeRates, they're used for rate limiting to prevent users from sending too many requests at once and overwhelming the system.","title":"Registering Accounts on OpenExchangeRates and weatherstack"},{"location":"tutorials/creating-and-hosting-a-flask-api/#creating-our-accounts","text":"First, let's register an account on OpenExchangeRates. Navigate to here and: Sign up and log in. On the dashboard, click \"App IDs\". Take note of your \"App ID\" (API key) you will need to paste it into the code below. Obtaining the weatherstack API key is similar: Create a free account on weatherstack Log in and take note of the API key presented in the control panel, you will need to paste it into the code below. Now we can retrieve data from the OpenExchangeRates and weatherstack APIs using our API keys. Let's try that out now.","title":"Creating our accounts"},{"location":"tutorials/creating-and-hosting-a-flask-api/#getting-exchange-rates","text":"First, let's see how requesting data from OpenExchangeRates works. Create a file named app.py and open it. To request data from an API, we need an endpoint for the type of data we want. APIs often provide multiple endpoints for different information \u2013 for example, a weather API may have one endpoint for temperature and another for humidity. In the code below, the EXCHANGE_URL variable contains the OpenExchangeRates endpoint for retrieving the latest exchange rates. Enter it in your app.py file now, replacing YOUR-API-KEY-HERE with the OpenExchangeRates API key you saved earlier. import requests EXCHANGE_URL = 'https://openexchangerates.org/api/latest.json?app_id=YOUR-API-KEY-HERE' exchange_data = requests . get ( EXCHANGE_URL ) Note that we are including a secret API key in our codebase, which is bad practice. In later tutorials, you'll see how to use environment variables with Code Capsules for better security. In this code, we're using the requests module to fetch data from the API. It does this over HTTPS, the same way your browser would. In fact, if you copy the value of EXCHANGE_URL to your browser now, you'll see exactly what data your code is fetching. Note the format of the URL: https://openexchangerates.org is the website. /api/ is the path containing the API portion of the website. latest.json is the API endpoint which returns the latest exchange rates. ?app_id=YOUR-API-KEY-HERE specifies our password for accessing the API. OpenExchangeRates has many other endpoints, each of which provides a different set of data. For example, you could request data from the historical endpoint ( https://openexchangerates.org/api/historical/ ) to access past exchange rates. Now let's print the data using the .json() method. This method converts the data from raw text into in JSON (Javascript Object Notation), which we can work with like a Python dictionary. print ( exchange_data . json ()) When running the program, you will see a lot of output. This is because we are currently retrieving every exchange rate OpenExchangeRates provides. Let's modify the code to only receive exchange rates from USD to EUR, CAD, and ZAR. Add the following lines below EXCHANGE_URL : EXCHANGE_PARAMS = { 'symbols' : 'ZAR,EUR,CAD' } exchange_data = requests . get ( EXCHANGE_URL , EXCHANGE_PARAMS ) Then change your print statement as follows: print(exchange_data.json()['rates']) # Print only exchange rates Now we've included an EXCHANGE_PARAMS variable. Providing parameters to an API endpoint will alter which data is retrieved. The parameters available will depend on the API endpoint. You can find a list of parameters for the latest endpoint here . In our case, we supplied the parameter symbols with the three currencies we want data for. When you run the program again, you should only see three exchange rates.","title":"Getting exchange rates"},{"location":"tutorials/creating-and-hosting-a-flask-api/#getting-the-temperature","text":"Now that we've obtained the exchange rates, we can retrieve the temperature for a city. Let's modify the program by adding the following below the print statement. Make sure to replace YOUR-API-KEY-HERE with the weatherstack API key. WEATHER_URL = 'http://api.weatherstack.com/current?access_key=YOUR-API-KEY-HERE' WEATHER_PARAMS = { 'query' : 'Cape Town' } weather = requests . get ( WEATHER_URL , params = WEATHER_PARAMS ) print ( weather . json ()[ 'current' ][ 'temperature' ]) # will print only the temperature; print without indexing to see all the values returned! Here we retrieve the temperature for Cape Town, South Africa. You can replace \"Cape Town\" with another city of your choice to see its temperature.","title":"Getting the temperature"},{"location":"tutorials/creating-and-hosting-a-flask-api/#creating-our-api","text":"Now we'll get to creating the API with Flask. Our API will package the weatherstack and OpenExchangeRates data together in a single endpoint. This means we can build other applications later which will be able to retrieve all of the data above by calling requests.get(MY_CODE_CAPSULES_URL) .","title":"Creating our API"},{"location":"tutorials/creating-and-hosting-a-flask-api/#beginning-steps-with-flask","text":"First, we can remove all the print statements in our app.py file. Afterwards, edit the file accordingly: import requests from flask import Flask , jsonify EXCHANGE_URL = 'https://openexchangerates.org/api/latest.json?app_id=YOUR-API-KEY-HERE' EXCHANGE_PARAMS = { 'symbols' : 'ZAR,EUR,CAD' } WEATHER_URL = 'http://api.weatherstack.com/current?access_key=YOUR-API-KEY-HERE' WEATHER_PARAMS = { 'query' : 'Cape Town' } app = Flask ( __name__ ) @app . route ( '/' ) # Create main page of web-application def index (): return \"Welcome to my API!\" # Display text on main page if __name__ == '__main__' : app . run () # Run the application After instantiating a Flask object, we add @app.route('/') . The @ symbol is known as a Python decorator \u2013 their use isn't very important for our application. Just understand that the below creates the homepage for your API: @app . route ( ` / ` ) def index (): return \"Welcome to my API!\" Once the API is hosted on Code Capsules, you'll see \"Welcome to my API!\" when you visit the app's URL which you can find under the domains section of the capsule. Next, we'll implement the ability to \"get\" (using requests.get() ) our data from the API when it's hosted.","title":"Beginning steps with Flask"},{"location":"tutorials/creating-and-hosting-a-flask-api/#combining-the-apis","text":"We've already written code to retrieve our data \u2013 now we just need to combine it and create an endpoint to fetch it. We'll do this by creating a new endpoint called /get that returns our selected data. @app . route ( '/get' , methods = [ 'GET' ]) # Add an endpoint to access our API def get (): exchange_data = requests . get ( EXCHANGE_URL , EXCHANGE_PARAMS ) weather = requests . get ( WEATHER_URL , params = WEATHER_PARAMS ) return jsonify ({ 'usd_rates' : exchange_data . json ()[ 'rates' ], 'curr_temp' : weather . json ()[ 'current' ][ 'temperature' ] }) @app.route('/get', methods=['GET']) adds an endpoint, /get , allowing us to retrieve data from the API. When Code Capsules gives us a URL for our API, we'll be able to use this URL plus the endpoint /get to retrieve data from our API, combining the inputs from the two APIs we are calling out to in turn. Next, the statement below returns our data in JSON: return jsonify ({ 'usd_rates' : exchange_data . json ()[ 'rates' ], 'curr_temp' : weather . json ()[ 'current' ][ 'temperature' ] }) Here, the exchange rate data is stored under 'usd_rates' and the temperature data under curr_temp . This means that if we request our data and store it in a variable like my_data , we'll be able to print out the exchange rates by executing print(my_data['usd_rates']) , and print the temperature by executing print(my_data['curr_temp']) . The API is complete \u2013 only a few steps left before hosting it on Code Capsules.","title":"Combining the APIs"},{"location":"tutorials/creating-and-hosting-a-flask-api/#freezing-requirements-and-creating-the-procfile","text":"Before sending our API to GitHub (so Code Capsules can host it), we need the requirements.txt file, and a Procfile. The requirements.txt file contains information about the libraries we've used to make our API, which will allow Code Capsules to install those same libraries when we deploy it. To create this file, first ensure your terminal is still in the virtual environment. Then, in the same directory as the app.py file, enter pip3 freeze > requirements.txt in your terminal. Next, create a new file named Procfile in the same directory. Open the Procfile and enter: web: gunicorn app:app This tells Code Capsules to use the Gunicorn WSGI server to serve the HTTP data sent and received by our Flask API.","title":"Freezing Requirements and Creating the Procfile"},{"location":"tutorials/creating-and-hosting-a-flask-api/#hosting-the-api-on-code-capsules","text":"The API is now ready to host on Code Capsules. Follow these steps to get it online: Create a remote repository on GitHub. Push the Procfile , requirements.txt , and app.py files to the repository. Link the repository to your Code Capsules account following this guide. Create a new Team and Space (as necessary). With the repository linked to Code Capsules, we just need to store the API on a Capsule: Create a new Capsule. Choose Backend Capsule and continue. Select your product type and GitHub repository, click next. Leave the \"Run Command\" field blank (our Procfile handles this step). Create the Capsule. Once the Capsule has built, the API is hosted! Let's take a quick look at how to interact with it.","title":"Hosting the API on Code Capsules"},{"location":"tutorials/creating-and-hosting-a-flask-api/#viewing-and-interacting-with-our-api","text":"Once the Capsule has been built, Code Capsules will provide you with a URL (found in the \"Overview\" tab). Enter the URL in your browser, and you'll be greeted with \"Welcome to my API!\". To view the API data, add /get to the end of the URL. Depending on your browser (Google Chrome was used below), you'll see something like this: Now try interacting with the API through code. In a new file, enter the following, replacing the URL with your Code Capsules URL (ensure /get is at the end of the URL): import requests MY_URL = 'https://my-code-capsules-url.codecapsules.space/get' api_data = requests . get ( MY_URL ) print ( api_data . json ()) All done!","title":"Viewing and interacting with our API"},{"location":"tutorials/creating-and-hosting-a-flask-api/#further-reading","text":"We've learned a lot about APIs; how to interact with them, how to use API endpoints, and how to create and host an API with Flask and Code Capsules. If you'd like a more in-depth look at APIs, check out this article . If you're interested in learning more about Flask or want to know what else you can do with it, start with their tutorial or their documentation .","title":"Further Reading"},{"location":"tutorials/customising-domain/","text":"Customising Your Domain on Code Capsules In this tutorial, we'll set up a custom domain name for your website or application hosted on Code Capsules. Why Custom Domains and How Do They Work? Custom domains garner name recognition for your web-application or website. Consider the Google search-engine: without a domain, you would need to type in the IP address for it. This would be far more difficult to remember than the URL www.google.com \u2013 instantly recognizable. Web-addresses like www.google.com act as placeholders for an IP address and help us remember the website. When you type a URL in your search bar, your computer sends a request with the URL to the Domain Name System (DNS) \u2013 a cluster of servers worldwide containing domain names and corresponding IP addresses. The DNS then returns the URL's corresponding IP address, and you connect to the website you were trying to reach. Following this guide, we'll learn how to buy a domain and route it to a Code Capsules hosted web-application. Along the way, we'll learn more about the DNS and related topics. Prerequisites To complete this tutorial, we'll need: A web-application hosted on Code Capsules . A valid payment method (credit card, PayPal, cryptocurrency, bank transfer) to purchase a custom domain. Where to Buy a Domain Domain Registrars are businesses accredited to sell domains. We'll purchase a domain from the registrar www.gandi.net. Some things to keep in mind when choosing a domain name: Domains that don't contain highly sought after words are usually inexpensive. You can save on domains by using less popular Top-level domains (TLD's) \u2013 for example: rather than register a \".com\" website, register a \".info\" website. Keeping these tips in mind, let's purchase a domain. Purchasing a domain from Gandi To purchase a domain on Gandi: Navigate to www.gandi.net. Enter the domain you want in the domain search box (ex: https://www.lincolnsportfolio.co.za) Add the domain to the shopping cart. Checkout by clicking the shopping cart at the top right of the screen. Decide how many years you'd like to host the domain, and press the Checkout button. Follow the prompts to create an account and purchase your domain. Then log in to Gandi.net with your new account and click the \"Domain\" button on the dashboard. If Gandi has processed the domain, find it under the \"Active\" tab \u2013 if it's still processing, view it under the \"Pending\" tab. Processing a domain can take some time. Before routing the new domain to a web application, we have something left to consider \u2013 the security of your web-application. HTTP vs. HTTPS Domain names are one portion of a URL (Uniform Resource Locator) \u2013 Google's domain name is google.com , and the URL is http://www.google.com. Similarly, example.com is a domain name, and http://www.example.com is the URL associated with it. HTTP stands for Hypertext Transfer Protocol . When you see HTTP beginning a URL such as http://www.google.com, you know that the information retrieved by entering this address returns in clear text . This means data is vulnerable when interacting with this website, presenting a problem for any website dealing with sensitive information. The alternative is HTTPS \u2013 Hypertext Transfer Protocol Secure . HTTPS encrypts data sent between you and the server that you're connected to. Because of the security risks associated with HTTP , many websites \"force\" an HTTPS connection. Try entering http://www.google.com in your web browser. You'll notice the http portion automatically becomes https . Like the Google example, we'll make sure that if a user attempts to connect via http://www.yourwebsitehere.com , they'll redirect to https:/www.yourwebitehere.com . Setting up HTTPS is a quick process with Gandi \u2013 let's do that for your domain. Setting Up HTTPS for Your Domain To set up HTTPS with the domain, we need to register a free SSL (Secure Sockets Layer) certificate. In short, an SSL certificate helps encrypt the data sent when connected via HTTPS. To register an SSL certificate for our domain we must: Click on the domain under the active tab. Navigate to the Web Forwarding tab. Click Create at the top right. From the Address drop-down menu , choose \"HTTP:// + HTTPS://\" Type \"www\" in the textbox to the right. From the Address to forward to drop-down menu, choose \"HTTPS://\" Type in the name of the domain. Choose \"Permanent\" under Type of web forwarding The above image shows an example form \u2013 click create when done. Repeat this process, but choose \"http://\" in the Address drop-down and type \"*\" in the textbox next to it. This will forward any users connect to http://www.yourdomainhere.tld or http://yourdomainhere.tld to https://yourdomainhere.tld \u2013 it forces users to take advantage of HTTPS. After creating this forwarding address, Gandi automatically creates an SSL certificate. This can take some time to process. You'll need to verify your email address with Gandi before receiving the SSL certificate, so check your email for a verification link from Gandi. Now that the domain has an SSL certificate, we'll route your Code Capsules web-application to the domain. Navigate to your domain on the Gandi dashboard. Routing Your Web-application to The Domain Click the \"DNS Records\" tab at the top of the page. DNS records contain your domain's \"information\". When users enter your domain in their search bar, their computer will receive these records (or information). Gandi supplies numerous DNS records with default values upon domain creation. We'll only concern ourselves with entries containing the \"A\" and \"CNAME\" types. An A record stores the IP address of the server that hosts your web-application (in this case, Code Capsules). When you type in a domain name, your computer requests the A record associated with the domain from the DNS. The DNS returns the A record containing the IP address \u2013 this is what you finally connect to. Let's modify the default A record to route to your web-application: On Code Capsules , navigate to the Capsule you wish to route to your new domain. Click Overview then Add A Custom Domain . Copy the supplied IP address and type in the name of the web-address purchased. Click Create Domain . At the DNS record tab in domain view on Gandi, edit the entry with \"A\" as the type. Enter \"@\" for its name and paste the Code Capsules supplied IP address in the IPv4 address text box. Click create. It may take up to 3 hours for these changes to process . View your web-application by typing https://yourdomainname.tld , replacing your domain name with \"yourdomainname\" and \".tld\" with your extension (such as .com). Notice that if you type https://www.yourdomainhere.tld , you'll receive a 404 error. To fix this, we'll add a new \"CNAME\" record. A CNAME is like an alias for a domain \u2013 we're going to create one that tells the DNS that it should direct users who enter the leading \"www.\" to the same place as those who leave it out. To allow users to enter in \"www.\" before your domain name: Return to Code Capsules and press the Add A Custom Domain button again. Under domain name, enter www.yourdomainname.tld , replacing your name and TLD appropriately. Return to the DNS record tab on Gandi, and press Add at the top right. Choose the CNAME type. Enter \"www\" in the name text-box. Type your default Code Capsules web-application URL under Hostname (find this in the \"Overview\" tab in your web-application's Capsule), with a period at the end. It should look like the below: Click create. You can now view your web-application by entering either https://yourdomainname.tld or https://www.yourdomainname.tld . Once more, it may take up to 3 hours for these changes to process . What Next? We've learned how to purchase, secure, and configure a domain, route a domain to your Code Capsules application, and even a little bit about DNS. If you're interested, there is still a lot to learn about DNS. A fine place to start is Amazon Web Services' page on DNS . If you'd like to know about the rest of the DNS records associated with your new domain, this Google help page contains a good overview Finally, if you'd like to read more about how the HTTP protocol works, this Mozilla Developers Network page is a good place to start.","title":"Custom Domains"},{"location":"tutorials/customising-domain/#customising-your-domain-on-code-capsules","text":"In this tutorial, we'll set up a custom domain name for your website or application hosted on Code Capsules.","title":"Customising Your Domain on Code Capsules"},{"location":"tutorials/customising-domain/#why-custom-domains-and-how-do-they-work","text":"Custom domains garner name recognition for your web-application or website. Consider the Google search-engine: without a domain, you would need to type in the IP address for it. This would be far more difficult to remember than the URL www.google.com \u2013 instantly recognizable. Web-addresses like www.google.com act as placeholders for an IP address and help us remember the website. When you type a URL in your search bar, your computer sends a request with the URL to the Domain Name System (DNS) \u2013 a cluster of servers worldwide containing domain names and corresponding IP addresses. The DNS then returns the URL's corresponding IP address, and you connect to the website you were trying to reach. Following this guide, we'll learn how to buy a domain and route it to a Code Capsules hosted web-application. Along the way, we'll learn more about the DNS and related topics.","title":"Why Custom Domains and How Do They Work?"},{"location":"tutorials/customising-domain/#prerequisites","text":"To complete this tutorial, we'll need: A web-application hosted on Code Capsules . A valid payment method (credit card, PayPal, cryptocurrency, bank transfer) to purchase a custom domain.","title":"Prerequisites"},{"location":"tutorials/customising-domain/#where-to-buy-a-domain","text":"Domain Registrars are businesses accredited to sell domains. We'll purchase a domain from the registrar www.gandi.net. Some things to keep in mind when choosing a domain name: Domains that don't contain highly sought after words are usually inexpensive. You can save on domains by using less popular Top-level domains (TLD's) \u2013 for example: rather than register a \".com\" website, register a \".info\" website. Keeping these tips in mind, let's purchase a domain.","title":"Where to Buy a Domain"},{"location":"tutorials/customising-domain/#purchasing-a-domain-from-gandi","text":"To purchase a domain on Gandi: Navigate to www.gandi.net. Enter the domain you want in the domain search box (ex: https://www.lincolnsportfolio.co.za) Add the domain to the shopping cart. Checkout by clicking the shopping cart at the top right of the screen. Decide how many years you'd like to host the domain, and press the Checkout button. Follow the prompts to create an account and purchase your domain. Then log in to Gandi.net with your new account and click the \"Domain\" button on the dashboard. If Gandi has processed the domain, find it under the \"Active\" tab \u2013 if it's still processing, view it under the \"Pending\" tab. Processing a domain can take some time. Before routing the new domain to a web application, we have something left to consider \u2013 the security of your web-application.","title":"Purchasing a domain from Gandi"},{"location":"tutorials/customising-domain/#http-vs-https","text":"Domain names are one portion of a URL (Uniform Resource Locator) \u2013 Google's domain name is google.com , and the URL is http://www.google.com. Similarly, example.com is a domain name, and http://www.example.com is the URL associated with it. HTTP stands for Hypertext Transfer Protocol . When you see HTTP beginning a URL such as http://www.google.com, you know that the information retrieved by entering this address returns in clear text . This means data is vulnerable when interacting with this website, presenting a problem for any website dealing with sensitive information. The alternative is HTTPS \u2013 Hypertext Transfer Protocol Secure . HTTPS encrypts data sent between you and the server that you're connected to. Because of the security risks associated with HTTP , many websites \"force\" an HTTPS connection. Try entering http://www.google.com in your web browser. You'll notice the http portion automatically becomes https . Like the Google example, we'll make sure that if a user attempts to connect via http://www.yourwebsitehere.com , they'll redirect to https:/www.yourwebitehere.com . Setting up HTTPS is a quick process with Gandi \u2013 let's do that for your domain.","title":"HTTP vs. HTTPS"},{"location":"tutorials/customising-domain/#setting-up-https-for-your-domain","text":"To set up HTTPS with the domain, we need to register a free SSL (Secure Sockets Layer) certificate. In short, an SSL certificate helps encrypt the data sent when connected via HTTPS. To register an SSL certificate for our domain we must: Click on the domain under the active tab. Navigate to the Web Forwarding tab. Click Create at the top right. From the Address drop-down menu , choose \"HTTP:// + HTTPS://\" Type \"www\" in the textbox to the right. From the Address to forward to drop-down menu, choose \"HTTPS://\" Type in the name of the domain. Choose \"Permanent\" under Type of web forwarding The above image shows an example form \u2013 click create when done. Repeat this process, but choose \"http://\" in the Address drop-down and type \"*\" in the textbox next to it. This will forward any users connect to http://www.yourdomainhere.tld or http://yourdomainhere.tld to https://yourdomainhere.tld \u2013 it forces users to take advantage of HTTPS. After creating this forwarding address, Gandi automatically creates an SSL certificate. This can take some time to process. You'll need to verify your email address with Gandi before receiving the SSL certificate, so check your email for a verification link from Gandi. Now that the domain has an SSL certificate, we'll route your Code Capsules web-application to the domain. Navigate to your domain on the Gandi dashboard.","title":"Setting Up HTTPS for Your Domain"},{"location":"tutorials/customising-domain/#routing-your-web-application-to-the-domain","text":"Click the \"DNS Records\" tab at the top of the page. DNS records contain your domain's \"information\". When users enter your domain in their search bar, their computer will receive these records (or information). Gandi supplies numerous DNS records with default values upon domain creation. We'll only concern ourselves with entries containing the \"A\" and \"CNAME\" types. An A record stores the IP address of the server that hosts your web-application (in this case, Code Capsules). When you type in a domain name, your computer requests the A record associated with the domain from the DNS. The DNS returns the A record containing the IP address \u2013 this is what you finally connect to. Let's modify the default A record to route to your web-application: On Code Capsules , navigate to the Capsule you wish to route to your new domain. Click Overview then Add A Custom Domain . Copy the supplied IP address and type in the name of the web-address purchased. Click Create Domain . At the DNS record tab in domain view on Gandi, edit the entry with \"A\" as the type. Enter \"@\" for its name and paste the Code Capsules supplied IP address in the IPv4 address text box. Click create. It may take up to 3 hours for these changes to process . View your web-application by typing https://yourdomainname.tld , replacing your domain name with \"yourdomainname\" and \".tld\" with your extension (such as .com). Notice that if you type https://www.yourdomainhere.tld , you'll receive a 404 error. To fix this, we'll add a new \"CNAME\" record. A CNAME is like an alias for a domain \u2013 we're going to create one that tells the DNS that it should direct users who enter the leading \"www.\" to the same place as those who leave it out. To allow users to enter in \"www.\" before your domain name: Return to Code Capsules and press the Add A Custom Domain button again. Under domain name, enter www.yourdomainname.tld , replacing your name and TLD appropriately. Return to the DNS record tab on Gandi, and press Add at the top right. Choose the CNAME type. Enter \"www\" in the name text-box. Type your default Code Capsules web-application URL under Hostname (find this in the \"Overview\" tab in your web-application's Capsule), with a period at the end. It should look like the below: Click create. You can now view your web-application by entering either https://yourdomainname.tld or https://www.yourdomainname.tld . Once more, it may take up to 3 hours for these changes to process .","title":"Routing Your Web-application to The Domain"},{"location":"tutorials/customising-domain/#what-next","text":"We've learned how to purchase, secure, and configure a domain, route a domain to your Code Capsules application, and even a little bit about DNS. If you're interested, there is still a lot to learn about DNS. A fine place to start is Amazon Web Services' page on DNS . If you'd like to know about the rest of the DNS records associated with your new domain, this Google help page contains a good overview Finally, if you'd like to read more about how the HTTP protocol works, this Mozilla Developers Network page is a good place to start.","title":"What Next?"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/","text":"Developing a Persistent Sleep Tracker Part 1: Handling Users with Flask-Login Introduction In this two-part tutorial series, we'll learn how to create a sleep tracker web application hosted on Code Capsules. Users will register an account with the sleep tracker and log in. To track their sleep data, users will enter a date and number of hours slept. We'll present users with a graph showing the sleep data they've logged, so users can get a visual representation of their sleep habits over time. Throughout this tutorial series, we'll use many tools to create an interactive experience. We'll learn how to: Create a user login and register system with Python's Flask . Use a MongoDB NoSQL database to store data. Create interactive Plotly graphs. This tutorial series is best suited for those with some Python, HTML, and Flask experience. But even if you feel you don't have much experience with these, don't worry. We'll walk through this application step-by-step. Let's get started! MongoDB Data Capsule One of the most important aspects of this tutorial is using a Mongo Database (MongoDB). With this MongoDB, we can track users' login information and sleep data. MongoDB is a NoSQL databases, which means we can store data easily, in variable formats, without having to first create tables, as we would have to with a traditional SQL databse. If you're unfamiliar with NoSQL databases or MongoDB in general, take a look at this explainer by the MongoDB organisation. Follow this short tutorial to create a MongoDB data capsule that we'll use to store the user data for this sleep tracker application. This step is extremely important \u2013 without a database, our application will not function. Once you've set up a MongoDB data capsule, continue with this tutorial. Requirements In addition to creating a MongoDB Data Capsule, make sure you have the following: Git installed and a registered GitHub account. Virtualenv installed. A registered Code Capsules account. Project Setup and Introduction Creating this sleep tracker will be a two-part process. First, we will create a login and registration page and a user management backend. Second, we will create a page where users enter their sleep data and view a graph. This tutorial will focus on the first part: dealing with user management. To start, create a sleep-tracker directory somewhere on your computer. All of our project's files will be in this directory. Setting up Virtual Env With our sleep-tracker directory created, we need to set up a virtual environment . Setting up a virtual environment will be useful when we host our web application on Code Capsules. Virtual environments ensure that only the libraries used in the development of our sleep tracker application will be installed by Code Capsule's servers. To create a virtual environment, navigate to the sleep-tracker directory in a terminal and enter virtualenv env . Then, activate the virtual environment with: Linux/MacOSX: source env/bin/activate Windows: \\env\\Scripts\\activate.bat If the virtual environment activated correctly, you'll notice (env) to the left of your name in the terminal. Keep this terminal open \u2013 we'll install the project dependencies next. Installing requirements Our sleep tracker will use the following Python libraries: Flask is a lightweight Python web development framework. Flask-Login provides user session management for Flask. This will help us implement a user login and registeration system without having to create one from scratch. Flask Bcrypt is a hashing extension for Flask. This allow us to store users' passwords securely and without knowing what they are. Gunicorn is the WSGI server we'll use to host our application on Code Capsules. Pymongo is a Python library that has tools for interacting with MongoDBs. We'll use Pymongo to connect and send data to our MongoDB. To install these libraries, activate the virtual environment in your terminal and type the following: pip3 install flask flask-login flask-bcrypt gunicorn pymongo Next, we'll create all the files and directories that we'll use in both parts of this series. Creating the file structure Because we'll use Flask to render our HTML files and serve static content, we need to have a specific project structure. Flask expects to find HTML files in a directory named templates and static content such as CSS stylesheets and images in a directory named static . In the sleep-tracker directory, create both of these directories. Inside templates , create three files: base.html , login.html , and main.html . base.html will contain the skeleton for our website's other HTML pages. login.html will contain the HTML for the main page of our web application. Here, users will log in or register an account with our sleep tracker. main.html will contain the HTML for the page where users will enter their sleep data and view a graph of this data. We'll deal with this file in the second part of this tutorial. Next, open the static directory and create a file named style.css . This will be the only file in this directory, and will conain the CSS style for our website. Finally, in the main sleep-tracker directory, create a file named app.py . In this file, we'll write the Python code that serves our HTML content to user and manages their activities on the web application. Creating the HTML Templates Flask uses the Jinja templating library to allow us to embed Python-like code in HTML. This will allow us to create web pages which change dynamically in response to user actions such as registration, login and entering sleep tracking data. In this section, we will be populating the files we created in templates above, starting with base.html . Base.html The base.html file will contain all of the HTML code common throughout our application. This allows us to use it as a skeleton for every other page and avoid repeating standard markup such as stylesheet links. Open the base.html file and enter the following markup: <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > Sleep Tracker </ title > < meta name = \"author\" content = \"your-name-here\" > < meta name = \"description\" content = \"This web-application helps you track your sleep!\" > < link rel = \"stylesheet\" href = \"{{url_for('static',filename='style.css')}}\" > </ head > < body > {% block content %}{% endblock %} </ body > </ html > This is our skeleton. When Flask serves our login.html or main.html pages, it will replace the {% block content %}{% endblock %} with that page's unique content. Any code between {% and %} or {{ and }} is Jinja syntax, which is largely similar to Python code. Flask will evaluate this code before rendering HTML files and serving them to users. In this example, we use Jinja syntax to call Flask's url_for() function. To link our stylesheet, Flask uses the url_for() function to find the style.css file in the static directory. Creating the Login Page Now that we've created the base.html file, we can implement our login.html file. Open login.html and add the following markup: {% extends \"base.html\" %} {% block content %} < h2 > Login or register here to track your sleep! </ h2 > < form action = \"\" method = \"POST\" > < ul > < li > < label for = \"username\" > Username: </ label > < input type = \"text\" id = \"name\" name = \"user_name\" > </ li > < li > < label for = \"password\" > Password: </ label > < input type = \"password\" id = \"password\" name = \"user_pw\" > </ li > < li class = \"button\" > < input type = \"submit\" name = 'login' value = 'Login' > < input type = \"submit\" name = 'register' value = 'Register' > </ li > </ ul > </ form > {% endblock %} The line {% extends \"base.html\" %} tells Jinja to render this page by populating each of base.html 's named block directives with the corresponding block content defined in login.html . In this instance, we've only defined a single block named content , but we could define multiple blocks. For example, we might want to have a head block that defines some page-specific content that needs to be in the HTML <head> tag. On this page, we've created a form containing input fields for users to enter their username and password, as well as login and register buttons. Note the POST HTTP method \u2013 this will ensure that the username and password are sent as POST parameters in the HTTP request body, rather than as GET parameters in the URL. This allows us to differentate between when a user visits the login page (a GET request) versus when they click the register or login button. Before we take a look at our work so far, let's populate our style.css file to make our HTML look a bit better. Adding styles Open the style.css file in the static directory and add the following: form { margin : auto ; width : 500 px ; } form li + li { margin-top : 1 em ; } ul { /* Remove unordered list dots */ list-style : none ; padding : .1 ; margin : .1 ; } label { display : inline-block ; width : 100 px ; text-align : right ; } input , textarea { font : \"Times New Roman\" , serif ; /* Change border & width of textarea */ border : 1 px solid #000000 ; width : 300 px ; box-sizing : border-box ; } . button { /* Align w/ text box */ padding-left : 105 px ; } h2 { text-align : center ; font : \"Times New Roman\" , serif ; } Feel free to add your own personal touches, such as a favourite colour or font. Testing what we have Now that we've created our templates and stylesheet, let's add some initial functionality to app.py . Open the file and enter the following code: from flask import Flask , render_template , url_for , request , redirect app = Flask ( __name__ ) ## Login/Register page @app . route ( '/' ) def login (): return render_template ( 'login.html' ) @app . route ( '/main' ) def main (): return render_template ( 'main.html' ) Here we've created two routes : + / , which will be our web application's homepage and serve the content of login.html . + /main , which will be our web application's sleep tracker page and serve the content of main.html . Flask uses the @app.route function decorator to determine which functions will be executed when the user visits different routes. View the application by opening a terminal in the sleep-tracker directory and and entering flask run . After running the application, Flask will provide you with URL. Enter this URL in your web browser, and you'll see the login screen. It should look something like this: Handling User Registration and Login Rather than implementing a user registration and login system ourselves, we'll use the Flask Login library that we installed earlier to provide this functionality. This will help us to save time and avoid common usability and security pitfalls. We will store user information in the database we created at the beginning of this tutorial . First, let's import the functionality we'll need from: + flask-login , flask-bcrypt , to handle users. + pymongo , to interface with MongoDB. + re , to validate user input. Enter the following code below the line that starts with from flask import : from flask_login import LoginManager , UserMixin , login_required , login_user , logout_user , current_user from flask_bcrypt import Bcrypt import pymongo , re Now we can create an instance of the LoginManager class and set a secret key for our application. Just below the line that defines app , add: app . config [ 'SECRET_KEY' ] = 'your-secret-key-here' login_manager = LoginManager ( app ) This class does exactly what it says \u2013 manages logged in users and communicates any necessary information about a user to Flask. Replace your-secret-key-here with a long randomly generated string. UUIDs are good for this purpose. You can generate one with the following terminal command: python3 -c 'import uuid; print(uuid.uuid4().hex.upper())' Next, we need to initialise a bcrypt object for our application. Add the following code below the line that defines login_manager : bcrypt = Bcrypt ( app ) When a user registers with our sleep tracker, we'll create a new entry in our MongoDB with the user's username and password. That way, when a user logs in to our sleep tracker, we can see if the information they entered matches the information in our MongoDB. Beneath the last line we added, add the following: client = pymongo . MongoClient ( 'mongodb+srv://YOURUSERNAME:YOURPASSWORD@cluster0.e2fw3.mongodb.net/<dbname>?retryWrites=true&w=majorhostity' ) db = client . user_login Here we import the pymongo library and use it to connect to our MongoDB instance. Replace YOURUSERNAME and YOURPASSWORD with your data capsule account information. Create the user class For Flask Login to work, we need to create a User class. This User class will contain information pertaining to the user that is currently logged in to our sleep tracker. Flask Login expects us to implement four methods in our User class: is_authenticated , is_active , is_anonymous and get_id . Rather than implementing all of these ourselves, we will have our User class inherit from Flask's UserMixin , which provides generic implementations for the first three, leaving us with only get_id . In addition, we'll need to implement our own load_user and check_password methods. Below the line db = client.user_login , enter the following code: class User ( UserMixin ): def __init__ ( self , username ): self . username = username def get_id ( self ): return self . username Here we've created the class, inherited from UserMixin and implemented the get_id method, which simply returns the user's username. To facilitate user login, we need to implement two methods, load_user and check_password . Let's implement load_user first. This method will be used to fetch a user from the MongoDB database corresponding to the username entered in the login form. Add the following code to the User class: @login_manager . user_loader def load_user ( username ): user = db . users . find_one ({ \"username\" : username }) if user is None : return None return User ( username = user [ 'username' ]) The decorate @login_manager.user_loader tells the login_manager to use this method to load users. Now let's add a check_password method. This method will be called to determine whether a user has entered the correct password for the username they specify. When we register users, we will hash their passwords with the bcrypt one-way encryption function before storing them in MongoDB. This will keep our users' passwords secret from us and, should our application be compromised in future, ensure that hackers cannot easily recover our users' passwords and use them on other websites those users may have account on. Therefore, when checking the password a user has entered on login, we need to hash this input with bcrypt before comparing it to the password entry in our MongoDB database. To do this, add the following code to the User class: @staticmethod def check_password ( password_entered , password ): if bcrypt . check_password_hash ( password , password_entered ): return True return False By making check_password a static method , we enabled it to be called without instantiating an instance of our User class. That's all we need for user login. Now we need to link our login and registration form to this functionality. Add functionality to the login and register buttons When a user clicks the register button, we will create a new user document in our MongoDB users collection, containing their username and hashed password. When a user clicks \"Login\", we will log them in if they've entered a valid username and password combination and redirect them to the main.html file. To do this, we'll create a new function that handles login and registration. Add the following code below the def login() function: @app . route ( \"/\" , methods = [ \"POST\" ]) def login_or_register (): if request . method == 'POST' : name_entered = str ( request . form . get ( 'user_name' )) # Get username and password from form pw_entered = str ( request . form . get ( 'user_pw' )) if request . form . get ( 'login' ): # Log in logic user = db . users . find_one ({ 'username' : name_entered }) if user and User . check_password ( pw_entered , user [ 'password' ]): usr_obj = User ( username = user [ 'username' ]) login_user ( usr_obj ) return redirect ( url_for ( 'main' )) else : return \"Incorrect username or password.\" elif request . form . get ( 'register' ): # Register logic # Validate username and password if not re . match ( \"[a-zA-Z0-9_]{1,20}\" , name_entered ): return \"Username must be between 1 and 20 characters. Letters, numbers and underscores allowed.\" if len ( pw_entered ) < 8 : return \"Password must be at least 8 characters.\" if db . users . find_one ({ 'username' : name_entered }): return \"User already exists.\" new_user = { 'username' : name_entered , 'password' : bcrypt . generate_password_hash ( pw_entered ) } db . users . insert_one ( new_user ) # insert new user to db return redirect ( url_for ( 'login' )) # redirect after register First, note the POST method. As mentioned when we created our login.html file, using a POST method for user login and registration allows our application to transmit username and information more securely and allows us to differentiate between a user login or registration ( POST ) and a user merely visiting the page ( GET ). If the login button is pressed ( if request.form.get('login') ), we check our MongoDB for a username that matches the one entered. Then we check if the password entered matches that user's password in the MongoDB. If check_password evaluates to true, we log the user in and redirect to the main route (which we'll create in the next part of this series . Otherwise, we provide the user with an error message. To redirect users, we use Flask's redirect function and url_for functions. The url_for function finds the main route, and the redirect function sends users to that route. If a user clicks \"Register\", we first validate the username and password they've provided. We're restricting usernames to a length of 20 characters, containing only alphanumeric characters and underscores. We're also ensuring that the chosen password is eight or more characters long. We then check whether the username they're trying to use is already taken. If their username and password are acceptable, we create a new_user dictionary with the specified name and a bcrypt hash of the specified password, which we then insert it into our MongoDB. Then we send the user back to the login page. Trying out the login system We've implemented the login and register buttons. Try running the program by opening a terminal in the sleep-tracker directory and entering flask run . Test out registering a few new accounts and logging into them. Remember, we haven't put any HTML in our main.html file, so when you log in, you'll see a blank page. Don't worry, everything is working! In the next part of this series , we'll implement the rest of the sleep tracker application. This means populating the main.html file and learning how to store user sleep data in MongoDB. Further Reading To learn more about Flask-Login, take a look at their documentation . The Explore Flask documentation site also has a guide for handling users that goes into further depth than we have, including features such as a way for users to reset forgotten passwords. For more information on the Jinja templating language, their documentation can be found here . Finally, when you're ready, finish the sleep tracker application by following the second tutorial in this series .","title":"Persistent Sleep Tracker Part 1"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#developing-a-persistent-sleep-tracker-part-1-handling-users-with-flask-login","text":"","title":"Developing a Persistent Sleep Tracker Part 1: Handling Users with Flask-Login"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#introduction","text":"In this two-part tutorial series, we'll learn how to create a sleep tracker web application hosted on Code Capsules. Users will register an account with the sleep tracker and log in. To track their sleep data, users will enter a date and number of hours slept. We'll present users with a graph showing the sleep data they've logged, so users can get a visual representation of their sleep habits over time. Throughout this tutorial series, we'll use many tools to create an interactive experience. We'll learn how to: Create a user login and register system with Python's Flask . Use a MongoDB NoSQL database to store data. Create interactive Plotly graphs. This tutorial series is best suited for those with some Python, HTML, and Flask experience. But even if you feel you don't have much experience with these, don't worry. We'll walk through this application step-by-step. Let's get started!","title":"Introduction"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#mongodb-data-capsule","text":"One of the most important aspects of this tutorial is using a Mongo Database (MongoDB). With this MongoDB, we can track users' login information and sleep data. MongoDB is a NoSQL databases, which means we can store data easily, in variable formats, without having to first create tables, as we would have to with a traditional SQL databse. If you're unfamiliar with NoSQL databases or MongoDB in general, take a look at this explainer by the MongoDB organisation. Follow this short tutorial to create a MongoDB data capsule that we'll use to store the user data for this sleep tracker application. This step is extremely important \u2013 without a database, our application will not function. Once you've set up a MongoDB data capsule, continue with this tutorial.","title":"MongoDB Data Capsule"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#requirements","text":"In addition to creating a MongoDB Data Capsule, make sure you have the following: Git installed and a registered GitHub account. Virtualenv installed. A registered Code Capsules account.","title":"Requirements"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#project-setup-and-introduction","text":"Creating this sleep tracker will be a two-part process. First, we will create a login and registration page and a user management backend. Second, we will create a page where users enter their sleep data and view a graph. This tutorial will focus on the first part: dealing with user management. To start, create a sleep-tracker directory somewhere on your computer. All of our project's files will be in this directory.","title":"Project Setup and Introduction"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#setting-up-virtual-env","text":"With our sleep-tracker directory created, we need to set up a virtual environment . Setting up a virtual environment will be useful when we host our web application on Code Capsules. Virtual environments ensure that only the libraries used in the development of our sleep tracker application will be installed by Code Capsule's servers. To create a virtual environment, navigate to the sleep-tracker directory in a terminal and enter virtualenv env . Then, activate the virtual environment with: Linux/MacOSX: source env/bin/activate Windows: \\env\\Scripts\\activate.bat If the virtual environment activated correctly, you'll notice (env) to the left of your name in the terminal. Keep this terminal open \u2013 we'll install the project dependencies next.","title":"Setting up Virtual Env"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#installing-requirements","text":"Our sleep tracker will use the following Python libraries: Flask is a lightweight Python web development framework. Flask-Login provides user session management for Flask. This will help us implement a user login and registeration system without having to create one from scratch. Flask Bcrypt is a hashing extension for Flask. This allow us to store users' passwords securely and without knowing what they are. Gunicorn is the WSGI server we'll use to host our application on Code Capsules. Pymongo is a Python library that has tools for interacting with MongoDBs. We'll use Pymongo to connect and send data to our MongoDB. To install these libraries, activate the virtual environment in your terminal and type the following: pip3 install flask flask-login flask-bcrypt gunicorn pymongo Next, we'll create all the files and directories that we'll use in both parts of this series.","title":"Installing requirements"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#creating-the-file-structure","text":"Because we'll use Flask to render our HTML files and serve static content, we need to have a specific project structure. Flask expects to find HTML files in a directory named templates and static content such as CSS stylesheets and images in a directory named static . In the sleep-tracker directory, create both of these directories. Inside templates , create three files: base.html , login.html , and main.html . base.html will contain the skeleton for our website's other HTML pages. login.html will contain the HTML for the main page of our web application. Here, users will log in or register an account with our sleep tracker. main.html will contain the HTML for the page where users will enter their sleep data and view a graph of this data. We'll deal with this file in the second part of this tutorial. Next, open the static directory and create a file named style.css . This will be the only file in this directory, and will conain the CSS style for our website. Finally, in the main sleep-tracker directory, create a file named app.py . In this file, we'll write the Python code that serves our HTML content to user and manages their activities on the web application.","title":"Creating the file structure"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#creating-the-html-templates","text":"Flask uses the Jinja templating library to allow us to embed Python-like code in HTML. This will allow us to create web pages which change dynamically in response to user actions such as registration, login and entering sleep tracking data. In this section, we will be populating the files we created in templates above, starting with base.html .","title":"Creating the HTML Templates"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#basehtml","text":"The base.html file will contain all of the HTML code common throughout our application. This allows us to use it as a skeleton for every other page and avoid repeating standard markup such as stylesheet links. Open the base.html file and enter the following markup: <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > Sleep Tracker </ title > < meta name = \"author\" content = \"your-name-here\" > < meta name = \"description\" content = \"This web-application helps you track your sleep!\" > < link rel = \"stylesheet\" href = \"{{url_for('static',filename='style.css')}}\" > </ head > < body > {% block content %}{% endblock %} </ body > </ html > This is our skeleton. When Flask serves our login.html or main.html pages, it will replace the {% block content %}{% endblock %} with that page's unique content. Any code between {% and %} or {{ and }} is Jinja syntax, which is largely similar to Python code. Flask will evaluate this code before rendering HTML files and serving them to users. In this example, we use Jinja syntax to call Flask's url_for() function. To link our stylesheet, Flask uses the url_for() function to find the style.css file in the static directory.","title":"Base.html"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#creating-the-login-page","text":"Now that we've created the base.html file, we can implement our login.html file. Open login.html and add the following markup: {% extends \"base.html\" %} {% block content %} < h2 > Login or register here to track your sleep! </ h2 > < form action = \"\" method = \"POST\" > < ul > < li > < label for = \"username\" > Username: </ label > < input type = \"text\" id = \"name\" name = \"user_name\" > </ li > < li > < label for = \"password\" > Password: </ label > < input type = \"password\" id = \"password\" name = \"user_pw\" > </ li > < li class = \"button\" > < input type = \"submit\" name = 'login' value = 'Login' > < input type = \"submit\" name = 'register' value = 'Register' > </ li > </ ul > </ form > {% endblock %} The line {% extends \"base.html\" %} tells Jinja to render this page by populating each of base.html 's named block directives with the corresponding block content defined in login.html . In this instance, we've only defined a single block named content , but we could define multiple blocks. For example, we might want to have a head block that defines some page-specific content that needs to be in the HTML <head> tag. On this page, we've created a form containing input fields for users to enter their username and password, as well as login and register buttons. Note the POST HTTP method \u2013 this will ensure that the username and password are sent as POST parameters in the HTTP request body, rather than as GET parameters in the URL. This allows us to differentate between when a user visits the login page (a GET request) versus when they click the register or login button. Before we take a look at our work so far, let's populate our style.css file to make our HTML look a bit better.","title":"Creating the Login Page"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#adding-styles","text":"Open the style.css file in the static directory and add the following: form { margin : auto ; width : 500 px ; } form li + li { margin-top : 1 em ; } ul { /* Remove unordered list dots */ list-style : none ; padding : .1 ; margin : .1 ; } label { display : inline-block ; width : 100 px ; text-align : right ; } input , textarea { font : \"Times New Roman\" , serif ; /* Change border & width of textarea */ border : 1 px solid #000000 ; width : 300 px ; box-sizing : border-box ; } . button { /* Align w/ text box */ padding-left : 105 px ; } h2 { text-align : center ; font : \"Times New Roman\" , serif ; } Feel free to add your own personal touches, such as a favourite colour or font.","title":"Adding styles"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#testing-what-we-have","text":"Now that we've created our templates and stylesheet, let's add some initial functionality to app.py . Open the file and enter the following code: from flask import Flask , render_template , url_for , request , redirect app = Flask ( __name__ ) ## Login/Register page @app . route ( '/' ) def login (): return render_template ( 'login.html' ) @app . route ( '/main' ) def main (): return render_template ( 'main.html' ) Here we've created two routes : + / , which will be our web application's homepage and serve the content of login.html . + /main , which will be our web application's sleep tracker page and serve the content of main.html . Flask uses the @app.route function decorator to determine which functions will be executed when the user visits different routes. View the application by opening a terminal in the sleep-tracker directory and and entering flask run . After running the application, Flask will provide you with URL. Enter this URL in your web browser, and you'll see the login screen. It should look something like this:","title":"Testing what we have"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#handling-user-registration-and-login","text":"Rather than implementing a user registration and login system ourselves, we'll use the Flask Login library that we installed earlier to provide this functionality. This will help us to save time and avoid common usability and security pitfalls. We will store user information in the database we created at the beginning of this tutorial . First, let's import the functionality we'll need from: + flask-login , flask-bcrypt , to handle users. + pymongo , to interface with MongoDB. + re , to validate user input. Enter the following code below the line that starts with from flask import : from flask_login import LoginManager , UserMixin , login_required , login_user , logout_user , current_user from flask_bcrypt import Bcrypt import pymongo , re Now we can create an instance of the LoginManager class and set a secret key for our application. Just below the line that defines app , add: app . config [ 'SECRET_KEY' ] = 'your-secret-key-here' login_manager = LoginManager ( app ) This class does exactly what it says \u2013 manages logged in users and communicates any necessary information about a user to Flask. Replace your-secret-key-here with a long randomly generated string. UUIDs are good for this purpose. You can generate one with the following terminal command: python3 -c 'import uuid; print(uuid.uuid4().hex.upper())' Next, we need to initialise a bcrypt object for our application. Add the following code below the line that defines login_manager : bcrypt = Bcrypt ( app ) When a user registers with our sleep tracker, we'll create a new entry in our MongoDB with the user's username and password. That way, when a user logs in to our sleep tracker, we can see if the information they entered matches the information in our MongoDB. Beneath the last line we added, add the following: client = pymongo . MongoClient ( 'mongodb+srv://YOURUSERNAME:YOURPASSWORD@cluster0.e2fw3.mongodb.net/<dbname>?retryWrites=true&w=majorhostity' ) db = client . user_login Here we import the pymongo library and use it to connect to our MongoDB instance. Replace YOURUSERNAME and YOURPASSWORD with your data capsule account information.","title":"Handling User Registration and Login"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#create-the-user-class","text":"For Flask Login to work, we need to create a User class. This User class will contain information pertaining to the user that is currently logged in to our sleep tracker. Flask Login expects us to implement four methods in our User class: is_authenticated , is_active , is_anonymous and get_id . Rather than implementing all of these ourselves, we will have our User class inherit from Flask's UserMixin , which provides generic implementations for the first three, leaving us with only get_id . In addition, we'll need to implement our own load_user and check_password methods. Below the line db = client.user_login , enter the following code: class User ( UserMixin ): def __init__ ( self , username ): self . username = username def get_id ( self ): return self . username Here we've created the class, inherited from UserMixin and implemented the get_id method, which simply returns the user's username. To facilitate user login, we need to implement two methods, load_user and check_password . Let's implement load_user first. This method will be used to fetch a user from the MongoDB database corresponding to the username entered in the login form. Add the following code to the User class: @login_manager . user_loader def load_user ( username ): user = db . users . find_one ({ \"username\" : username }) if user is None : return None return User ( username = user [ 'username' ]) The decorate @login_manager.user_loader tells the login_manager to use this method to load users. Now let's add a check_password method. This method will be called to determine whether a user has entered the correct password for the username they specify. When we register users, we will hash their passwords with the bcrypt one-way encryption function before storing them in MongoDB. This will keep our users' passwords secret from us and, should our application be compromised in future, ensure that hackers cannot easily recover our users' passwords and use them on other websites those users may have account on. Therefore, when checking the password a user has entered on login, we need to hash this input with bcrypt before comparing it to the password entry in our MongoDB database. To do this, add the following code to the User class: @staticmethod def check_password ( password_entered , password ): if bcrypt . check_password_hash ( password , password_entered ): return True return False By making check_password a static method , we enabled it to be called without instantiating an instance of our User class. That's all we need for user login. Now we need to link our login and registration form to this functionality.","title":"Create the user class"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#add-functionality-to-the-login-and-register-buttons","text":"When a user clicks the register button, we will create a new user document in our MongoDB users collection, containing their username and hashed password. When a user clicks \"Login\", we will log them in if they've entered a valid username and password combination and redirect them to the main.html file. To do this, we'll create a new function that handles login and registration. Add the following code below the def login() function: @app . route ( \"/\" , methods = [ \"POST\" ]) def login_or_register (): if request . method == 'POST' : name_entered = str ( request . form . get ( 'user_name' )) # Get username and password from form pw_entered = str ( request . form . get ( 'user_pw' )) if request . form . get ( 'login' ): # Log in logic user = db . users . find_one ({ 'username' : name_entered }) if user and User . check_password ( pw_entered , user [ 'password' ]): usr_obj = User ( username = user [ 'username' ]) login_user ( usr_obj ) return redirect ( url_for ( 'main' )) else : return \"Incorrect username or password.\" elif request . form . get ( 'register' ): # Register logic # Validate username and password if not re . match ( \"[a-zA-Z0-9_]{1,20}\" , name_entered ): return \"Username must be between 1 and 20 characters. Letters, numbers and underscores allowed.\" if len ( pw_entered ) < 8 : return \"Password must be at least 8 characters.\" if db . users . find_one ({ 'username' : name_entered }): return \"User already exists.\" new_user = { 'username' : name_entered , 'password' : bcrypt . generate_password_hash ( pw_entered ) } db . users . insert_one ( new_user ) # insert new user to db return redirect ( url_for ( 'login' )) # redirect after register First, note the POST method. As mentioned when we created our login.html file, using a POST method for user login and registration allows our application to transmit username and information more securely and allows us to differentiate between a user login or registration ( POST ) and a user merely visiting the page ( GET ). If the login button is pressed ( if request.form.get('login') ), we check our MongoDB for a username that matches the one entered. Then we check if the password entered matches that user's password in the MongoDB. If check_password evaluates to true, we log the user in and redirect to the main route (which we'll create in the next part of this series . Otherwise, we provide the user with an error message. To redirect users, we use Flask's redirect function and url_for functions. The url_for function finds the main route, and the redirect function sends users to that route. If a user clicks \"Register\", we first validate the username and password they've provided. We're restricting usernames to a length of 20 characters, containing only alphanumeric characters and underscores. We're also ensuring that the chosen password is eight or more characters long. We then check whether the username they're trying to use is already taken. If their username and password are acceptable, we create a new_user dictionary with the specified name and a bcrypt hash of the specified password, which we then insert it into our MongoDB. Then we send the user back to the login page.","title":"Add functionality to the login and register buttons"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#trying-out-the-login-system","text":"We've implemented the login and register buttons. Try running the program by opening a terminal in the sleep-tracker directory and entering flask run . Test out registering a few new accounts and logging into them. Remember, we haven't put any HTML in our main.html file, so when you log in, you'll see a blank page. Don't worry, everything is working! In the next part of this series , we'll implement the rest of the sleep tracker application. This means populating the main.html file and learning how to store user sleep data in MongoDB.","title":"Trying out the login system"},{"location":"tutorials/develop-persistent-sleep-tracker-part-1/#further-reading","text":"To learn more about Flask-Login, take a look at their documentation . The Explore Flask documentation site also has a guide for handling users that goes into further depth than we have, including features such as a way for users to reset forgotten passwords. For more information on the Jinja templating language, their documentation can be found here . Finally, when you're ready, finish the sleep tracker application by following the second tutorial in this series .","title":"Further Reading"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/","text":"Developing a Persistent Sleep Tracker Part 2: Tracking and Graphing Sleep Data This is the second part of our sleep tracker web application tutorial, covering the creation of the sleep tracker interface. Recap In the first part of this series , we built a web application with user registration and login using Python's Flask web framework and a hosted NoSQL MongoDB database for data persistence. We will now build on the code we wrote in that tutorial, so you must have completed it. In this second part of the series, we'll implement the logic that allows users to enter their sleep data and see that data on an interactive graph, generated using Plotly . Registered users will be able to log the number of hours slept on different days and visualise this data as a graph. Creating the Sleep Tracker Front-end At the end of our last tutorial, we saw a blank page when we logged in and were redirected to the application's /main page. This happened because our main.html file was empty, so let's add some content to it. We'll need the following: A form with fields for the date and hours slept, so users can provide sleep data for different days. A way to view a graph of this data. A logout button, that logs the user out. To do all of this, we will first need to build a main.html containing both static HTML and dynamic Jinja template components that will change depending on which user is logged in and what sleep data they've provided. We will also implement some front-end JavaScript code to make our sleep data graph interactive. Let's add the sleep data logging form first. Open the main.html file in the templates directory. Add the following: {% extends \"base.html\" %} {% block content %} < h2 > Hey, {{ user['username'] }}! Let's track your sleep. </ h2 > < form action = \"\" method = \"POST\" > < ul > < li > < label for = \"time\" > Time Slept (hours): </ label > < input type = \"text\" id = \"time\" name = \"time\" > </ li > < li > < label for = \"date\" > Date: </ label > < input type = \"date\" id = \"date\" name = \"date\" value = \"\" > </ li > < li class = \"button\" > < input type = \"submit\" name = 'submit' value = 'Submit' > < input type = \"submit\" name = 'graph' value = 'View Graph' > < input type = \"submit\" name = 'logout' value = 'Logout' > </ li > </ ul > </ form > {% endblock %} This works similarly to the login.html file we created in the previous tutorial, with base.html acting as the page skeleton and our unique content being entered between the {% block content %} and {% endblock %} lines. We also ensure that our form uses the POST method so we can differentiate between a user visiting the page and clicking one of the three form buttons. To determine which button a user has clicked in a given POST request, we'll use the button's HTML name attribute ( submit , graph or logout ) in Flask. Notice the Jinja snippet {{ user['username'] }} . This will display data sent from our Flask back-end code in the page \u2013 in this case, the user's name. The <input type=\"date\" id=\"date\" name=\"date\" value=\"\"> line creates an interactive calendar so users can click on dates rather than typing them out. Adding Sleep Data Submission and Logout In the app.py file, add the following line below the app = Flask(__name__) line. app . config [ 'plotting' ] = False Here we add a new entry in our Flask application's configuration settings. This will come in handy soon \u2013 we'll use this line to tell whether or not a user has clicked the \"View Graph\" button in our main.html file. If a user has clicked the button, we'll set this line to \"True\" and a graph with the user's sleep data will display. Now, we can implement the functionality for our \"Submit\", \"View Graph\" and \"Logout\" buttons. Add the following code below the main() function. @app . route ( '/main' , methods = [ 'POST' ]) def submit_sleep (): if request . form . get ( 'submit' ): # if submitting new sleep data time_entered = float ( request . form . get ( 'time' )) date_entered = request . form . get ( 'date' ) message = add_sleep ( time_entered , date_entered , db . users . find_one ({ 'username' : current_user . get_id ()})) if message : return message if request . form . get ( 'logout' ): logout_user () app . config [ 'plotting' ] = False return 'You logged out!' elif request . form . get ( 'graph' ): app . config [ 'plotting' ] = True return redirect ( url_for ( 'main' )) This function operates similarly as our login_or_register function: If a user clicks \"Submit\", the data they entered will be stored in their MongoDB entry via the add_sleep function (that we'll create next). This function will return a string with an error message if it encounters an error, and None if it succeeds. If a user clicks \"Logout\", the user will be logged out. If a user clicks \"View Graph\", the app.config['plotting'] entry is set to True . Later, we'll expand main.html to display the graph. Let's wrap up our button functionality by creating the add_sleep function that is called when a user clicks \"Submit\". Add the following code above the submit_logout_plot function to create the add_sleep function: def add_sleep ( time , date , user ): if not re . match ( \"[0-9] {4} -[0-1][0-9]-[0-3][0-9]\" , date ): return \"Invalid date supplied.\" if time < 0.0 or time > 24.0 : return \"Sleep time must be between 0 and 24 hours.\" if 'date' in user : user [ 'date' ] . append ( date ) user [ 'time' ] . append ( time ) else : # adding sleep data for the first time user [ 'date' ] = [ date ] user [ 'time' ] = [ time ] # Update MongoDB db . users . update_one ({ 'username' : user [ 'username' ] }, { '$set' : { 'date' : user [ 'date' ], 'time' : user [ 'time' ] }}) Our add_sleep function takes three variables: time : The number of hours slept that the user entered. date : The calendar date the user selected. user : The user's MongoDB entry. First, we validate the user's input to ensure that a correctly formatted date has been provided and that the time given is not a negative number or larger than 24. If either value does not pass validation, we return a relevant error message from the function without writing to the database. Otherwise we continue. If a user has never entered any sleep data, we add a new 'date' and 'time' entry to the user's MongoDB entry with the date and time entered. Otherwise, we take the data they entered and add it to their existing sleep data. Finally, we update the user's MongoDB entry with db.users.update_one . We've implemented functionality for all three buttons. Now we need to modify the main() function to pass the current user's data to main.html . This will allow us to display their username on the page, and to graph their sleep data. Find the main() function and modify it like so: @app . route ( '/main' ) def main (): if current_user . get_id () is None : return redirect ( url_for ( 'login' )) # redirect to login page if not logged in user_data = db . users . find_one ({ 'username' : current_user . get_id () }) return render_template ( \"main.html\" , user = user_data , plot = app . config [ 'plotting' ]) First, we leverage Flask-Login's anonymous users functionality to check if the current user is not logged in and, if so, we redirect them to the login page. If the current user is logged it, we retrieve their MongoDB entry and assign it to user_data . Then we pass this variable to the render_template function as user . This is how the line below will access and display the user's name. < h2 > Hey, {{ user['username'] }}! Let's track your sleep. </ h2 > As user_data contains the entire MongoDB user entry, our template will be able to access the current user's sleep data from the user variable as well. We've also passed the template the value of app.config['plotting'] in plot . This is how our application will know whether or not to display a graph on the /main page. All that's left now is to add the sleep data graph in our main.html file. After that, we can deploy our application to Code Capsules. Adding the Plotly Graph As mentioned at the beginning of the article, we'll add the ability to graph sleep data with the help of Plotly . Plotly provides an external JavaScript library that we can use to create interactive graphs for the web. In the main.html file, find the </form> line. Right below this line, add the following: {% if plot %} < script src = \"https://cdn.plot.ly/plotly-latest.min.js\" ></ script > < div id = \"graph\" > < script > var x = {{ user [ 'date' ] | safe }}; var y = {{ user [ 'time' ] | safe }}; var trace1 = { x : x , y : y , type : 'bar' }; var data = [ trace1 ]; var layout = { title : { text : 'My Sleep' , font : { family : 'Courier New, monospace' , size : 24 }, xref : 'paper' , x : 0.05 , }, xaxis : { title : { text : 'Date' , font : { family : 'Courier New, monospace' , size : 18 , color : '#7f7f7f' } }, }, yaxis : { title : { text : 'Time Slept (hrs)' , font : { family : 'Courier New, monospace' , size : 18 , color : '#7f7f7f' } } } }; Plotly . newPlot ( 'graph' , data , layout ); </ script > </ div > {% endif %} Let's break this down, starting with the line {% if plot %} . This line references the plot variable we created in our app.py file in the main function. If someone has clicked \"View Graph\", we set plot to true. If plot is true, the HTML between {% if plot %} and {% endif %} will be included in the page served to the user, otherwise it will be left out. The line <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> imports the Plotly graphing library. This is similar to an import statement in Python. Under this line, we see a lot of code enclosed in <script>...</script> tags. This is all JavaScript code. In this code, we create two variables, x and y , which contain arrays of the dates and number of hours slept that a user has logged. Note that we have set these variables as safe , which means that Jinja will not attempt to escape or encode any of the characters within them when it renders the HTML. This is dangerous to do with user input, which is why we validated both the date and time values in our Python code. If we had not validated them, a malicious user might be able to supply JavaScript code in the date or time input fields and alter the behaviour of this page. The code inside var trace1 = {...} tells Plotly which data to use for the x and y axes, and the type of graph we'll make \u2013 a bar graph. All the code in var layout = {...} effects things like x and y axis labelling, font type, and size of font. Customise this to your liking! Finally, The line Plotly.newPlot('graph', data, layout) creates the actual graph and displays it to a user. Try running the application by opening a terminal in the sleep-tracker directory, activating the virtual environment and entering flask run . You should be able to register a new user account, log in, enter sleep data, and view your graph. Preparing for Deployment With our sleep tracker functionally complete, we need to make one last modification to our app.py file and add some files in the sleep-tracker directory before we can push our code to GitHub and deploy it on Code Capsules. Creating environment variables Before we push our code to GitHub, we need to remove our app.config['SECRET_KEY'] and the MongoDB user credentials. If we were to push our code now, anyone could use our secret key to forge user sessions on our application or our MongoDB credentials to alter our database. Luckily, there is an easy fix. First, save your secret key and MongoDB credentials somewhere safe, outside of this project's directory so that you don't lose them. Then, at the top of app.py , add the line: import os Then, replace the line: app . config [ 'SECRET_KEY' ] = 'your-secret-key-here' with this: app . config [ 'SECRET_KEY' ] = os . getenv ( 'SECRET_KEY' ) And replace this line: client = pymongo . MongoClient ( 'mongodb+srv://YOURUSERNAME:<password>@cluster0.e2fw3.mongodb.net/<dbname>?retryWrites=true&w=majorhostity' ) with this: client = pymongo . MongoClient ( 'MONGO_CONNECTION_STRING' ) os.getenv('SECRET_KEY') and os.getenv('MONGO_CONNECTION_STRING') will look for environment variables with the names \"SECRET_KEY\" and \"MONGO_CONNECTION_STRING\". When we host the sleep tracker application on Code Capsules, we'll set these environment variables to the values we removed from the code. Creating a Procfile and requirements.txt Code Capsules requires a couple of files to deploy our application: Procfile and requirements.txt . The first one tells Code Capsules how to run our application, and the second one tells it which libraries it needs to install. To create the Procfile : Create a file named Procfile in your project directory (do not add a file extension). Open the Procfile , enter web: gunicorn app:app , and save the file. This tells Code Capsules to use the Gunicorn WSGI server to run app.py . In the same terminal, activate the virtual environment and enter pip3 freeze > requirements.txt to create requirements.txt and populate it with all the libraries we've used to create this application. Now we can push our code to GitHub. Create a GitHub repository and send every file and directory to GitHub, except for virtual env's env directory . Deploying the Sleep Tracker to Code Capsules With all of the files on GitHub, we can deploy the sleep tracer to Code Capsules: Log in to Code Capsules, and create a Team and Space as necessary. Link Code Capsules to the GitHub repository created previously . Enter your Code Capsules Space. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository containing the sleep tracker \u2013 leave \"Repo subpath\" empty and click \"Next\". Leave the \"Run Command\" blank and click \"Create Capsule\". Now we just need to set those environment variables we mentioned previously . Creating environment variables in Code Capsules Let's create set the environment variables so our sleep tracker will work properly: Navigate to your Capsule. Click the \"Config\" tab. Add two environment variables, one named \"SECRET_KEY\" and another \"MONGO_CONNECTION_STRING\". Enter the secret key and connection string values you saved earlier. When done, make sure to click \"Update\". Now the sleep tracker is ready to try out! The application is complete. What Next? There are many ways to expand or improve this application. Some ideas include: Improve the application's styling \u2013 it's fairly simple right now. If you want to learn more about CSS styling, this tutorial written by Mozilla is a great place to start. Add a way for users to keep track of other data (calories, daily notes, exercise). Display better looking error messages, preferably somewhere in the current page.","title":"Persistent Sleep Tracker Part 2"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#developing-a-persistent-sleep-tracker-part-2-tracking-and-graphing-sleep-data","text":"This is the second part of our sleep tracker web application tutorial, covering the creation of the sleep tracker interface.","title":"Developing a Persistent Sleep Tracker Part 2: Tracking and Graphing Sleep Data"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#recap","text":"In the first part of this series , we built a web application with user registration and login using Python's Flask web framework and a hosted NoSQL MongoDB database for data persistence. We will now build on the code we wrote in that tutorial, so you must have completed it. In this second part of the series, we'll implement the logic that allows users to enter their sleep data and see that data on an interactive graph, generated using Plotly . Registered users will be able to log the number of hours slept on different days and visualise this data as a graph.","title":"Recap"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#creating-the-sleep-tracker-front-end","text":"At the end of our last tutorial, we saw a blank page when we logged in and were redirected to the application's /main page. This happened because our main.html file was empty, so let's add some content to it. We'll need the following: A form with fields for the date and hours slept, so users can provide sleep data for different days. A way to view a graph of this data. A logout button, that logs the user out. To do all of this, we will first need to build a main.html containing both static HTML and dynamic Jinja template components that will change depending on which user is logged in and what sleep data they've provided. We will also implement some front-end JavaScript code to make our sleep data graph interactive. Let's add the sleep data logging form first. Open the main.html file in the templates directory. Add the following: {% extends \"base.html\" %} {% block content %} < h2 > Hey, {{ user['username'] }}! Let's track your sleep. </ h2 > < form action = \"\" method = \"POST\" > < ul > < li > < label for = \"time\" > Time Slept (hours): </ label > < input type = \"text\" id = \"time\" name = \"time\" > </ li > < li > < label for = \"date\" > Date: </ label > < input type = \"date\" id = \"date\" name = \"date\" value = \"\" > </ li > < li class = \"button\" > < input type = \"submit\" name = 'submit' value = 'Submit' > < input type = \"submit\" name = 'graph' value = 'View Graph' > < input type = \"submit\" name = 'logout' value = 'Logout' > </ li > </ ul > </ form > {% endblock %} This works similarly to the login.html file we created in the previous tutorial, with base.html acting as the page skeleton and our unique content being entered between the {% block content %} and {% endblock %} lines. We also ensure that our form uses the POST method so we can differentiate between a user visiting the page and clicking one of the three form buttons. To determine which button a user has clicked in a given POST request, we'll use the button's HTML name attribute ( submit , graph or logout ) in Flask. Notice the Jinja snippet {{ user['username'] }} . This will display data sent from our Flask back-end code in the page \u2013 in this case, the user's name. The <input type=\"date\" id=\"date\" name=\"date\" value=\"\"> line creates an interactive calendar so users can click on dates rather than typing them out.","title":"Creating the Sleep Tracker Front-end"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#adding-sleep-data-submission-and-logout","text":"In the app.py file, add the following line below the app = Flask(__name__) line. app . config [ 'plotting' ] = False Here we add a new entry in our Flask application's configuration settings. This will come in handy soon \u2013 we'll use this line to tell whether or not a user has clicked the \"View Graph\" button in our main.html file. If a user has clicked the button, we'll set this line to \"True\" and a graph with the user's sleep data will display. Now, we can implement the functionality for our \"Submit\", \"View Graph\" and \"Logout\" buttons. Add the following code below the main() function. @app . route ( '/main' , methods = [ 'POST' ]) def submit_sleep (): if request . form . get ( 'submit' ): # if submitting new sleep data time_entered = float ( request . form . get ( 'time' )) date_entered = request . form . get ( 'date' ) message = add_sleep ( time_entered , date_entered , db . users . find_one ({ 'username' : current_user . get_id ()})) if message : return message if request . form . get ( 'logout' ): logout_user () app . config [ 'plotting' ] = False return 'You logged out!' elif request . form . get ( 'graph' ): app . config [ 'plotting' ] = True return redirect ( url_for ( 'main' )) This function operates similarly as our login_or_register function: If a user clicks \"Submit\", the data they entered will be stored in their MongoDB entry via the add_sleep function (that we'll create next). This function will return a string with an error message if it encounters an error, and None if it succeeds. If a user clicks \"Logout\", the user will be logged out. If a user clicks \"View Graph\", the app.config['plotting'] entry is set to True . Later, we'll expand main.html to display the graph. Let's wrap up our button functionality by creating the add_sleep function that is called when a user clicks \"Submit\". Add the following code above the submit_logout_plot function to create the add_sleep function: def add_sleep ( time , date , user ): if not re . match ( \"[0-9] {4} -[0-1][0-9]-[0-3][0-9]\" , date ): return \"Invalid date supplied.\" if time < 0.0 or time > 24.0 : return \"Sleep time must be between 0 and 24 hours.\" if 'date' in user : user [ 'date' ] . append ( date ) user [ 'time' ] . append ( time ) else : # adding sleep data for the first time user [ 'date' ] = [ date ] user [ 'time' ] = [ time ] # Update MongoDB db . users . update_one ({ 'username' : user [ 'username' ] }, { '$set' : { 'date' : user [ 'date' ], 'time' : user [ 'time' ] }}) Our add_sleep function takes three variables: time : The number of hours slept that the user entered. date : The calendar date the user selected. user : The user's MongoDB entry. First, we validate the user's input to ensure that a correctly formatted date has been provided and that the time given is not a negative number or larger than 24. If either value does not pass validation, we return a relevant error message from the function without writing to the database. Otherwise we continue. If a user has never entered any sleep data, we add a new 'date' and 'time' entry to the user's MongoDB entry with the date and time entered. Otherwise, we take the data they entered and add it to their existing sleep data. Finally, we update the user's MongoDB entry with db.users.update_one . We've implemented functionality for all three buttons. Now we need to modify the main() function to pass the current user's data to main.html . This will allow us to display their username on the page, and to graph their sleep data. Find the main() function and modify it like so: @app . route ( '/main' ) def main (): if current_user . get_id () is None : return redirect ( url_for ( 'login' )) # redirect to login page if not logged in user_data = db . users . find_one ({ 'username' : current_user . get_id () }) return render_template ( \"main.html\" , user = user_data , plot = app . config [ 'plotting' ]) First, we leverage Flask-Login's anonymous users functionality to check if the current user is not logged in and, if so, we redirect them to the login page. If the current user is logged it, we retrieve their MongoDB entry and assign it to user_data . Then we pass this variable to the render_template function as user . This is how the line below will access and display the user's name. < h2 > Hey, {{ user['username'] }}! Let's track your sleep. </ h2 > As user_data contains the entire MongoDB user entry, our template will be able to access the current user's sleep data from the user variable as well. We've also passed the template the value of app.config['plotting'] in plot . This is how our application will know whether or not to display a graph on the /main page. All that's left now is to add the sleep data graph in our main.html file. After that, we can deploy our application to Code Capsules.","title":"Adding Sleep Data Submission and Logout"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#adding-the-plotly-graph","text":"As mentioned at the beginning of the article, we'll add the ability to graph sleep data with the help of Plotly . Plotly provides an external JavaScript library that we can use to create interactive graphs for the web. In the main.html file, find the </form> line. Right below this line, add the following: {% if plot %} < script src = \"https://cdn.plot.ly/plotly-latest.min.js\" ></ script > < div id = \"graph\" > < script > var x = {{ user [ 'date' ] | safe }}; var y = {{ user [ 'time' ] | safe }}; var trace1 = { x : x , y : y , type : 'bar' }; var data = [ trace1 ]; var layout = { title : { text : 'My Sleep' , font : { family : 'Courier New, monospace' , size : 24 }, xref : 'paper' , x : 0.05 , }, xaxis : { title : { text : 'Date' , font : { family : 'Courier New, monospace' , size : 18 , color : '#7f7f7f' } }, }, yaxis : { title : { text : 'Time Slept (hrs)' , font : { family : 'Courier New, monospace' , size : 18 , color : '#7f7f7f' } } } }; Plotly . newPlot ( 'graph' , data , layout ); </ script > </ div > {% endif %} Let's break this down, starting with the line {% if plot %} . This line references the plot variable we created in our app.py file in the main function. If someone has clicked \"View Graph\", we set plot to true. If plot is true, the HTML between {% if plot %} and {% endif %} will be included in the page served to the user, otherwise it will be left out. The line <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> imports the Plotly graphing library. This is similar to an import statement in Python. Under this line, we see a lot of code enclosed in <script>...</script> tags. This is all JavaScript code. In this code, we create two variables, x and y , which contain arrays of the dates and number of hours slept that a user has logged. Note that we have set these variables as safe , which means that Jinja will not attempt to escape or encode any of the characters within them when it renders the HTML. This is dangerous to do with user input, which is why we validated both the date and time values in our Python code. If we had not validated them, a malicious user might be able to supply JavaScript code in the date or time input fields and alter the behaviour of this page. The code inside var trace1 = {...} tells Plotly which data to use for the x and y axes, and the type of graph we'll make \u2013 a bar graph. All the code in var layout = {...} effects things like x and y axis labelling, font type, and size of font. Customise this to your liking! Finally, The line Plotly.newPlot('graph', data, layout) creates the actual graph and displays it to a user. Try running the application by opening a terminal in the sleep-tracker directory, activating the virtual environment and entering flask run . You should be able to register a new user account, log in, enter sleep data, and view your graph.","title":"Adding the Plotly Graph"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#preparing-for-deployment","text":"With our sleep tracker functionally complete, we need to make one last modification to our app.py file and add some files in the sleep-tracker directory before we can push our code to GitHub and deploy it on Code Capsules.","title":"Preparing for Deployment"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#creating-environment-variables","text":"Before we push our code to GitHub, we need to remove our app.config['SECRET_KEY'] and the MongoDB user credentials. If we were to push our code now, anyone could use our secret key to forge user sessions on our application or our MongoDB credentials to alter our database. Luckily, there is an easy fix. First, save your secret key and MongoDB credentials somewhere safe, outside of this project's directory so that you don't lose them. Then, at the top of app.py , add the line: import os Then, replace the line: app . config [ 'SECRET_KEY' ] = 'your-secret-key-here' with this: app . config [ 'SECRET_KEY' ] = os . getenv ( 'SECRET_KEY' ) And replace this line: client = pymongo . MongoClient ( 'mongodb+srv://YOURUSERNAME:<password>@cluster0.e2fw3.mongodb.net/<dbname>?retryWrites=true&w=majorhostity' ) with this: client = pymongo . MongoClient ( 'MONGO_CONNECTION_STRING' ) os.getenv('SECRET_KEY') and os.getenv('MONGO_CONNECTION_STRING') will look for environment variables with the names \"SECRET_KEY\" and \"MONGO_CONNECTION_STRING\". When we host the sleep tracker application on Code Capsules, we'll set these environment variables to the values we removed from the code.","title":"Creating environment variables"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#creating-a-procfile-and-requirementstxt","text":"Code Capsules requires a couple of files to deploy our application: Procfile and requirements.txt . The first one tells Code Capsules how to run our application, and the second one tells it which libraries it needs to install. To create the Procfile : Create a file named Procfile in your project directory (do not add a file extension). Open the Procfile , enter web: gunicorn app:app , and save the file. This tells Code Capsules to use the Gunicorn WSGI server to run app.py . In the same terminal, activate the virtual environment and enter pip3 freeze > requirements.txt to create requirements.txt and populate it with all the libraries we've used to create this application. Now we can push our code to GitHub. Create a GitHub repository and send every file and directory to GitHub, except for virtual env's env directory .","title":"Creating a Procfile and requirements.txt"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#deploying-the-sleep-tracker-to-code-capsules","text":"With all of the files on GitHub, we can deploy the sleep tracer to Code Capsules: Log in to Code Capsules, and create a Team and Space as necessary. Link Code Capsules to the GitHub repository created previously . Enter your Code Capsules Space. Create a new Capsule, selecting the \"Backend\" capsule type. Select the GitHub repository containing the sleep tracker \u2013 leave \"Repo subpath\" empty and click \"Next\". Leave the \"Run Command\" blank and click \"Create Capsule\". Now we just need to set those environment variables we mentioned previously .","title":"Deploying the Sleep Tracker to Code Capsules"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#creating-environment-variables-in-code-capsules","text":"Let's create set the environment variables so our sleep tracker will work properly: Navigate to your Capsule. Click the \"Config\" tab. Add two environment variables, one named \"SECRET_KEY\" and another \"MONGO_CONNECTION_STRING\". Enter the secret key and connection string values you saved earlier. When done, make sure to click \"Update\". Now the sleep tracker is ready to try out! The application is complete.","title":"Creating environment variables in Code Capsules"},{"location":"tutorials/develop-persistent-sleep-tracker-part-2/#what-next","text":"There are many ways to expand or improve this application. Some ideas include: Improve the application's styling \u2013 it's fairly simple right now. If you want to learn more about CSS styling, this tutorial written by Mozilla is a great place to start. Add a way for users to keep track of other data (calories, daily notes, exercise). Display better looking error messages, preferably somewhere in the current page.","title":"What Next?"},{"location":"tutorials/host-a-frontend/","text":"Hosting a Front-end: Building and Deploying Your Portfolio to Code Capsules Publishing your portfolio online requires a solid technical background \u2013 managing servers can be challenging. You need to choose a server's operating system, maintain and update the server, and figure out where to host the server itself. In this tutorial, we'll work with an alternative to the traditional method of hosting a front-end (content that visitors see when they load your website), called Code Capsules . Code Capsules is a service that hosts front-end (and back-end) code online. Furthermore, Code Capsules: Manages all of the technical details \u2013 no server management required. Integrates with GitHub to deploy your code with a single git push . First, we'll take a look at choosing a portfolio template and personalising it. After, we'll push the portfolio to a GitHub repository and see how Code Capsules connects to GitHub and makes your portfolio visible to the world. Requirements & Prerequisite Knowledge Hosting a portfolio on Code Capsules requires no previous knowledge about servers or front-end development. To personalise a portfolio template and deploy it to Code Capsules, we'll need: A text editor, such as Sublime Text , or VSCode . A registered GitHub account. The Git command-line interface installed. Creating a Portfolio HTML5 UP provides HTML site templates for free. We'll use the Massively template \u2013 an easy to modify and elegant HTML template. Follow these instructions carefully : Download the Massively template. Create a directory somewhere on your computer, then enter it. Within this directory, create another directory, and extract the Massively template files into it . This last step is necessary for hosting a web-page on Code Capsules. The file structure should look something like this: myPortfolio portFolder + assets + images + generic.html + elements.html + index.html The index.html file contains all of the HTML code for our portfolio \u2013 any changes to this code will result in a change to the portfolio. To view changes you make as we begin to modify the template, double click the index.html file to open the portfolio in a web-browser. Personalizing the Template This tutorial will following the creation of a portfolio for Abraham Lincoln \u2013 the 16th president of the USA. We'll take a closer look at some things Abraham Lincoln wouldn't want in a portfolio \u2013 and maybe you too. The next few sections will cover how to modify the following elements of the portfolio template: Any not personalized text. The \"Generic Page\" and \"Elements Reference\" tabs. Pagination. The email contact form. Personal information (address, social media account). Let's start with the title and subheading of the portfolio. Open the index.html file in your text editor. You'll see the following block of HTML near the top of the file: < head > < title > Massively by HTML5 UP </ title > < meta charset = \"utf-8\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, user-scalable=no\" /> < link rel = \"stylesheet\" href = \"assets/css/main.css\" /> < noscript >< link rel = \"stylesheet\" href = \"assets/css/noscript.css\" /></ noscript > </ head > Change the text within the <title> tags to whatever you'd like, such as: \"Abraham Lincoln\". This is what will appear in search engines and browser tabs. Now we'll change the text that displays at the top of the portfolio. Scroll down in your text editor, until you see the following code: <!-- Intro --> < div id = \"intro\" > < h1 > This is < br /> Massively </ h1 > < p > A free, fully responsive HTML5 + CSS3 site template designed by < a href = \"https://twitter.com/ajlkn\" > @ajlkn </ a > for < a href = \"https://html5up.net\" > HTML5 UP </ a >< br /> and released for free under the < a href = \"https://html5up.net/license\" > Creative Commons license </ a > . </ p > < ul class = \"actions\" > < li >< a href = \"#header\" class = \"button icon solid solo fa-arrow-down scrolly\" > Continue </ a ></ li > </ ul > </ div > <!-- Header --> < header id = \"header\" > < a href = \"index.html\" class = \"logo\" > Massively </ a > </ header > Customise the words wrapped in the <h1>...</h1> tags \u2013 this is the large text that displays at the top of the portfolio. Change the text within the <p>...</p> tags to edit the subheading of the portfolio \u2013 the <br /> tags and the <a>...</a> tags are safe to delete. Delete the \"Massively\" button that appears as you scroll down the portfolio by deleting the three lines under the <!-- Header --> text wrapped in <header>...</header> tags. Save the file and open it in a web browser. Our portfolio should now look something like this: Next, we'll take a look at deleting the date entries above each portfolio piece, removing the \"Generic Page\" and \"Elements Reference\" tabs, and modifying the social media links. Removing the tabs, dates, and links The default layout for Massively is designed for a blog or news website containing articles. To look like a portfolio, we should delete the dates above each article entry. Do so by locating and deleting all lines beginning with <span class=\"date\"...> . To make this a single-page portfolio, we can delete the \"Generic Page\" and \"Elements Reference\" tabs by finding: < li class = \"active\" >< a href = \"index.html\" > This is Massively </ a ></ li > < li >< a href = \"generic.html\" > Generic Page </ a ></ li > < li >< a href = \"elements.html\" > Elements Reference </ a ></ li > and deleting the last two lines. While we're at it, alter the title of the main tab by changing the \"This is Massively\" text. The code for social media accounts is located at the top and bottom of the index.html file. Starting at the top, find this block of code: < ul class = \"icons\" > < li >< a href = \"#\" class = \"icon brands fa-twitter\" >< span class = \"label\" > Twitter </ span ></ a ></ li > < li >< a href = \"#\" class = \"icon brands fa-facebook-f\" >< span class = \"label\" > Facebook </ span ></ a ></ li > < li >< a href = \"#\" class = \"icon brands fa-instagram\" >< span class = \"label\" > Instagram </ span ></ a ></ li > < li >< a href = \"#\" class = \"icon brands fa-github\" >< span class = \"label\" > GitHub </ span ></ a ></ li > </ ul > Delete any social media account you don't need \u2013 Abraham Lincoln doesn't have Instagram, so he would delete the following line to remove the Instagram link: < li >< a href = \"#\" class = \"icon brands fa-instagram\" >< span class = \"label\" > Instagram </ span ></ a ></ li > If you'd like to link your social media accounts, enter the account link in place of the # in href=\"#\" . For example, to link Abraham Lincoln's Twitter account, you'd edit the Twitter line like so: < li >< a href = \"https://twitter.com/Abe_Lincoln\" class = \"icon brands fa-twitter\" >< span class = \"label\" > Twitter </ span ></ a ></ li > The social media code at the bottom of the index.html is nearly identical \u2013 follow this same process to edit the code at the bottom. Removing unnecessary content and further personalisation In this section we'll: Remove the contact form Remove pagination Update or remove contact information 1.Remove the contact form found at the bottom of the portfolio by deleting the following code: < section > < form method = \"post\" action = \"#\" > < div class = \"fields\" > < div class = \"field\" > < label for = \"name\" > Name </ label > < input type = \"text\" name = \"name\" id = \"name\" /> </ div > < div class = \"field\" > < label for = \"email\" > Email </ label > < input type = \"text\" name = \"email\" id = \"email\" /> </ div > < div class = \"field\" > < label for = \"message\" > Message </ label > < textarea name = \"message\" id = \"message\" rows = \"3\" ></ textarea > </ div > </ div > < ul class = \"actions\" > < li >< input type = \"submit\" value = \"Send Message\" /></ li > </ ul > </ form > </ section > 2.Remove pagination by deleting: < footer > < div class = \"pagination\" > <!--<a href=\"#\" class=\"previous\">Prev</a>--> < a href = \"#\" class = \"page active\" > 1 </ a > < a href = \"#\" class = \"page\" > 2 </ a > < a href = \"#\" class = \"page\" > 3 </ a > < span class = \"extra\" > &hellip; </ span > < a href = \"#\" class = \"page\" > 8 </ a > < a href = \"#\" class = \"page\" > 9 </ a > < a href = \"#\" class = \"page\" > 10 </ a > < a href = \"#\" class = \"next\" > Next </ a > </ div > </ footer > 3.To delete specific contact information sections (the address section is shown below), delete the <section> tag, the information you want to delete, and the corresponding </section> tag. < section class = \"alt\" > < h3 > Address </ h3 > < p > 1234 Somewhere Road #87257 < br /> Nashville, TN 00000-0000 </ p > </ section > If you'd like to personalise your contact information instead, edit the text within the <h3>...</h3> tags and the <p>...</p> tags. Personalising portfolio pieces Our portfolio is almost complete \u2013 we just need to personalise the actual portfolio pieces \u2013 customising the images, button links, and other text. Let's start with the images. Gather any images you'd like to replace with the default images. Then, place your images in the images directory, located in the same directory as the index.html file. You can swap images by finding lines wrapped in <img.../> tags, like the below line. < img src = \"images/pic01.jpg\" alt = \"\" /> images is the name of the directory where you placed your image. To change the image, replace the text \"pic01.jpg\" with the name and file extension of your desired image. Once we've replaced the images, we should change the text for each portfolio entry. Find code blocks wrapped in <article>...</article> tags, such as: < article > < header > < h2 >< a href = \"#\" > Sed magna < br /> ipsum faucibus </ a ></ h2 > </ header > < a href = \"#\" class = \"image fit\" >< img src = \"images/pic02.jpg\" alt = \"\" /></ a > < p > Donec eget ex magna. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque venenatis dolor imperdiet dolor mattis sagittis magna etiam. </ p > < ul class = \"actions special\" > < li >< a href = \"#\" class = \"button\" > Full Story </ a ></ li > </ ul > </ article > You can: Change the entry's title by editing the text within the <h2>...</h2> tags. Personalise the entry text by editing the Latin wrapped in the <p>...</p> tags. Customise buttons by finding the <li><a href=\"#\" class=\"button\">Full Story</a></li> lines and replacing the \"#\" with a link to your portfolio piece. Replace \"Full Story\" text with something more appropriate. If you would like to remove a portfolio piece, delete the <article>...</article> tags and all the text wrapped in the tags. Once finished with the portfolio, we need to push it to GitHub. After, the portfolio can be deployed to Code Capsules, making the portfolio publicly viewable. Uploading to GitHub If you already know how to push code from a local repository to a remote repository on GitHub, push the sub-directory containing the portfolio to GitHub and skip to the next section. Otherwise, we'll push (or send) our portfolio code to a GitHub remote repository (a place where your code stores on GitHub). Once complete, Code Capsules can connect to the repository and automatically \"deploy\" the portfolio online. Let's create the remote repository now. Creating the remote repository Follow the steps below to create a remote repository on GitHub: Go to www.github.com and log in. Find the \"Create new repository\" button and click it. Name your repository anything (in this picture it was named \"myPortfolio\"). Copy the URL given to you under \"Quick setup\". Locate the link to your repository under \"Quick Setup\" Sending files to the GitHub repository We've created the remote repository \u2013 now we need to push the portfolio to GitHub. Open a terminal and navigate to the top-level directory containing the portfolio. This directory should contain the sub-directory that has all the portfolio files. If your file structure looked like: myPortfolio portFolder + assets + images + generic.html + elements.html + index.html You would open the terminal in the myPortfolio directory. Not the portFolder directory. Enter each command in order: git init git add . git commit -m \"First commit!\" git branch -M main git remote add origin https://github.com/yourusername/yourrepositoryname.git git push -u origin main Replace the URL above with the URL to your remote repository (copied in the previous section). Now you can see the portfolio code in your GitHub repository. Your repository should look similar to the below, where all of your portfolio code is contained in a sub-directory (in this image, the sub-directory is \"portFolder\"): Now Code Capsules can host the portfolio. Deploying to Code Capsules To deploy the portfolio to Code Capsules, navigate to https://codecapsules.io/, create an account, and log in. After logging in, you'll be greeted with a page that looks like the below. Notice the \"Team Personal\" at the top left. Every new account starts with a \"Team Personal\". Code Capsules provides Teams for collaborative development \u2013 you can invite other people to your Team and Team members can view and edit your web-applications. You can create other teams - but the default \"Personal\" team is fine for now. At the center, you'll see a clickable box, labeled \"Personal\". This is called a Space . Spaces act as a further layer of organisation. Spaces can contain one or many Capsules (more on Capsules shortly) and can help organise large projects. We'll take a look at this space soon, but we first need to link Code Capsules to Github. Linking the repository We need to give Code Capsules access to our portfolio. Click on your profile image at the top right of the screen, then find the \"GitHub\" button \u2013 click on it. Code Capsules will redirect you to GitHub. Then: Log in to GitHub. Click your username. Press \"Only select repositories\". From the drop-down menu, type the repository's name containing your portfolio and select it. Press \"Install & Authorize\". Now we can deploy our portfolio. Return back to your Team, and enter the space labeled \"Personal\" Creating Capsule, and viewing the portfolio The last step to deploying the Portfolio is creating a Capsule . Capsules provide the server for your application or code \u2013 in our case, we'll create a Capsule that'll host our portfolio. Click \"Create a new Capsule for your Space\". You'll be prompted to choose a Capsule type \u2013 our portfolio contains only front-end code, so choose a \"Frontend\" Capsule and: Select the \"Trial\" product type. Click the repository containing the portfolio. Press \"Next\". Leave the build command blank and enter the name of the sub-directory containing the portfolio files in the \"Static Content Folder Path\" entry box. Press \"Create Capsule\". Your Capsule is now building. This process will make your portfolio visible online. After it has deployed, click the \"Overview\" tab, then press the link under \"Domains\" to view your portfolio. Conclusion and Further Reading We've created a portfolio, pushed it to GitHub, and made the portfolio visible to the world. In the future, we'll take a look at \"Backend\" capsules. These \"Backend\" capsules will enable us to host back-end code and provide additional functionality \u2013 like implementing the contact form we removed at the beginning of the tutorial. We'll also take a look at customising your domain, so people can view your portfolio by typing something like https://www.myportfolio.co.za If any of the HTML code was confusing, or you'd like to learn more for further customisation, check out this tutorial written by Mozilla. For any help with GitHub, take a look at their documentation .","title":"Front-end Portfolio"},{"location":"tutorials/host-a-frontend/#hosting-a-front-end-building-and-deploying-your-portfolio-to-code-capsules","text":"Publishing your portfolio online requires a solid technical background \u2013 managing servers can be challenging. You need to choose a server's operating system, maintain and update the server, and figure out where to host the server itself. In this tutorial, we'll work with an alternative to the traditional method of hosting a front-end (content that visitors see when they load your website), called Code Capsules . Code Capsules is a service that hosts front-end (and back-end) code online. Furthermore, Code Capsules: Manages all of the technical details \u2013 no server management required. Integrates with GitHub to deploy your code with a single git push . First, we'll take a look at choosing a portfolio template and personalising it. After, we'll push the portfolio to a GitHub repository and see how Code Capsules connects to GitHub and makes your portfolio visible to the world.","title":"Hosting a Front-end: Building and Deploying Your Portfolio to Code Capsules"},{"location":"tutorials/host-a-frontend/#requirements-prerequisite-knowledge","text":"Hosting a portfolio on Code Capsules requires no previous knowledge about servers or front-end development. To personalise a portfolio template and deploy it to Code Capsules, we'll need: A text editor, such as Sublime Text , or VSCode . A registered GitHub account. The Git command-line interface installed.","title":"Requirements &amp; Prerequisite Knowledge"},{"location":"tutorials/host-a-frontend/#creating-a-portfolio","text":"HTML5 UP provides HTML site templates for free. We'll use the Massively template \u2013 an easy to modify and elegant HTML template. Follow these instructions carefully : Download the Massively template. Create a directory somewhere on your computer, then enter it. Within this directory, create another directory, and extract the Massively template files into it . This last step is necessary for hosting a web-page on Code Capsules. The file structure should look something like this: myPortfolio portFolder + assets + images + generic.html + elements.html + index.html The index.html file contains all of the HTML code for our portfolio \u2013 any changes to this code will result in a change to the portfolio. To view changes you make as we begin to modify the template, double click the index.html file to open the portfolio in a web-browser.","title":"Creating a Portfolio"},{"location":"tutorials/host-a-frontend/#personalizing-the-template","text":"This tutorial will following the creation of a portfolio for Abraham Lincoln \u2013 the 16th president of the USA. We'll take a closer look at some things Abraham Lincoln wouldn't want in a portfolio \u2013 and maybe you too. The next few sections will cover how to modify the following elements of the portfolio template: Any not personalized text. The \"Generic Page\" and \"Elements Reference\" tabs. Pagination. The email contact form. Personal information (address, social media account). Let's start with the title and subheading of the portfolio. Open the index.html file in your text editor. You'll see the following block of HTML near the top of the file: < head > < title > Massively by HTML5 UP </ title > < meta charset = \"utf-8\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, user-scalable=no\" /> < link rel = \"stylesheet\" href = \"assets/css/main.css\" /> < noscript >< link rel = \"stylesheet\" href = \"assets/css/noscript.css\" /></ noscript > </ head > Change the text within the <title> tags to whatever you'd like, such as: \"Abraham Lincoln\". This is what will appear in search engines and browser tabs. Now we'll change the text that displays at the top of the portfolio. Scroll down in your text editor, until you see the following code: <!-- Intro --> < div id = \"intro\" > < h1 > This is < br /> Massively </ h1 > < p > A free, fully responsive HTML5 + CSS3 site template designed by < a href = \"https://twitter.com/ajlkn\" > @ajlkn </ a > for < a href = \"https://html5up.net\" > HTML5 UP </ a >< br /> and released for free under the < a href = \"https://html5up.net/license\" > Creative Commons license </ a > . </ p > < ul class = \"actions\" > < li >< a href = \"#header\" class = \"button icon solid solo fa-arrow-down scrolly\" > Continue </ a ></ li > </ ul > </ div > <!-- Header --> < header id = \"header\" > < a href = \"index.html\" class = \"logo\" > Massively </ a > </ header > Customise the words wrapped in the <h1>...</h1> tags \u2013 this is the large text that displays at the top of the portfolio. Change the text within the <p>...</p> tags to edit the subheading of the portfolio \u2013 the <br /> tags and the <a>...</a> tags are safe to delete. Delete the \"Massively\" button that appears as you scroll down the portfolio by deleting the three lines under the <!-- Header --> text wrapped in <header>...</header> tags. Save the file and open it in a web browser. Our portfolio should now look something like this: Next, we'll take a look at deleting the date entries above each portfolio piece, removing the \"Generic Page\" and \"Elements Reference\" tabs, and modifying the social media links.","title":"Personalizing the Template"},{"location":"tutorials/host-a-frontend/#removing-the-tabs-dates-and-links","text":"The default layout for Massively is designed for a blog or news website containing articles. To look like a portfolio, we should delete the dates above each article entry. Do so by locating and deleting all lines beginning with <span class=\"date\"...> . To make this a single-page portfolio, we can delete the \"Generic Page\" and \"Elements Reference\" tabs by finding: < li class = \"active\" >< a href = \"index.html\" > This is Massively </ a ></ li > < li >< a href = \"generic.html\" > Generic Page </ a ></ li > < li >< a href = \"elements.html\" > Elements Reference </ a ></ li > and deleting the last two lines. While we're at it, alter the title of the main tab by changing the \"This is Massively\" text. The code for social media accounts is located at the top and bottom of the index.html file. Starting at the top, find this block of code: < ul class = \"icons\" > < li >< a href = \"#\" class = \"icon brands fa-twitter\" >< span class = \"label\" > Twitter </ span ></ a ></ li > < li >< a href = \"#\" class = \"icon brands fa-facebook-f\" >< span class = \"label\" > Facebook </ span ></ a ></ li > < li >< a href = \"#\" class = \"icon brands fa-instagram\" >< span class = \"label\" > Instagram </ span ></ a ></ li > < li >< a href = \"#\" class = \"icon brands fa-github\" >< span class = \"label\" > GitHub </ span ></ a ></ li > </ ul > Delete any social media account you don't need \u2013 Abraham Lincoln doesn't have Instagram, so he would delete the following line to remove the Instagram link: < li >< a href = \"#\" class = \"icon brands fa-instagram\" >< span class = \"label\" > Instagram </ span ></ a ></ li > If you'd like to link your social media accounts, enter the account link in place of the # in href=\"#\" . For example, to link Abraham Lincoln's Twitter account, you'd edit the Twitter line like so: < li >< a href = \"https://twitter.com/Abe_Lincoln\" class = \"icon brands fa-twitter\" >< span class = \"label\" > Twitter </ span ></ a ></ li > The social media code at the bottom of the index.html is nearly identical \u2013 follow this same process to edit the code at the bottom.","title":"Removing the tabs, dates, and links"},{"location":"tutorials/host-a-frontend/#removing-unnecessary-content-and-further-personalisation","text":"In this section we'll: Remove the contact form Remove pagination Update or remove contact information 1.Remove the contact form found at the bottom of the portfolio by deleting the following code: < section > < form method = \"post\" action = \"#\" > < div class = \"fields\" > < div class = \"field\" > < label for = \"name\" > Name </ label > < input type = \"text\" name = \"name\" id = \"name\" /> </ div > < div class = \"field\" > < label for = \"email\" > Email </ label > < input type = \"text\" name = \"email\" id = \"email\" /> </ div > < div class = \"field\" > < label for = \"message\" > Message </ label > < textarea name = \"message\" id = \"message\" rows = \"3\" ></ textarea > </ div > </ div > < ul class = \"actions\" > < li >< input type = \"submit\" value = \"Send Message\" /></ li > </ ul > </ form > </ section > 2.Remove pagination by deleting: < footer > < div class = \"pagination\" > <!--<a href=\"#\" class=\"previous\">Prev</a>--> < a href = \"#\" class = \"page active\" > 1 </ a > < a href = \"#\" class = \"page\" > 2 </ a > < a href = \"#\" class = \"page\" > 3 </ a > < span class = \"extra\" > &hellip; </ span > < a href = \"#\" class = \"page\" > 8 </ a > < a href = \"#\" class = \"page\" > 9 </ a > < a href = \"#\" class = \"page\" > 10 </ a > < a href = \"#\" class = \"next\" > Next </ a > </ div > </ footer > 3.To delete specific contact information sections (the address section is shown below), delete the <section> tag, the information you want to delete, and the corresponding </section> tag. < section class = \"alt\" > < h3 > Address </ h3 > < p > 1234 Somewhere Road #87257 < br /> Nashville, TN 00000-0000 </ p > </ section > If you'd like to personalise your contact information instead, edit the text within the <h3>...</h3> tags and the <p>...</p> tags.","title":"Removing unnecessary content and further personalisation"},{"location":"tutorials/host-a-frontend/#personalising-portfolio-pieces","text":"Our portfolio is almost complete \u2013 we just need to personalise the actual portfolio pieces \u2013 customising the images, button links, and other text. Let's start with the images. Gather any images you'd like to replace with the default images. Then, place your images in the images directory, located in the same directory as the index.html file. You can swap images by finding lines wrapped in <img.../> tags, like the below line. < img src = \"images/pic01.jpg\" alt = \"\" /> images is the name of the directory where you placed your image. To change the image, replace the text \"pic01.jpg\" with the name and file extension of your desired image. Once we've replaced the images, we should change the text for each portfolio entry. Find code blocks wrapped in <article>...</article> tags, such as: < article > < header > < h2 >< a href = \"#\" > Sed magna < br /> ipsum faucibus </ a ></ h2 > </ header > < a href = \"#\" class = \"image fit\" >< img src = \"images/pic02.jpg\" alt = \"\" /></ a > < p > Donec eget ex magna. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque venenatis dolor imperdiet dolor mattis sagittis magna etiam. </ p > < ul class = \"actions special\" > < li >< a href = \"#\" class = \"button\" > Full Story </ a ></ li > </ ul > </ article > You can: Change the entry's title by editing the text within the <h2>...</h2> tags. Personalise the entry text by editing the Latin wrapped in the <p>...</p> tags. Customise buttons by finding the <li><a href=\"#\" class=\"button\">Full Story</a></li> lines and replacing the \"#\" with a link to your portfolio piece. Replace \"Full Story\" text with something more appropriate. If you would like to remove a portfolio piece, delete the <article>...</article> tags and all the text wrapped in the tags. Once finished with the portfolio, we need to push it to GitHub. After, the portfolio can be deployed to Code Capsules, making the portfolio publicly viewable.","title":"Personalising portfolio pieces"},{"location":"tutorials/host-a-frontend/#uploading-to-github","text":"If you already know how to push code from a local repository to a remote repository on GitHub, push the sub-directory containing the portfolio to GitHub and skip to the next section. Otherwise, we'll push (or send) our portfolio code to a GitHub remote repository (a place where your code stores on GitHub). Once complete, Code Capsules can connect to the repository and automatically \"deploy\" the portfolio online. Let's create the remote repository now.","title":"Uploading to GitHub"},{"location":"tutorials/host-a-frontend/#creating-the-remote-repository","text":"Follow the steps below to create a remote repository on GitHub: Go to www.github.com and log in. Find the \"Create new repository\" button and click it. Name your repository anything (in this picture it was named \"myPortfolio\"). Copy the URL given to you under \"Quick setup\". Locate the link to your repository under \"Quick Setup\"","title":"Creating the remote repository"},{"location":"tutorials/host-a-frontend/#sending-files-to-the-github-repository","text":"We've created the remote repository \u2013 now we need to push the portfolio to GitHub. Open a terminal and navigate to the top-level directory containing the portfolio. This directory should contain the sub-directory that has all the portfolio files. If your file structure looked like: myPortfolio portFolder + assets + images + generic.html + elements.html + index.html You would open the terminal in the myPortfolio directory. Not the portFolder directory. Enter each command in order: git init git add . git commit -m \"First commit!\" git branch -M main git remote add origin https://github.com/yourusername/yourrepositoryname.git git push -u origin main Replace the URL above with the URL to your remote repository (copied in the previous section). Now you can see the portfolio code in your GitHub repository. Your repository should look similar to the below, where all of your portfolio code is contained in a sub-directory (in this image, the sub-directory is \"portFolder\"): Now Code Capsules can host the portfolio.","title":"Sending files to the GitHub repository"},{"location":"tutorials/host-a-frontend/#deploying-to-code-capsules","text":"To deploy the portfolio to Code Capsules, navigate to https://codecapsules.io/, create an account, and log in. After logging in, you'll be greeted with a page that looks like the below. Notice the \"Team Personal\" at the top left. Every new account starts with a \"Team Personal\". Code Capsules provides Teams for collaborative development \u2013 you can invite other people to your Team and Team members can view and edit your web-applications. You can create other teams - but the default \"Personal\" team is fine for now. At the center, you'll see a clickable box, labeled \"Personal\". This is called a Space . Spaces act as a further layer of organisation. Spaces can contain one or many Capsules (more on Capsules shortly) and can help organise large projects. We'll take a look at this space soon, but we first need to link Code Capsules to Github.","title":"Deploying to Code Capsules"},{"location":"tutorials/host-a-frontend/#linking-the-repository","text":"We need to give Code Capsules access to our portfolio. Click on your profile image at the top right of the screen, then find the \"GitHub\" button \u2013 click on it. Code Capsules will redirect you to GitHub. Then: Log in to GitHub. Click your username. Press \"Only select repositories\". From the drop-down menu, type the repository's name containing your portfolio and select it. Press \"Install & Authorize\". Now we can deploy our portfolio. Return back to your Team, and enter the space labeled \"Personal\"","title":"Linking the repository"},{"location":"tutorials/host-a-frontend/#creating-capsule-and-viewing-the-portfolio","text":"The last step to deploying the Portfolio is creating a Capsule . Capsules provide the server for your application or code \u2013 in our case, we'll create a Capsule that'll host our portfolio. Click \"Create a new Capsule for your Space\". You'll be prompted to choose a Capsule type \u2013 our portfolio contains only front-end code, so choose a \"Frontend\" Capsule and: Select the \"Trial\" product type. Click the repository containing the portfolio. Press \"Next\". Leave the build command blank and enter the name of the sub-directory containing the portfolio files in the \"Static Content Folder Path\" entry box. Press \"Create Capsule\". Your Capsule is now building. This process will make your portfolio visible online. After it has deployed, click the \"Overview\" tab, then press the link under \"Domains\" to view your portfolio.","title":"Creating Capsule, and viewing the portfolio"},{"location":"tutorials/host-a-frontend/#conclusion-and-further-reading","text":"We've created a portfolio, pushed it to GitHub, and made the portfolio visible to the world. In the future, we'll take a look at \"Backend\" capsules. These \"Backend\" capsules will enable us to host back-end code and provide additional functionality \u2013 like implementing the contact form we removed at the beginning of the tutorial. We'll also take a look at customising your domain, so people can view your portfolio by typing something like https://www.myportfolio.co.za If any of the HTML code was confusing, or you'd like to learn more for further customisation, check out this tutorial written by Mozilla. For any help with GitHub, take a look at their documentation .","title":"Conclusion and Further Reading"},{"location":"tutorials/stripe-checkout-and-email-with-flask/","text":"Adding Functionality to Your Web Application: Setting up Stripe Checkout and Email Subscription with Flask and Code Capsules What We'll Cover Constructing a frontend for your web application is the first step towards providing an interactive user experience. The next step is building a working backend, or making your web application functional. Buttons are nice to have, but it's more interesting to have those buttons do something. That's what we'll focus on today. Through a step-by-step process, we'll develop this functionality. We'll use Flask and a frontend template to create a web application that allows users to buy products through Stripe Checkout (a tool for creating a \"checkout\" process for products) and subscribe to an email list with help from the Mailgun email API service. Then, we'll host the web application on Code Capsules so people around the world can buy your product and subscribe to your mailing list. Requirements To successfully complete this project, we'll need: A text editor (like Sublime or VSCode ) installed. Python 3.XX+ installed. Virtualenv installed. Git installed and a GitHub account. A Code Capsules account. Setting Up the Frontend We'll use the Laurel frontend template from https://cruip.com to add our functionality. This template is perfect for our project \u2013 there is already an email subscription box that just needs to be implemented and, with a few modifications, we'll implement a \"Buy Now\" button. After downloading the Laurel template: Create a directory named project . Within the project directory, create a sub-directory named templates . Open the downloaded template and extract the files within the laurel directory into the templates subdirectory. You can view the template by opening the index.html file in the templates subdirectory. We'll change the first \"Early access\" button to \"Buy Now\" and implement Stripe Checkout functionality for it. Then we'll change the second \"Early access\" button at the bottom of the template to \"Subscribe\", and implement the email subscription functionality for it. First, let's change the \"Early access\" button texts. Modifying the \"Early access\" text We'll start with changing the first \"Early access\" button to \"Buy Now\". Open the index.html file in a text editor. Find this line: < div class = \"hero-cta\" >< a class = \"button button-shadow\" href = \"#\" > Learn more </ a >< a class = \"button button-primary button-shadow\" href = \"#\" > Early access </ a ></ div > Replace it with: < div class = \"hero-cta\" > < a class = \"button button-shadow\" href = \"#\" > Learn more </ a > < a id = \"checkout-button\" class = \"button button-primary button-shadow\" href = \"#\" > Buy Now </ a > </ div > As well as changing \"Early access\" to \"Buy Now\", we've added [SOMETHING?], and given it an ID with id=\"checkout-button\" . This will be useful when implementing Stripe Checkout. Next, find this line: < a class = \"button button-primary button-block button-shadow\" href = \"#\" > Early access </ a > Replace \"Early access\" with \"Subscribe\". View the changes by saving the index.html file and re-opening it in a web browser. We have one more task before building our Flask backend. Project directory restructuring To make a functional web application out of our template, Flask requires a specific directory structure, so we will need to reorganise the project directory. To do this: Create a new directory named static in the project directory. Navigate to the templates directory and then the dist directory. Copy all of the directories located in dist into the static directory that we created above. Your project file structure should look like this: project static css + style.css images + iphone-mockup.png js + main.min.js templates This was necessary because Flask strictly serves CSS, JavaScript, and images from the static directory, and renders HTML files in the templates directory. Because we've moved our template's files around, we now need to edit our index.html file to point to their new locations. Flask uses the Jinja templating library to allow us to embed backend code in HTML. This code will be executed on the webserver before a given page is served to the user, allowing us to give that page dynamic functionality and make it responsive to user input. The first thing we will use Jinja templating for is to dynamically locate and load our index.html file's stylesheet. Open the index.html file in the templates folder and find this line: < link rel = \"stylesheet\" href = \"dist/css/style.css\" > Replace the value of href with the string below. < link rel = \"stylesheet\" href = \"{{url_for('static',filename='css/style.css')}}\" > In Jinja, anything between {{ and }} is server-side code that will be evaluated before the page is served to users, i.e. when it is rendered . In this way, we can include the output of Python functions and the values of Python variables in our HTML. Jinja syntax is similar to Python, but not identical. In the Jinja code above, we're calling the function url_for() , which asks Flask to find the location of our style.css file in our static directory. Speaking of Flask, we're almost ready to implement our functionality. Setting Up the Virtual Environment We'll create a virtual environment for our project. The virtual environment will be useful later on when we host our web application on Code Capsules, as it will ensure that the Python libraries we use for development are installed in the Capsule. To create a virtual environment, navigate to the project directory in a terminal and enter virtualenv env . Activate the virtual environment with: Linux/MacOSX : source env/bin/activate Windows : \\env\\Scripts\\activate.bat If the virtual environment has activated correctly, you'll notice (env) to the left of your name in the terminal. Keep this terminal open \u2013 we'll install the project requirements next. Installing the requirements For our project, we'll use the following libraries: Flask is a lightweight Python web development framework. Gunicorn is the WSGI server we'll use to host our application on Code Capsules. Requests is a Python library that allows us to send HTTP requests . Stripe is another Python library that will help us interact with the Stripe API . Install these by entering the command below in the virtual environment. pip3 install flask gunicorn requests stripe Now we can build the backend for our web application. Creating the Flask Application In the projects folder, create a new file named app.py . This file will contain all of our Flask code. Open the app.py file in a text editor and enter the following: from flask import Flask , render_template , request import requests , stripe app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" , \"POST\" ]) def index (): return render_template ( \"index.html\" ) if __name__ == '__main__' : app . run ( debug = True ) We import the following functions from flask : Flask , which provides the Flask application object. render_template() , which will render our index.html file. request , an object which contains any information sent to our web application \u2013 later this will be used to retrieve the email address entered in our subscription box. Be careful not to confuse this with the requests library. The index function has a route decorator which causes it to execute when Flask receives an HTTP GET or POST request for the \"/\" URL, i.e. when someone navigates to the website's domain or IP address in a browser. When render_template(\"index.html\") runs, Flask will look in the templates directory for a file named index.html and render it by executing its Jinja template code and serving the resulting HTML. To see this, run app.py with flask run in your terminal. Open the provided IP address in your browser \u2013 the web application should look like this: Let's make this web application useful and implement the first bit of functionality \u2013 the email list feature. Signing up for Mailgun We'll use Mailgun to handle our email subscriber list. Mailgun is free up to 5,000 emails per month. Register with Mailgun and continue. With an account registered, create a mailing list by doing the following: Log in to Mailgun. Click \"Sending\" then \"Mailing lists\" on the dashboard. At the top right, click \"Create mailing list\". Enter whatever you'd like for the address prefix, name, and description \u2013 leave everything else default. Click \"Add mailing list\". Navigate to the mailing list we just created. You'll see something called an alias address \u2013 Mailgun provides every new mailing list with one. When you send an email to your alias address, Mailgun sends a copy of the email to everyone who is subscribed to your mailing list. Jot down your alias address, we'll use it soon. Next, you'll need to retrieve the API key for your Mailgun account. We'll use this API key in our web application to validate your Mailgun account when people subscribe to your mailing list. Find the API key by clicking on your account at the top right of the screen. Click \"API keys\", and make a note of your private API key. Implementing the Subscribe Button With the mailing list created, we can implement the subscribe button. Re-open the index.html file. At the bottom of the file, find the line: < section class = \"newsletter section\" > From the above line down to its corresponding </section> tag, replace all of the markup with the following: < section class = \"newsletter section\" > < div class = \"container-sm\" > < div class = \"newsletter-inner section-inner\" > < div class = \"newsletter-header text-center\" > < h2 class = \"section-title mt-0\" > Stay in the know </ h2 > < p class = \"section-paragraph\" > Lorem ipsum is common placeholder text used to demonstrate the graphic elements of a document or visual presentation. </ p > </ div > < form method = \"POST\" > < div class = \"footer-form newsletter-form field field-grouped\" > < div class = \"control control-expanded\" > < input class = \"input\" type = \"email\" name = \"email\" placeholder = \"Your best email&hellip;\" > </ div > < div class = \"control\" > < button class = \"button button-primary button-block button-shadow\" type = \"submit\" > Subscribe </ a > </ div > </ div > </ form > </ div > </ div > </ section > The important part of this HTML for our functionality is the form tag. Let's take a closer look at it. < form method = \"POST\" > < div class = \"footer-form newsletter-form field field-grouped\" > < div class = \"control control-expanded\" > < input class = \"input\" type = \"email\" name = \"email\" placeholder = \"Your best email&hellip;\" > </ div > < div class = \"control\" > < button class = \"button button-primary button-block button-shadow\" type = \"submit\" > Subscribe </ a > </ div > </ div > </ form > This contains one input , for the user's email address, and a button for submitting that email address. When the user clicks on the button, an HTTP request will be sent from their browser to our Flask backend, containing the email address. As per the method attribute of the form tag, this will be a [POST request. Recall that the Python code we entered in the last section provided for both GET and POST HTTP requests. As submitting this form will also send a request to \"/\", we can differentiate between a user browsing to our website ( GET ) and subscribing to our mailing list ( POST ) by looking at the HTTP method. We'll do that in the next section. Subscribe functionality in Flask Return to the app.py file. Find this line: @app . route ( \"/\" , methods [ \"GET\" , \"POST\" ]) Just above it, enter this code: def subscribe ( user_email , email_list , api_key ): return requests . post ( \"https://api.mailgun.net/v3/lists/\" + email_list + \"/members\" , auth = ( 'api' , api_key ), data = { 'subscribed' : True , 'address' : user_email ,}) This function is called when a user clicks the \"Subscribe\" button. It takes three arguments: user_email : The email the user has entered. email_list : Your Mailgun alias address. api_key : Your Mailgun secret API key. The real logic is contained in the return line. Here, we use requests.post() to add the user_email to our email_list , by sending (or \"posting\") all of the values in data to Mailgun's email list API . Next, modify the current index() function like below, replacing MAILGUN_ALIAS and YOUR-MAILGUN-PRIVATE-KEY with the email alias and private API key we previously retrieved: @app . route ( \"/\" , methods [ \"GET\" , \"POST\" ]) def index (): if request . method == \"POST\" : user_email = request . form . get ( 'email' ) response = subscribe ( user_email , 'MAILGUN_ALIAS' , 'YOUR-MAILGUN-PRIVATE-KEY' ) return render_template ( \"index.html\" ) In the previous section , we added the POST method to the subscribe button. We will therefor know when someone has clicked the subscribe button with the line: if request . method == \"POST\" : If they've clicked the subscribe button, we obtain the email they entered by referencing the relevant input field's name attribute in request.form.get , and adding the email to the mailing list our subscribe method. Try it out: enter an email address and hit \"Subscribe\". Navigate back to the \"Mailing lists\" tab on Mailgun and click on the list we created. You will find the email address you just submitted under \"Recipients\". All that's left is to add functionality to our \"Buy Now\" button. Implementing \"Buy Now\" with Stripe Checkout Stripe Checkout allows business owners to accept payments on their web applications. Let's create an account . After creating an account, log in and find your API keys by clicking \"Developers\" then \"API keys\" on the dashboard. Here we'll see two API keys \u2013 a publishable API key, and a secret API key. You can think of these as a username and password. Stripe uses the publishable API key to identify your account, and the secret API key to ensure it's really you using it. Open the app.py file. Above the subscribe function, add the following lines, replacing YOUR PUBLISHABLE KEY HERE and YOUR SECRET KEY HERE appropriately: app . config [ 'STRIPE_PUBLISH_KEY' ] = 'YOUR PUBLISHABLE KEY HERE' app . config [ 'STRIPE_SECRET_KEY' ] = 'YOUR SECRET KEY HERE' stripe . api_key = app . config [ 'STRIPE_SECRET_KEY' ] In thid code, we place the two Stripe keys in our Flask app's configuration settings for ease of access, then set our Stripe secret API key. These are test API keys that we'll use to check out our product. With these keys, no charges will be incurred when making payments. However, before we can make a payment, we need a product, so let's create one. Return to Stripe, log in, and navigate to the \"Products\" tab on the dashboard. Creating a product Create a product by doing the following: Click \"Add product\" on the top right. Name the product. Add a description and price. Choose \"One time\" payment. Click \"Save product\" After the last step, save the API key found in the \"Pricing\" section. We'll use this API key to tell Stripe which product we want our customers to pay for. Adding functionality in Flask Time to create the \"Buy Now\" button logic. Open app.py again and modify the index function accordingly. Replace \"YOUR-PRICE-API-KEY\" with the API key for your product, that we saved in the previous section. @app . route ( \"/\" , methods = [ \"GET\" , \"POST\" ]) def index (): session = stripe . checkout . Session . create ( payment_method_types = [ 'card' ], mode = 'payment' , success_url = 'https://example.com/success' , cancel_url = 'https://example.com/cancel' , line_items = [{ 'price' : 'YOUR-PRICE-API-KEY' , 'quantity' : 1 , }] ) if request . method == \"POST\" : user_email = request . form . get ( 'email' ) response = subscribe ( user_email , 'MAILGUN_ALIAS' , 'YOUR-MAILGUN-PRIVATE-KEY' ) return render_template ( \"index.html\" , checkout_id = session [ 'id' ], checkout_pk = app . config [ 'STRIPE_PK' ], ) We use the stripe library to create a new \"Session\" object. This object contains multiple variables affecting how our customers interact with the \"Buy Now\" button. For more information on these variables, see Stripe's documentation . We also return two new variables \u2013 checkout_id and checkout_pk . checkout_id , which we get from Stripe, stores information about the potential purchase (price, payment type, etc). checkout_pk stores our private API key, which we added to the Flask app's configuration settings above. When a customer buys our product, their money is sent to the account associated with this private API key. Let's see how our HTML will use these new variables and redirect us to the Stripe Checkout page. \"Buy Now\" button functionality in the HTML file With our Flask logic finished, we can implement the \"Buy Now\" button functionality in our index.html file. Open the index.html and find this section: < div class = \"hero-copy\" > < h1 class = \"hero-title mt-0\" > Landing template for startups </ h1 > < p class = \"hero-paragraph\" > Our landing page template works on all devices, so you only have to set it up once, and get beautiful results forever. </ p > < div class = \"hero-cta\" >< a class = \"button button-shadow\" href = \"#\" > Learn more </ a >< a id = 'checkout-button' class = \"button button-primary button-shadow\" href = \"#\" > Buy Now </ a ></ div > </ div > Directly below the </div> line, add: < script src = \"https://js.stripe.com/v3/\" ></ script > < script > const checkout_pk = '{{checkout_pk}}' ; const checkout_id = '{{checkout_id}}' ; var stripe = Stripe ( checkout_pk ) const button = document . querySelector ( '#checkout-button' ) button . addEventListener ( 'click' , event =>{ stripe . redirectToCheckout ({ sessionId : checkout_id }). then ( function ( result ){ }); }) </ script > This code adds a JavaScript event which will trigger when the customer clicks the \"Buy Now\" button, and will redirect them to the Stripe Checkout page. The Stripe Checkout page changes according to the information stored in checkout_id . Also, take a look at the Jinja code in these lines: const checkout_pk = '{{checkout_pk}}' ; const checkout_id = '{{checkout_id}}' ; When the index.html template is rendered before being served to the user, Flask will substitute in the current values of the Python variables that we passed to render_template() . While checkout_pk will remain the same throughout, checkout_id will be unique for each purchase. The \"Buy Now\" button is good to go \u2013 run app.py again. Try making a payment using the test credit card number 4242 4242 4242 4242 with any name, expiration date, and security code. No charges will be incurred. Hosting the Application on Code Capsules Now that we've added all the functionality, we need to create some files that Code Capsules will use when hosting our application. We'll also take a look at a security problem in our current application, and how to fix it before we go live. Creating the \"requirements.txt\" file and procfile To host this application on Code Capsules, we need to create a requirements.txt file and a Procfile . In the project directory, ensure the virtual environment is activated and then enter pip3 freeze > requirements.txt . Create another file named Procfile , containg the line web: gunicorn app:app . With the requirements.txt file, Code Capsules will now know what libraries to install to run the application. The Procfile tells Code Capsules to use the gunicorn WSGI server to serve HTML rendered by Flask to end-users. Now we can fix that security problem mentioned before, and host the application. Removing secret keys We need to send our application to GitHub so Code Capsules can host it. But currently this project's code contains all of our API keys. It is considered very poor practice to send personal API keys to GitHub, especially public repositories. Anyone could find them and incur charges on your debit card. Luckily, there is a workaround. By working with environment variables , we can use our API keys on Code Capsules without exposing them on GitHub. We will alter our application to retrieve our API keys from environment variables, which we will set on Code Capsules. To do this, change the code at the top of app.py as follows: from flask import Flask , render_template , request import requests , stripe , os app = Flask ( __name__ ) app . config [ 'STRIPE_PK' ] = os . getenv ( \"STRIPE_PK\" ) app . config [ 'STRIPE_SK' ] = os . getenv ( \"STRIPE_SK\" ) stripe . api_key = app . config [ 'STRIPE_SK' ] Notice that we've imported a new Python module, os , which allows us to retrieve with environment variables using the os.getenv() method. We've now done this with our Stripe publishable and secret API keys and our Mailgun secret key. On Code Capsules, we'll set environment variables named 'STRIPE_PK' , 'STRIPE_SK' , and 'MAILGUN_SK' . This way, our API keys do not have to be stored on GitHub and will remain secret. Notice, we aren't adding environment variables for the Stripe product API key. This doesn't contain any sensitive information. It just displays a product's price. Your final app.py code should look like this: from flask import Flask , render_template , request import requests , stripe , os app = Flask ( __name__ ) app . config [ 'STRIPE_PK' ] = os . getenv ( \"STRIPE_PK\" ) app . config [ 'STRIPE_SK' ] = os . getenv ( \"STRIPE_SK\" ) stripe . api_key = app . config [ 'STRIPE_SK' ] def subscribe ( user_email , email_list , api_key ): return requests . post ( \"https://api.mailgun.net/v3/lists/\" + email_list + \"/members\" , auth = ( 'api' , api_key ), data = { 'subscribed' : True , 'address' : user_email ,}) @app . route ( \"/\" , methods = [ \"GET\" , \"POST\" ]) def index (): session = stripe . checkout . Session . create ( payment_method_types = [ 'card' ], mode = 'payment' , success_url = 'https://example.com/success' , cancel_url = 'https://example.com/cancel' , line_items = [{ 'price' : 'YOUR-PRICE-API-KEY' , 'quantity' : 1 , }] ) if request . method == \"POST\" : user_email = request . form . get ( 'email' ) response = subscribe ( user_email , 'MAILGUN_ALIAS' , os . getenv ( \"MAILGUN_SK\" )) return render_template ( \"index.html\" , checkout_id = session [ 'id' ], checkout_pk = app . config [ 'STRIPE_PK' ], ) if __name__ == '__main__' : app . run ( debug = True ) We can now safely host our application. Pushing to GitHub and hosting the application on Code Capsules Before we create the Capsule that will host our code, take the following steps: Create a GitHub repository for the application. Send all code within the project directory to the repository on GitHub. Log in to Code Capsules . Grant Code Capsules access to the repository. Create a Team and Space as necessary. Now let's create the Capsule: Click \"Create A New Capsule\". Select your repository. Choose the Backend Capsule type. Create the Capsule. All that's left is to set the environment variables. Navigate to the Capsule and click on the \"Config\" tab. Use the image below as a guide to properly add your environment variables. Replace each value with the appropriate API key. After entering the API keys, make sure to click \"Update\" . All done \u2013 now anyone can view the web application and interact with the \"Buy Now\" and \"Subscribe\" buttons. Further Reading We covered a lot in this tutorial: how to use Flask to implement functionality for frontend code, how to set up an email subscriber list, and how to work with Stripe. Earlier I mentioned more information on the url_for() function. Check out Flask's documentation for more information. For further information on how Jinja templates work and what can be done with them, check out this link to learn more about Flask templating and Jinja2 . Now that you have a functional email subscriber list, you may be interested in sending emails to your list .","title":"Stripe Checkout and Email Subscription with Flask"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#adding-functionality-to-your-web-application-setting-up-stripe-checkout-and-email-subscription-with-flask-and-code-capsules","text":"","title":"Adding Functionality to Your Web Application: Setting up Stripe Checkout and Email Subscription with Flask and Code Capsules"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#what-well-cover","text":"Constructing a frontend for your web application is the first step towards providing an interactive user experience. The next step is building a working backend, or making your web application functional. Buttons are nice to have, but it's more interesting to have those buttons do something. That's what we'll focus on today. Through a step-by-step process, we'll develop this functionality. We'll use Flask and a frontend template to create a web application that allows users to buy products through Stripe Checkout (a tool for creating a \"checkout\" process for products) and subscribe to an email list with help from the Mailgun email API service. Then, we'll host the web application on Code Capsules so people around the world can buy your product and subscribe to your mailing list.","title":"What We'll Cover"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#requirements","text":"To successfully complete this project, we'll need: A text editor (like Sublime or VSCode ) installed. Python 3.XX+ installed. Virtualenv installed. Git installed and a GitHub account. A Code Capsules account.","title":"Requirements"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#setting-up-the-frontend","text":"We'll use the Laurel frontend template from https://cruip.com to add our functionality. This template is perfect for our project \u2013 there is already an email subscription box that just needs to be implemented and, with a few modifications, we'll implement a \"Buy Now\" button. After downloading the Laurel template: Create a directory named project . Within the project directory, create a sub-directory named templates . Open the downloaded template and extract the files within the laurel directory into the templates subdirectory. You can view the template by opening the index.html file in the templates subdirectory. We'll change the first \"Early access\" button to \"Buy Now\" and implement Stripe Checkout functionality for it. Then we'll change the second \"Early access\" button at the bottom of the template to \"Subscribe\", and implement the email subscription functionality for it. First, let's change the \"Early access\" button texts.","title":"Setting Up the Frontend"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#modifying-the-early-access-text","text":"We'll start with changing the first \"Early access\" button to \"Buy Now\". Open the index.html file in a text editor. Find this line: < div class = \"hero-cta\" >< a class = \"button button-shadow\" href = \"#\" > Learn more </ a >< a class = \"button button-primary button-shadow\" href = \"#\" > Early access </ a ></ div > Replace it with: < div class = \"hero-cta\" > < a class = \"button button-shadow\" href = \"#\" > Learn more </ a > < a id = \"checkout-button\" class = \"button button-primary button-shadow\" href = \"#\" > Buy Now </ a > </ div > As well as changing \"Early access\" to \"Buy Now\", we've added [SOMETHING?], and given it an ID with id=\"checkout-button\" . This will be useful when implementing Stripe Checkout. Next, find this line: < a class = \"button button-primary button-block button-shadow\" href = \"#\" > Early access </ a > Replace \"Early access\" with \"Subscribe\". View the changes by saving the index.html file and re-opening it in a web browser. We have one more task before building our Flask backend.","title":"Modifying the \"Early access\" text"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#project-directory-restructuring","text":"To make a functional web application out of our template, Flask requires a specific directory structure, so we will need to reorganise the project directory. To do this: Create a new directory named static in the project directory. Navigate to the templates directory and then the dist directory. Copy all of the directories located in dist into the static directory that we created above. Your project file structure should look like this: project static css + style.css images + iphone-mockup.png js + main.min.js templates This was necessary because Flask strictly serves CSS, JavaScript, and images from the static directory, and renders HTML files in the templates directory. Because we've moved our template's files around, we now need to edit our index.html file to point to their new locations. Flask uses the Jinja templating library to allow us to embed backend code in HTML. This code will be executed on the webserver before a given page is served to the user, allowing us to give that page dynamic functionality and make it responsive to user input. The first thing we will use Jinja templating for is to dynamically locate and load our index.html file's stylesheet. Open the index.html file in the templates folder and find this line: < link rel = \"stylesheet\" href = \"dist/css/style.css\" > Replace the value of href with the string below. < link rel = \"stylesheet\" href = \"{{url_for('static',filename='css/style.css')}}\" > In Jinja, anything between {{ and }} is server-side code that will be evaluated before the page is served to users, i.e. when it is rendered . In this way, we can include the output of Python functions and the values of Python variables in our HTML. Jinja syntax is similar to Python, but not identical. In the Jinja code above, we're calling the function url_for() , which asks Flask to find the location of our style.css file in our static directory. Speaking of Flask, we're almost ready to implement our functionality.","title":"Project directory restructuring"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#setting-up-the-virtual-environment","text":"We'll create a virtual environment for our project. The virtual environment will be useful later on when we host our web application on Code Capsules, as it will ensure that the Python libraries we use for development are installed in the Capsule. To create a virtual environment, navigate to the project directory in a terminal and enter virtualenv env . Activate the virtual environment with: Linux/MacOSX : source env/bin/activate Windows : \\env\\Scripts\\activate.bat If the virtual environment has activated correctly, you'll notice (env) to the left of your name in the terminal. Keep this terminal open \u2013 we'll install the project requirements next.","title":"Setting Up the Virtual Environment"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#installing-the-requirements","text":"For our project, we'll use the following libraries: Flask is a lightweight Python web development framework. Gunicorn is the WSGI server we'll use to host our application on Code Capsules. Requests is a Python library that allows us to send HTTP requests . Stripe is another Python library that will help us interact with the Stripe API . Install these by entering the command below in the virtual environment. pip3 install flask gunicorn requests stripe Now we can build the backend for our web application.","title":"Installing the requirements"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#creating-the-flask-application","text":"In the projects folder, create a new file named app.py . This file will contain all of our Flask code. Open the app.py file in a text editor and enter the following: from flask import Flask , render_template , request import requests , stripe app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"GET\" , \"POST\" ]) def index (): return render_template ( \"index.html\" ) if __name__ == '__main__' : app . run ( debug = True ) We import the following functions from flask : Flask , which provides the Flask application object. render_template() , which will render our index.html file. request , an object which contains any information sent to our web application \u2013 later this will be used to retrieve the email address entered in our subscription box. Be careful not to confuse this with the requests library. The index function has a route decorator which causes it to execute when Flask receives an HTTP GET or POST request for the \"/\" URL, i.e. when someone navigates to the website's domain or IP address in a browser. When render_template(\"index.html\") runs, Flask will look in the templates directory for a file named index.html and render it by executing its Jinja template code and serving the resulting HTML. To see this, run app.py with flask run in your terminal. Open the provided IP address in your browser \u2013 the web application should look like this: Let's make this web application useful and implement the first bit of functionality \u2013 the email list feature.","title":"Creating the Flask Application"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#signing-up-for-mailgun","text":"We'll use Mailgun to handle our email subscriber list. Mailgun is free up to 5,000 emails per month. Register with Mailgun and continue. With an account registered, create a mailing list by doing the following: Log in to Mailgun. Click \"Sending\" then \"Mailing lists\" on the dashboard. At the top right, click \"Create mailing list\". Enter whatever you'd like for the address prefix, name, and description \u2013 leave everything else default. Click \"Add mailing list\". Navigate to the mailing list we just created. You'll see something called an alias address \u2013 Mailgun provides every new mailing list with one. When you send an email to your alias address, Mailgun sends a copy of the email to everyone who is subscribed to your mailing list. Jot down your alias address, we'll use it soon. Next, you'll need to retrieve the API key for your Mailgun account. We'll use this API key in our web application to validate your Mailgun account when people subscribe to your mailing list. Find the API key by clicking on your account at the top right of the screen. Click \"API keys\", and make a note of your private API key.","title":"Signing up for Mailgun"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#implementing-the-subscribe-button","text":"With the mailing list created, we can implement the subscribe button. Re-open the index.html file. At the bottom of the file, find the line: < section class = \"newsletter section\" > From the above line down to its corresponding </section> tag, replace all of the markup with the following: < section class = \"newsletter section\" > < div class = \"container-sm\" > < div class = \"newsletter-inner section-inner\" > < div class = \"newsletter-header text-center\" > < h2 class = \"section-title mt-0\" > Stay in the know </ h2 > < p class = \"section-paragraph\" > Lorem ipsum is common placeholder text used to demonstrate the graphic elements of a document or visual presentation. </ p > </ div > < form method = \"POST\" > < div class = \"footer-form newsletter-form field field-grouped\" > < div class = \"control control-expanded\" > < input class = \"input\" type = \"email\" name = \"email\" placeholder = \"Your best email&hellip;\" > </ div > < div class = \"control\" > < button class = \"button button-primary button-block button-shadow\" type = \"submit\" > Subscribe </ a > </ div > </ div > </ form > </ div > </ div > </ section > The important part of this HTML for our functionality is the form tag. Let's take a closer look at it. < form method = \"POST\" > < div class = \"footer-form newsletter-form field field-grouped\" > < div class = \"control control-expanded\" > < input class = \"input\" type = \"email\" name = \"email\" placeholder = \"Your best email&hellip;\" > </ div > < div class = \"control\" > < button class = \"button button-primary button-block button-shadow\" type = \"submit\" > Subscribe </ a > </ div > </ div > </ form > This contains one input , for the user's email address, and a button for submitting that email address. When the user clicks on the button, an HTTP request will be sent from their browser to our Flask backend, containing the email address. As per the method attribute of the form tag, this will be a [POST request. Recall that the Python code we entered in the last section provided for both GET and POST HTTP requests. As submitting this form will also send a request to \"/\", we can differentiate between a user browsing to our website ( GET ) and subscribing to our mailing list ( POST ) by looking at the HTTP method. We'll do that in the next section.","title":"Implementing the Subscribe Button"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#subscribe-functionality-in-flask","text":"Return to the app.py file. Find this line: @app . route ( \"/\" , methods [ \"GET\" , \"POST\" ]) Just above it, enter this code: def subscribe ( user_email , email_list , api_key ): return requests . post ( \"https://api.mailgun.net/v3/lists/\" + email_list + \"/members\" , auth = ( 'api' , api_key ), data = { 'subscribed' : True , 'address' : user_email ,}) This function is called when a user clicks the \"Subscribe\" button. It takes three arguments: user_email : The email the user has entered. email_list : Your Mailgun alias address. api_key : Your Mailgun secret API key. The real logic is contained in the return line. Here, we use requests.post() to add the user_email to our email_list , by sending (or \"posting\") all of the values in data to Mailgun's email list API . Next, modify the current index() function like below, replacing MAILGUN_ALIAS and YOUR-MAILGUN-PRIVATE-KEY with the email alias and private API key we previously retrieved: @app . route ( \"/\" , methods [ \"GET\" , \"POST\" ]) def index (): if request . method == \"POST\" : user_email = request . form . get ( 'email' ) response = subscribe ( user_email , 'MAILGUN_ALIAS' , 'YOUR-MAILGUN-PRIVATE-KEY' ) return render_template ( \"index.html\" ) In the previous section , we added the POST method to the subscribe button. We will therefor know when someone has clicked the subscribe button with the line: if request . method == \"POST\" : If they've clicked the subscribe button, we obtain the email they entered by referencing the relevant input field's name attribute in request.form.get , and adding the email to the mailing list our subscribe method. Try it out: enter an email address and hit \"Subscribe\". Navigate back to the \"Mailing lists\" tab on Mailgun and click on the list we created. You will find the email address you just submitted under \"Recipients\". All that's left is to add functionality to our \"Buy Now\" button.","title":"Subscribe functionality in Flask"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#implementing-buy-now-with-stripe-checkout","text":"Stripe Checkout allows business owners to accept payments on their web applications. Let's create an account . After creating an account, log in and find your API keys by clicking \"Developers\" then \"API keys\" on the dashboard. Here we'll see two API keys \u2013 a publishable API key, and a secret API key. You can think of these as a username and password. Stripe uses the publishable API key to identify your account, and the secret API key to ensure it's really you using it. Open the app.py file. Above the subscribe function, add the following lines, replacing YOUR PUBLISHABLE KEY HERE and YOUR SECRET KEY HERE appropriately: app . config [ 'STRIPE_PUBLISH_KEY' ] = 'YOUR PUBLISHABLE KEY HERE' app . config [ 'STRIPE_SECRET_KEY' ] = 'YOUR SECRET KEY HERE' stripe . api_key = app . config [ 'STRIPE_SECRET_KEY' ] In thid code, we place the two Stripe keys in our Flask app's configuration settings for ease of access, then set our Stripe secret API key. These are test API keys that we'll use to check out our product. With these keys, no charges will be incurred when making payments. However, before we can make a payment, we need a product, so let's create one. Return to Stripe, log in, and navigate to the \"Products\" tab on the dashboard.","title":"Implementing \"Buy Now\" with Stripe Checkout"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#creating-a-product","text":"Create a product by doing the following: Click \"Add product\" on the top right. Name the product. Add a description and price. Choose \"One time\" payment. Click \"Save product\" After the last step, save the API key found in the \"Pricing\" section. We'll use this API key to tell Stripe which product we want our customers to pay for.","title":"Creating a product"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#adding-functionality-in-flask","text":"Time to create the \"Buy Now\" button logic. Open app.py again and modify the index function accordingly. Replace \"YOUR-PRICE-API-KEY\" with the API key for your product, that we saved in the previous section. @app . route ( \"/\" , methods = [ \"GET\" , \"POST\" ]) def index (): session = stripe . checkout . Session . create ( payment_method_types = [ 'card' ], mode = 'payment' , success_url = 'https://example.com/success' , cancel_url = 'https://example.com/cancel' , line_items = [{ 'price' : 'YOUR-PRICE-API-KEY' , 'quantity' : 1 , }] ) if request . method == \"POST\" : user_email = request . form . get ( 'email' ) response = subscribe ( user_email , 'MAILGUN_ALIAS' , 'YOUR-MAILGUN-PRIVATE-KEY' ) return render_template ( \"index.html\" , checkout_id = session [ 'id' ], checkout_pk = app . config [ 'STRIPE_PK' ], ) We use the stripe library to create a new \"Session\" object. This object contains multiple variables affecting how our customers interact with the \"Buy Now\" button. For more information on these variables, see Stripe's documentation . We also return two new variables \u2013 checkout_id and checkout_pk . checkout_id , which we get from Stripe, stores information about the potential purchase (price, payment type, etc). checkout_pk stores our private API key, which we added to the Flask app's configuration settings above. When a customer buys our product, their money is sent to the account associated with this private API key. Let's see how our HTML will use these new variables and redirect us to the Stripe Checkout page.","title":"Adding functionality in Flask"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#buy-now-button-functionality-in-the-html-file","text":"With our Flask logic finished, we can implement the \"Buy Now\" button functionality in our index.html file. Open the index.html and find this section: < div class = \"hero-copy\" > < h1 class = \"hero-title mt-0\" > Landing template for startups </ h1 > < p class = \"hero-paragraph\" > Our landing page template works on all devices, so you only have to set it up once, and get beautiful results forever. </ p > < div class = \"hero-cta\" >< a class = \"button button-shadow\" href = \"#\" > Learn more </ a >< a id = 'checkout-button' class = \"button button-primary button-shadow\" href = \"#\" > Buy Now </ a ></ div > </ div > Directly below the </div> line, add: < script src = \"https://js.stripe.com/v3/\" ></ script > < script > const checkout_pk = '{{checkout_pk}}' ; const checkout_id = '{{checkout_id}}' ; var stripe = Stripe ( checkout_pk ) const button = document . querySelector ( '#checkout-button' ) button . addEventListener ( 'click' , event =>{ stripe . redirectToCheckout ({ sessionId : checkout_id }). then ( function ( result ){ }); }) </ script > This code adds a JavaScript event which will trigger when the customer clicks the \"Buy Now\" button, and will redirect them to the Stripe Checkout page. The Stripe Checkout page changes according to the information stored in checkout_id . Also, take a look at the Jinja code in these lines: const checkout_pk = '{{checkout_pk}}' ; const checkout_id = '{{checkout_id}}' ; When the index.html template is rendered before being served to the user, Flask will substitute in the current values of the Python variables that we passed to render_template() . While checkout_pk will remain the same throughout, checkout_id will be unique for each purchase. The \"Buy Now\" button is good to go \u2013 run app.py again. Try making a payment using the test credit card number 4242 4242 4242 4242 with any name, expiration date, and security code. No charges will be incurred.","title":"\"Buy Now\" button functionality in the HTML file"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#hosting-the-application-on-code-capsules","text":"Now that we've added all the functionality, we need to create some files that Code Capsules will use when hosting our application. We'll also take a look at a security problem in our current application, and how to fix it before we go live.","title":"Hosting the Application on Code Capsules"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#creating-the-requirementstxt-file-and-procfile","text":"To host this application on Code Capsules, we need to create a requirements.txt file and a Procfile . In the project directory, ensure the virtual environment is activated and then enter pip3 freeze > requirements.txt . Create another file named Procfile , containg the line web: gunicorn app:app . With the requirements.txt file, Code Capsules will now know what libraries to install to run the application. The Procfile tells Code Capsules to use the gunicorn WSGI server to serve HTML rendered by Flask to end-users. Now we can fix that security problem mentioned before, and host the application.","title":"Creating the \"requirements.txt\" file and procfile"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#removing-secret-keys","text":"We need to send our application to GitHub so Code Capsules can host it. But currently this project's code contains all of our API keys. It is considered very poor practice to send personal API keys to GitHub, especially public repositories. Anyone could find them and incur charges on your debit card. Luckily, there is a workaround. By working with environment variables , we can use our API keys on Code Capsules without exposing them on GitHub. We will alter our application to retrieve our API keys from environment variables, which we will set on Code Capsules. To do this, change the code at the top of app.py as follows: from flask import Flask , render_template , request import requests , stripe , os app = Flask ( __name__ ) app . config [ 'STRIPE_PK' ] = os . getenv ( \"STRIPE_PK\" ) app . config [ 'STRIPE_SK' ] = os . getenv ( \"STRIPE_SK\" ) stripe . api_key = app . config [ 'STRIPE_SK' ] Notice that we've imported a new Python module, os , which allows us to retrieve with environment variables using the os.getenv() method. We've now done this with our Stripe publishable and secret API keys and our Mailgun secret key. On Code Capsules, we'll set environment variables named 'STRIPE_PK' , 'STRIPE_SK' , and 'MAILGUN_SK' . This way, our API keys do not have to be stored on GitHub and will remain secret. Notice, we aren't adding environment variables for the Stripe product API key. This doesn't contain any sensitive information. It just displays a product's price. Your final app.py code should look like this: from flask import Flask , render_template , request import requests , stripe , os app = Flask ( __name__ ) app . config [ 'STRIPE_PK' ] = os . getenv ( \"STRIPE_PK\" ) app . config [ 'STRIPE_SK' ] = os . getenv ( \"STRIPE_SK\" ) stripe . api_key = app . config [ 'STRIPE_SK' ] def subscribe ( user_email , email_list , api_key ): return requests . post ( \"https://api.mailgun.net/v3/lists/\" + email_list + \"/members\" , auth = ( 'api' , api_key ), data = { 'subscribed' : True , 'address' : user_email ,}) @app . route ( \"/\" , methods = [ \"GET\" , \"POST\" ]) def index (): session = stripe . checkout . Session . create ( payment_method_types = [ 'card' ], mode = 'payment' , success_url = 'https://example.com/success' , cancel_url = 'https://example.com/cancel' , line_items = [{ 'price' : 'YOUR-PRICE-API-KEY' , 'quantity' : 1 , }] ) if request . method == \"POST\" : user_email = request . form . get ( 'email' ) response = subscribe ( user_email , 'MAILGUN_ALIAS' , os . getenv ( \"MAILGUN_SK\" )) return render_template ( \"index.html\" , checkout_id = session [ 'id' ], checkout_pk = app . config [ 'STRIPE_PK' ], ) if __name__ == '__main__' : app . run ( debug = True ) We can now safely host our application.","title":"Removing secret keys"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#pushing-to-github-and-hosting-the-application-on-code-capsules","text":"Before we create the Capsule that will host our code, take the following steps: Create a GitHub repository for the application. Send all code within the project directory to the repository on GitHub. Log in to Code Capsules . Grant Code Capsules access to the repository. Create a Team and Space as necessary. Now let's create the Capsule: Click \"Create A New Capsule\". Select your repository. Choose the Backend Capsule type. Create the Capsule. All that's left is to set the environment variables. Navigate to the Capsule and click on the \"Config\" tab. Use the image below as a guide to properly add your environment variables. Replace each value with the appropriate API key. After entering the API keys, make sure to click \"Update\" . All done \u2013 now anyone can view the web application and interact with the \"Buy Now\" and \"Subscribe\" buttons.","title":"Pushing to GitHub and hosting the application on Code Capsules"},{"location":"tutorials/stripe-checkout-and-email-with-flask/#further-reading","text":"We covered a lot in this tutorial: how to use Flask to implement functionality for frontend code, how to set up an email subscriber list, and how to work with Stripe. Earlier I mentioned more information on the url_for() function. Check out Flask's documentation for more information. For further information on how Jinja templates work and what can be done with them, check out this link to learn more about Flask templating and Jinja2 . Now that you have a functional email subscriber list, you may be interested in sending emails to your list .","title":"Further Reading"}]}